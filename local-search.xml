<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nordic IoT 开发：起点</title>
    <link href="/2022/07/25/nordic-iot-dev-starting-point/"/>
    <url>/2022/07/25/nordic-iot-dev-starting-point/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.nordicsemi.com/">Nordic Semiconductor</a> 是一家总部位于挪威的无厂半导体公司，其专注于为物联网领域提供无线通信技术。截止到本文的编写日，Nordic 的物联网产品已经十分丰富，以下是一张从官网中截取的产品介绍图：</p><p><img src="/images/nordic-iot-dev-starting-point/nordic-product-guide.png" alt="Nordic Product Guide"></p><p>Nordic 提供了 <a href="https://www.nordicsemi.com/Products/Development-software/nrf-connect-sdk">nRF Connect SDK</a> 以方便开发者在 Nordic 的 nRF 系列芯片上进行应用开发。</p><blockquote><p>nRF Connect SDK 也托管在 GitHub 上：<a href="https://github.com/nrfconnect/sdk-nrf">https://github.com/nrfconnect/sdk-nrf</a>。</p></blockquote><p>nRF Connect SDK 包含了蜂窝式物联网（<a href="https://www.gsma.com/iot/long-term-evolution-machine-type-communication-lte-mtc-cat-m1/">LTE-M</a> 和 <a href="https://www.gsma.com/iot/narrow-band-internet-of-things-nb-iot/">NB-IoT</a>）、<a href="https://www.bluetooth.com/learn-about-bluetooth/tech-overview/">Bluetooth Low Energy</a>、<a href="https://www.threadgroup.org/">Thread</a>、<a href="https://csa-iot.org/all-solutions/zigbee/">Zigbee</a> 和 <a href="https://www.bluetooth.com/learn-about-bluetooth/recent-enhancements/mesh/">Bluetooth Mesh</a> 的示例和参考实现，以及 nRF 系列芯片的驱动实现。nRF Connect SDK 还包含了为资源受限的连接设备设计的 <a href="https://zephyrproject.org/">Zephyr</a> 实时操作系统。</p><p>nRF Connect SDK 由各种代码库组成，并使用 <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/zephyr/develop/west/index.html#west">West</a> 工具进行管理。在这些代码库中值得注意的是：</p><ul><li><a href="https://github.com/nrfconnect/sdk-nrf">sdk-nrf</a> - 包含专门针对 nRF 系列芯片的应用程序、示例、库和驱动程序。</li><li><a href="https://github.com/nrfconnect/sdk-nrfxlib">sdk-nrfxlib</a> - 包含二进制格式的闭源库和模块。</li><li><a href="https://github.com/nrfconnect/sdk-zephyr">sdk-zephyr</a> - 包含 Zephyr 项目的一个分支，它提供了一个实时操作系统。</li><li><a href="https://github.com/nrfconnect/sdk-mcuboot">sdk-mcuboot</a> - 包含 MCUboot 项目的一个分支，它提供了一个安全的引导加载程序。</li></ul><p>nRF Connect SDK 使用了 Zephyr 项目的构建方法，下图展示了 nRF Connect SDK 的构建方法和使用的工具：</p><p><img src="/images/nordic-iot-dev-starting-point/ncs-toolchain.svg" alt="nRF Connect SDK tools and configuration methods"></p><ul><li><a href="https://docs.zephyrproject.org/latest/build/kconfig/index.html">Kconfig</a> - 生成配置库和子系统的定义。</li><li><a href="https://docs.zephyrproject.org/latest/build/dts/index.html">Devicetree</a> - 描述硬件。</li><li><a href="https://docs.zephyrproject.org/latest/build/cmake/index.html">CMake</a> - 基于 <code>CMakeLists.txt</code> 文件生成构建文件。</li><li><a href="https://ninja-build.org/">Ninja</a> - 类似于 make，使用构建文件来构建程序。</li><li><a href="https://gcc.gnu.org/">GCC</a> - 创建可执行文件。</li></ul><p>nRF Connect SDK 提供两种安装方式：<a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/gs_installing.html">手动</a>和<a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/gs_assistant.html">自动</a>。除非你熟悉 nRF Connect SDK 所使用的工具链，否则更建议你使用自动安装。</p><hr><p>参考文档：</p><ul><li><a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/index.html">Welcome to the nRF Connect SDK!</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IoT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nRF Connect SDK</tag>
      
      <tag>Nordic Semiconductor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Devicetree Specification</title>
    <link href="/2022/07/13/devicetree-specification/"/>
    <url>/2022/07/13/devicetree-specification/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Release v0.3-40-g7e1cc17<br>30 November 2021</p></blockquote><hr><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-目的和范围"><a href="#1-1-目的和范围" class="headerlink" title="1.1 目的和范围"></a>1.1 目的和范围</h2><p>各种软件组件互相配合以初始化和引导计算机系统。在将控制权传递给 <a href="https://en.wikipedia.org/wiki/Operating_system">OS（Operating System，操作系统）</a> 、<a href="https://en.wikipedia.org/wiki/Bootloader">Bootloader（引导加载程序）</a> 或 <a href="https://en.wikipedia.org/wiki/Hypervisor">Hypervisor（管理程序）</a> 等软件之前， <a href="https://en.wikipedia.org/wiki/Firmware">Firmware（固件）</a> 可能会对系统硬件执行低级初始化。Bootloader 和 Hypervisor 可以依次加载并将控制权转移给 OS。标准、一致的接口和约定有利于这些软件组件之间的交互。在本文档中，术语 <em>引导程序（boot program）</em> 用于泛指初始化系统状态并执行另一个软件组件（称为 <em>客户程序（client program）</em> ）的软件组件。引导程序的示例包括：Firmware、Bootloader 和 Hypervisor。客户程序的示例包括：Bootloader、Hypervisor、OS 和专用程序。一个软件既可以是客户程序，也可以是引导程序（例如 Hypervisor）。</p><p>本规范，即设备树规范 (DTSpec，Devicetree Specification)，为客户程序接口定义提供了完整的引导程序，并结合了有助于开发各种系统的最低系统要求。</p><p>本规范针对嵌入式系统的要求。嵌入式系统通常由系统硬件、操作系统和应用软件组成，这些软件是为执行一组固定的特定任务而定制的。与通用计算机不同，嵌入式系统旨在由用户使用各种软件和 I&#x2F;O 设备进行定制。嵌入式系统的其他特征可能包括：</p><ul><li>一组固定的 I&#x2F;O 设备，其可能为应用程序高度定制</li><li>一块针对尺寸和成本优化的系统板</li><li>有限的用户接口</li><li>资源限制，例如有限的内存和有限的非易失性存储</li><li>实时性约束</li><li>使用多种操作系统，包括 Linux、实时操作系统，和自定义或专用的系统</li></ul><h3 id="本文档的组织"><a href="#本文档的组织" class="headerlink" title="本文档的组织"></a>本文档的组织</h3><ul><li><a href="#1-%E5%BC%95%E8%A8%80">第 1 章</a> 介绍了 DTSpec 指定的体系结构。 </li><li><a href="#2-%E8%AE%BE%E5%A4%87%E6%A0%91">第 2 章</a> 介绍了设备树的概念并描述了它的逻辑结构和标准属性。 </li><li><a href="#3-%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E8%A6%81%E6%B1%82">第 3 章</a> 规定了符合 DTSpec 的设备树所需的基本设备节点集的定义。 </li><li><a href="#4-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A">第 4 章</a> 介绍了特定设备类别和特定设备类型的设备绑定。 </li><li><a href="#5-flattened-devicetree-dtb-format">第 5 章</a> 规定了设备树的 DTB 编码。 </li><li><a href="#6-devicetree-source-dts-format-version-1">第 6 章</a> 规定了 DTS 源语言。</li></ul><h3 id="本文档中使用的约定"><a href="#本文档中使用的约定" class="headerlink" title="本文档中使用的约定"></a>本文档中使用的约定</h3><p><em>shall</em> 一词用于表示为符合标准而必须严格遵守的强制性要求，不允许违背（ <em>shall</em> 等于 <em>is required to</em> ）。</p><p><em>should</em> 一词用于表示在几种可能性中，推荐一种特别适合的，而没有提及或排除其他可能性；或者某些行为是首选但不一定是必需的；或者（以否定的形式）不赞成但不禁止某种行为（ <em>should</em> 等于 <em>is recommended that</em> ）。</p><p><em>may</em> 一词用于表示在标准限制内允许的行为（ <em>may</em> 等于 <em>is permitted</em> ）。</p><p>设备树结构的示例通常以 <em>设备树语法（Devicetree Syntax）</em> 形式展示。有关此语法的概述，请参见 <a href="#6-devicetree-source-dts-format-version-1">第 6 节</a> 。</p><blockquote><p>译者注：译文使用 <strong>必须</strong> 代替 <em>shall</em> 、 <strong>应该</strong> 代替 <em>should</em> 、 <strong>可以</strong> 代替 <em>may</em> 。</p></blockquote><h2 id="1-2-与-ieee™-1275-和-epapr-的关系"><a href="#1-2-与-ieee™-1275-和-epapr-的关系" class="headerlink" title="1.2 与 IEEE™ 1275 和 ePAPR 的关系"></a>1.2 与 IEEE™ 1275 和 ePAPR 的关系</h2><p>DTSpec 与 IEEE 1275 Open Firmware standard —— <em>IEEE Standard for Boot (Initialization Configuration) Firmware: Core Requirements and Practices [<a href="#bibliography">IEEE1275</a>]</em> 松耦合。</p><p>最初的 IEEE 1275 规范及其衍生规范，例如 CHRP [<a href="#bibliography">CHRP</a>] 和 PAPR [<a href="#bibliography">PAPR</a>] 解决了通用计算机的问题，例如一个操作系统的单个版本如何在同一系列中的多个不同计算机上工作，以及从用户安装的 I&#x2F;O 设备加载操作系统的问题。</p><p>由于嵌入式系统的性质，开放的通用计算机所面临的一些问题并不适用。DTSpec 中省略的 IEEE 1275 规范的显着特性包括：</p><ul><li>Plug-in device drivers</li><li>FCode </li><li>The programmable Open Firmware user interface based on Forth </li><li>FCode debugging </li><li>Operating system debugging</li></ul><p>从 IEEE 1275 中保留的是设备树体系结构的概念，引导程序可以通过它来描述系统硬件信息并将其传达给客户程序，从而消除客户程序对系统硬件的硬编码描述的必要。</p><p>本规范部分替代了 ePAPR [<a href="#bibliography">EPAPR</a>] 规范。ePAPR 记录了 Power ISA 如何使用 devicetree，涵盖了一般概念以及 Power ISA 特定的绑定。本文档的文本源自 ePAPR，但删除了特定于架构的绑定，或将它们移动到附录中。</p><h2 id="1-3-32-bit-和-64-bit-支持"><a href="#1-3-32-bit-和-64-bit-支持" class="headerlink" title="1.3 32-bit 和 64-bit 支持"></a>1.3 32-bit 和 64-bit 支持</h2><p>DTSpec 支持具有 32-bit 和 64-bit 寻址能力的 CPU。在适用的情况下，DTSpec 的章节描述了 32-bit 和 64-bit 寻址的任何要求或注意事项。</p><h2 id="1-4-术语定义"><a href="#1-4-术语定义" class="headerlink" title="1.4 术语定义"></a>1.4 术语定义</h2><p><strong>AMP</strong> Asymmetric Multiprocessing. Computer available CPUs are partitioned into groups, each running a distinct operating system image. The CPUs may or may not be identical.</p><p><strong>boot CPU</strong> The first CPU which a boot program directs to a client program’s entry point.</p><p><strong>Book III-E</strong> Embedded Environment. Section of the Power ISA defining supervisor instructions and related facilities used in embedded Power processor implementations.</p><p><strong>boot program</strong> Used to generically refer to a software component that initializes the system state and executes another software component referred to as a client program. Examples of a boot program include: firmware, bootloaders, and hypervisors.</p><p><strong>client program</strong> Program that typically contains application or operating system software. Examples of a client program include: bootloaders, hypervisors, operating systems, and special purpose programs.</p><p><strong>cell</strong> A unit of information consisting of 32 bits.</p><p><strong>DMA</strong> Direct memory access</p><p><strong>DTB</strong> Devicetree blob. Compact binary representation of the devicetree.</p><p><strong>DTC</strong> Devicetree compiler. An open source tool used to create DTB files from DTS files.</p><p><strong>DTS</strong> Devicetree syntax. A textual representation of a devicetree consumed by the DTC. See Appendix A Devicetree Source Format (version 1).</p><p><strong>effective address</strong> Memory address as computed by processor storage access or branch instruction.</p><p><strong>physical address</strong> Address used by the processor to access external device, typically a memory controller.</p><p><strong>Power ISA</strong> Power Instruction Set Architecture.</p><p><strong>interrupt specifier</strong> A property value that describes an interrupt. Typically information that specifies an interrupt number and sensitivity and triggering mechanism is included.</p><p><strong>secondary CPU</strong> CPUs other than the boot CPU that belong to the client program are considered secondary CPUs.</p><p><strong>SMP</strong> Symmetric multiprocessing. A computer architecture where two or more identical CPUs can share memory and IO and operate under a single operating system.</p><p><strong>SoC</strong> System on a chip. A single computer chip integrating one or more CPU core as well as number of other peripherals.</p><p><strong>unit address</strong> The part of a node name specifying the node’s address in the address space of the parent node.</p><p><strong>quiescent CPU</strong> A quiescent CPU is in a state where it cannot interfere with the normal operation of other CPUs, nor can its state be affected by the normal operation of other running CPUs, except by an explicit method for enabling or re-enabling the quiescent CPU.</p><h1 id="2-设备树"><a href="#2-设备树" class="headerlink" title="2. 设备树"></a>2. 设备树</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>DTSpec 指定了一个称为 <em>设备树（devicetree）</em> 的结构来描述系统硬件。引导程序会将设备树加载到客户程序的内存中，并将指向设备树的指针传递给客户程序。</p><p>本章描述了设备树的逻辑结构，并指定了一组用于描述设备节点的基本属性。 <a href="#3-%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E8%A6%81%E6%B1%82">第 3 章</a> 指定了一个 DTSpec-compliant 的设备树所需的某些设备节点。 <a href="#4-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A">第 4 章</a> 描述了 DTSpec-defined 的设备绑定（binding） —— 表示某些设备类型或设备类别的要求。 <a href="#5-flattened-devicetree-dtb-format">第 5 章</a> 描述了设备树的内存编码。</p><p>设备树是一种树形数据结构，其节点描述系统中的设备。每个节点都有描述所代表设备特征的属性&#x2F;值对。除了根节点之外，每个节点都有且只有一个父节点。</p><p>一个 DTSpec-compliant 的设备树描述了系统中不一定能被客户程序动态检测到的设备信息。例如，PCI 的体系结构使客户程序能够探测和检测已连接的设备，因此可能不需要描述 PCI 设备的设备树节点。但是，如果无法通过探测检测到，则需要设备节点来描述系统中的 PCI host bridge 设备。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>Fig. 2.1 展示了一个简单的设备树表示示例，该设备树几乎足以引导一个简单的操作系统，其中描述了平台类型、CPU、内存和单个 UART。设备节点与每个节点内的属性和值一起展示。</p><p><img src="/images/devicetree-specification/fig2.1.png" alt="Fig. 2.1: Devicetree Example"></p><h2 id="2-2-设备树结构和约定"><a href="#2-2-设备树结构和约定" class="headerlink" title="2.2 设备树结构和约定"></a>2.2 设备树结构和约定</h2><h3 id="2-2-1-节点名"><a href="#2-2-1-节点名" class="headerlink" title="2.2.1 节点名"></a>2.2.1 节点名</h3><h4 id="节点命名要求"><a href="#节点命名要求" class="headerlink" title="节点命名要求"></a>节点命名要求</h4><p>设备树中的每个节点都要根据以下约定命名：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span><span class="hljs-title">-name</span>@unit-address<br></code></pre></td></tr></table></figure><p><code>node-name</code> 部分指定节点的名称。它的长度 <strong>必须</strong> 为 1 到 31 个字符，并且仅由 Table 2.1 中的字符集中的字符组成。</p><table><caption style="caption-side: top">Table 2.1: Valid characters for node names</caption><thead>  <tr>    <th style="text-align: center">Character</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">0-9</td>    <td>digit</td>  </tr>  <tr>    <td style="text-align: center">a-z</td>    <td>lowercase letter</td>  </tr>  <tr>    <td style="text-align: center">A-Z</td>    <td>uppercase letter</td>  </tr>  <tr>    <td style="text-align: center">,</td>    <td>comma</td>  </tr>  <tr>    <td style="text-align: center">.</td>    <td>period</td>  </tr>  <tr>    <td style="text-align: center">_</td>    <td>underscore</td>  </tr>  <tr>    <td style="text-align: center">+</td>    <td>plus sign</td>  </tr>  <tr>    <td style="text-align: center">-</td>    <td>dash</td>  </tr></tbody></table><p><code>node-name</code> <strong>必须</strong> 以小写或大写字母开头，并应描述设备的一般类别。</p><p><code>unit-address</code> 部分特定于节点所在的总线类型。它由 Table 2.1 中字符集中的一个或多个 ASCII 字符组成。<code>unit-address</code> 必须与节点的 <code>reg</code> 属性中指定的第一个地址匹配。如果节点没有 <code>reg</code> 属性，则必须省略 <code>@unit-address</code> 并且 <code>node-name</code> 单独将节点与树中同一级的其他节点区分开来。特定总线的绑定可以为 <code>reg</code> 的格式和 <code>unit-address</code> 指定额外的、更具体的要求。</p><p>在没有 <code>@unit-address</code> 的情况下，<code>node-name</code> 在树中同一级的任何属性名称中 <strong>必须</strong> 是唯一的。</p><p>根节点没有 <code>node-name</code> 或 <code>unit-address</code>。它由正斜杠（/）标识。</p><p><img src="/images/devicetree-specification/fig2.2.png" alt="Fig. 2.2: Examples of Node Names"></p><p>在 Fig. 2.2 中：</p><ul><li>名为 cpu 的节点通过其 <code>unit-address</code> 值 0 和 1 进行区分。</li><li>名为 ethernet 的节点通过其 <code>unit-address</code> 值 fe002000 和 fe003000 进行区分。</li></ul><h3 id="2-2-2-通用名建议"><a href="#2-2-2-通用名建议" class="headerlink" title="2.2.2 通用名建议"></a>2.2.2 通用名建议</h3><p>节点的名称应该在一定程度上是通用的，它反映设备的功能，而不是其精确的编程模型。如果合适，名称应该是以下选项之一：</p><ul style="display: grid; grid-template-columns: repeat(3, 1fr);">  <li>adc</li>  <li>accelerometer</li>  <li>air-pollution-sensor</li>  <li>atm</li>  <li>audio-codec</li>  <li>audio-controller</li>  <li>backlight</li>  <li>bluetooth</li>  <li>bus</li>  <li>cache-controller</li>  <li>camera</li>  <li>can</li>  <li>charger</li>  <li>clock</li>  <li>clock-controller</li>  <li>co2-sensor</li>  <li>compact-flash</li>  <li>cpu</li>  <li>cpus</li>  <li>crypto</li>  <li>disk</li>  <li>display</li>  <li>dma-controller</li>  <li>dsi</li>  <li>dsp</li>  <li>eeprom</li>  <li>efuse</li>  <li>endpoint</li>  <li>ethernet</li>  <li>ethernet-phy</li>  <li>fdc</li>  <li>flash</li>  <li>gnss</li>  <li>gpio</li>  <li>gpu</li>  <li>gyrometer</li>  <li>hdmi</li>  <li>hwlock</li>  <li>i2c</li>  <li>i2c-mux</li>  <li>ide</li>  <li>interrupt-controller</li>  <li>iommu</li>  <li>isa</li>  <li>keyboard</li>  <li>key</li>  <li>keys</li>  <li>lcd-controller</li>  <li>led</li>  <li>leds</li>  <li>led-controller</li>  <li>light-sensor</li>  <li>lora</li>  <li>magnetometer</li>  <li>mailbox</li>  <li>mdio</li>  <li>memory</li>  <li>memory-controller</li>  <li>mmc</li>  <li>mmc-slot</li>  <li>mouse</li>  <li>nand-controller</li>  <li>nvram</li>  <li>oscillator</li>  <li>parallel</li>  <li>pc-card</li>  <li>pci</li>  <li>pcie</li>  <li>phy</li>  <li>pinctrl</li>  <li>pmic</li>  <li>pmu</li>  <li>port</li>  <li>ports</li>  <li>power-monitor</li>  <li>pwm</li>  <li>regulator</li>  <li>reset-controller</li>  <li>rng</li>  <li>rtc</li>  <li>sata</li>  <li>scsi</li>  <li>serial</li>  <li>sound</li>  <li>spi</li>  <li>sram-controller</li>  <li>ssi-controller</li>  <li>syscon</li>  <li>temperature-sensor</li>  <li>timer</li>  <li>touchscreen</li>  <li>tpm</li>  <li>usb</li>  <li>usb-hub</li>  <li>usb-phy</li>  <li>video-codec</li>  <li>vme</li>  <li>watchdog</li>  <li>wifi</li></ul><h3 id="2-2-3-路径名"><a href="#2-2-3-路径名" class="headerlink" title="2.2.3 路径名"></a>2.2.3 路径名</h3><p>通过指定从根节点到所有后代节点到所需节点的完整路径，可以唯一标识设备树中的节点。</p><p>指定设备路径的约定是：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/<span class="hljs-keyword">node</span><span class="hljs-title">-name-1</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-name-2</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-name-N</span><br></code></pre></td></tr></table></figure><p>例如，在 Fig. 2.2 中，cpu #1 的设备路径是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/cpus/</span>cpu@<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>根节点的路径是 /。</p><p>如果到节点的完整路径是明确的，则可以省略单元地址。</p><p>如果客户程序遇到不明确的路径，则其行为未定义。</p><h3 id="2-2-4-属性"><a href="#2-2-4-属性" class="headerlink" title="2.2.4 属性"></a>2.2.4 属性</h3><p>设备树中的每个节点都有描述节点特征的属性。属性由名称和值组成。</p><h4 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h4><p>属性名是 Table 2.2 中展示的字符中的 1 到 31 个字符的字符串</p><table><caption style="caption-side: top">Table 2.2: Valid characters for property names</caption><thead>  <tr>    <th style="text-align: center">Character</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">0-9</td>    <td>digit</td>  </tr>  <tr>    <td style="text-align: center">a-z</td>    <td>lowercase letter</td>  </tr>  <tr>    <td style="text-align: center">A-Z</td>    <td>uppercase letter</td>  </tr>  <tr>    <td style="text-align: center">,</td>    <td>comma</td>  </tr>  <tr>    <td style="text-align: center">.</td>    <td>period</td>  </tr>  <tr>    <td style="text-align: center">_</td>    <td>underscore</td>  </tr>  <tr>    <td style="text-align: center">+</td>    <td>plus sign</td>  </tr>  <tr>    <td style="text-align: center">?</td>    <td>question mark</td>  </tr>  <tr>    <td style="text-align: center">#</td>    <td>hash</td>  </tr>  <tr>    <td style="text-align: center">-</td>    <td>dash</td>  </tr></tbody></table><p>非标准属性名应指定唯一的字符串前缀，例如股票代码，标识定义该属性的公司或组织的名称。例子：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">fsl,</span>channel-fifo-len<br><span class="hljs-built_in">ibm,</span>ppc-interrupt-server#s<br><span class="hljs-built_in">linux,</span>network-index<br></code></pre></td></tr></table></figure><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><p>属性值是包含与属性相关信息的零个或多个字节的数组。</p><p>如果传达 true-false 信息，那么属性可能具有空值。在这种情况下，属性的存在或缺失足以描述该信息。</p><p>Table 2.3 描述了 DTSpec 定义的一组基本值类型。</p><table><caption style="caption-side: top">Table 2.3: Property values</caption><thead>  <tr>    <th>Value</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td>&lt;empty&gt;</td>    <td>Value is empty. Used for conveying true-false information, when the presence or absence of the property itself is sufficiently descriptive.</td>  </tr>  <tr>    <td>&lt;u32&gt;</td>    <td>      A 32-bit integer in big-endian format. Example: the 32-bit value 0x11223344 would be represented in memory as:      <pre>        address     11        address+1   22        address+2   33        address+3   44      </pre>    </td>  </tr>  <tr>    <td>&lt;u64&gt;</td>    <td>      Represents a 64-bit integer in big-endian format. Consists of two <u32> values where the first value contains the most significant bits of the integer and the second value contains the least significant bits.<br>      Example: the 64-bit value 0x1122334455667788 would be represented as two cells as: &lt;0x11223344 0x55667788&gt;.<br>      The value would be represented in memory as:      <pre>        address     11        address+1   22        address+2   33        address+3   44        address+4   55        address+5   66        address+6   77        address+7   88      </pre>    </td>  </tr>  <tr>    <td>&lt;string&gt;</td>    <td>      Strings are printable and null-terminated. Example: the string “hello” would be represented in memory as:      <pre>        address     68  'h'        address+1   65  'e'        address+2   6C  'l'        address+3   6C  'l'        address+4   6F  'o'        address+5   00  '\0'      </pre>    </td>  </tr>  <tr>    <td>&lt;prop-encoded-array&gt;</td>    <td>Format is specific to the property. See the property definition.</td>  </tr>  <tr>    <td>&lt;phandle&gt;</td>    <td>A &lt;u32&gt; value. A <em>phandle</em> value is a way to reference another node in the devicetree. Any node that can be referenced defines a phandle property with a unique &lt;u32&gt; value. That number is used for the value of properties with a phandle value type.</td>  </tr>  <tr>    <td>&lt;stringlist&gt;</td>    <td>      A list of &lt;string&gt; values concatenated together.<br>      Example: The string list “hello”,”world” would be represented in memory as:      <pre>        address     68  'h'        address+1   65  'e'        address+2   6C  'l'        address+3   6C  'l'        address+4   6F  'o'        address+5   00  '\0'        address+6   77  'w'        address+7   6F  'o'        address+8   72  'r'        address+9   6C  'l'        address+10  64  'd'        address+11  00  '\0'      </pre>    </td>  </tr></tbody></table><h2 id="2-3-标准属性"><a href="#2-3-标准属性" class="headerlink" title="2.3 标准属性"></a>2.3 标准属性</h2><p>DTSpec 为设备节点指定了一组标准属性。本节详细介绍了这些属性。由 DTSpec（见 <a href="#3-%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E8%A6%81%E6%B1%82">第 3 章</a> ）定义的设备节点可以指定有关使用标准属性的附加要求或约束。 <a href="#4-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A">第 4 章</a> 描述了特定设备的表示，也可能指定附加要求。</p><blockquote><p>注：本文档中的所有设备树节点示例都使用 DTS（Devicetree Source）格式来指定节点和属性。</p></blockquote><h3 id="2-3-1-compatible"><a href="#2-3-1-compatible" class="headerlink" title="2.3.1 compatible"></a>2.3.1 compatible</h3><p>属性名：compatible</p><p>值类型：&lt;stringlist&gt;</p><p>描述：</p><p><code>compatible</code> 属性值由一个或多个定义设备特定编程模型的字符串组成。客户程序应使用此字符串列表来选择设备驱动程序。属性值由空终止字符串的串联列表组成，从特定到通用。它们允许设备表达其与一系列类似设备的兼容性，可能允许单个设备驱动程序与多个设备匹配。</p><p>推荐格式为 <code>&quot;manufacturer,model&quot;</code>，其中 <code>manufacturer</code> 是描述制造商名称的字符串（如股票代码），<code>model</code> 指定型号。</p><p>compatible 字符串 <strong>应该</strong> 仅由小写字母、数字和连接符组成，并且 <strong>应该</strong> 以字母开头。单个逗号通常仅在供应商前缀之后使用。<strong>不应</strong> 使用下划线。</p><p>示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;fsl,mpc8641&quot;</span>, <span class="hljs-string">&quot;ns16550&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在此示例中，操作系统将首先尝试查找支持 fsl,mpc8641 的设备驱动程序。如果未找到驱动程序，它将尝试找到支持更为通用的 ns16550 设备类型的驱动程序。</p><h3 id="2-3-2-model"><a href="#2-3-2-model" class="headerlink" title="2.3.2 model"></a>2.3.2 model</h3><p>属性名：model</p><p>值类型：&lt;string&gt;</p><p>描述：</p><p><code>model</code> 属性值是一个 &lt;string&gt;，它指定设备制造商的型号。</p><p>推荐格式为：<code>&quot;manufacturer,model&quot;</code>，其中 <code>manufacturer</code> 是描述制造商名称的字符串（如股票代码），<code>model</code> 指定型号。</p><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">model</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,MPC8349EMITX&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-3-phandle"><a href="#2-3-3-phandle" class="headerlink" title="2.3.3 phandle"></a>2.3.3 phandle</h3><p>属性名：phandle</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>phandle</code> 属性为设备树中唯一的节点指定一个数字标识符。<code>phandle</code> 属性值由需要引用与该属性关联的节点的其他节点使用。</p><p>示例：</p><p>参阅以下设备树摘录：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">pic@10000000</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">phandle</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">interrupt-controller</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x10000000</span> <span class="hljs-number">0x100</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p><code>phandle</code> 值定义为 1。另一个设备节点可以使用 <code>phandle</code> 值 1 来引用 pic 节点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">another-device-node</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：可能会遇到旧版本的设备树，其中包含此属性的弃用形式，称为 <code>linux,phandle</code>。为了兼容性，如果 <code>phandle</code> 属性不存在，客户程序可能希望支持 <code>linux,phandle</code>。这两个属性的含义和用途是相同的。</p></blockquote><blockquote><p>注：DTS 中的大多数设备树（请参阅附录 A）不包含显式的 <code>phandle</code> 属性。当 DTS 编译为二进制 DTB 格式时，DTC 工具会自动插入 <code>phandle</code> 属性。</p></blockquote><h3 id="2-3-4-status"><a href="#2-3-4-status" class="headerlink" title="2.3.4 status"></a>2.3.4 status</h3><p>属性名：status</p><p>值类型：&lt;string&gt;</p><p>描述：</p><p><code>status</code> 属性表示设备的运行状态。缺少 <code>status</code> 属性应被视为该属性以 <code>&quot;okay&quot;</code> 值存在。有效值在 Table 2.4 中列出并定义。</p><table><caption style="caption-side: top">Table 2.4: Values for status property</caption><thead>  <tr>    <th>Value</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td>"okay"</td>    <td>Indicates the device is operational.</td>  </tr>  <tr>    <td>"disabled"</td>    <td>      Indicates that the device is not presently operational, but it might become operational in the future (for example, something is not plugged in, or switched off).<br>      Refer to the device binding for details on what disabled means for a given device.    </td>  </tr>  <tr>    <td>"reserved"</td>    <td>Indicates that the device is operational, but should not be used. Typically this is used for devices that are controlled by another software component, such as platform firmware.</td>  </tr>  <tr>    <td>"fail"</td>    <td>Indicates that the device is not operational. A serious error was detected in the device, and it is unlikely to become operational without repair.</td>  </tr>  <tr>    <td>"fail-sss"</td>    <td>Indicates that the device is not operational. A serious error was detected in the device and it is unlikely to become operational without repair. The <em>sss</em> portion of the value is specific to the device and indicates the error condition detected.</td>  </tr></tbody></table><h3 id="2-3-5-address-cells-和-size-cells"><a href="#2-3-5-address-cells-和-size-cells" class="headerlink" title="2.3.5 #address-cells 和 #size-cells"></a>2.3.5 #address-cells 和 #size-cells</h3><p>属性名：#address-cells, #size-cells</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>#address-cells</code> 和 <code>#size-cells</code> 属性可用于在设备树层次结构中具有子节点的任何设备节点，并描述应如何寻址子设备节点。 <code>#address-cells</code> 属性定义了用于对子节点的 <code>reg</code> 属性中的 <code>address</code> 字段进行编码的 &lt;u32&gt; cell 的数量。 <code>#size-cells</code> 属性定义了用于对子节点的 <code>reg</code> 属性中的 <code>size</code> 字段进行编码的 &lt;u32&gt; cell 的数量。</p><p><code>#address-cells</code> 和 <code>#size-cells</code> 属性不是从设备树中的祖先那里继承的。它们 <strong>必须</strong> 被明确定义。</p><p>一个 DTSpec-compliant 的引导程序 <strong>必须</strong> 在所有具有子节点的节点上提供 <code>#address-cells</code> 和 <code>#size-cells</code> 。</p><p>如果缺失，客户程序 <strong>应该</strong> 假定 <code>#address-cells</code> 的默认值为 2，<code>#size-cells</code> 的默认值为 1。</p><p>示例：</p><p>参阅以下设备树摘录：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br><br>    <span class="hljs-title class_">serial@4600</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ns16550&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;ipic</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>在此示例中，soc 节点的 <code>#address-cells</code> 和 <code>#size-cells</code> 属性均设置为 1。此设置指定表示子节点的 <code>address</code> 和 <code>size</code> 各需一个 cell。</p><p>serial 设备 <code>reg</code> 属性必须遵循父节点（soc）中所设置的规定 —— <code>address</code> 由单个 cell 表示（0x4600），<code>size</code> 由单个 cell 表示（0x100）。</p><h3 id="2-3-6-reg"><a href="#2-3-6-reg" class="headerlink" title="2.3.6 reg"></a>2.3.6 reg</h3><p>属性名：reg</p><p>值类型：&lt;prop-encoded-array&gt; encoded as an arbitrary number of (address, length) pairs.</p><p>描述：</p><p><code>reg</code> 属性描述了设备资源在其父总线定义的地址空间内的地址。最常见的含义是内存映射 IO 寄存器块的偏移量和长度，但在某些总线类型上可能有不同的含义。根节点定义的地址空间中的地址是 CPU 真实地址。</p><p>该值是一个 &lt;prop-encoded-array&gt;，由任意数量的地址和长度对组成，&lt;address length&gt;。 <code>address</code> 和 <code>length</code> 所需的 &lt;u32&gt; cell 数量特定于总线，由设备节点的父节点中的 <code>#address-cells</code> 和 <code>#size-cells</code> 属性指定。如果父节点为 <code>#size-cells</code> 指定值为 0，则 <code>reg</code> 值中的长度字段 <strong>必须</strong> 省略。</p><p>示例：</p><p>假设片上系统中的一个设备有两个寄存器块，一个 32-byte 块在 SOC 中的偏移量 0x3000 处，一个 256-byte 块在偏移量 0xFE00 处。<code>reg</code> 属性将编码如下（假设 <code>#address-cells</code> 和 <code>#size-cells</code> 值为 1）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">reg</span> = &lt;<span class="hljs-number">0</span>x3000 <span class="hljs-number">0</span>x20 <span class="hljs-number">0</span>xFE00 <span class="hljs-number">0</span>x100&gt;;<br></code></pre></td></tr></table></figure><h3 id="2-3-7-virtual-reg"><a href="#2-3-7-virtual-reg" class="headerlink" title="2.3.7 virtual-reg"></a>2.3.7 virtual-reg</h3><p>属性名：virtual-reg</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>virtual-reg</code> 属性指定映射到设备节点的 <code>reg</code> 属性中指定的第一个物理地址的有效地址。此属性使引导程序能够为客户程序提供已设置的虚拟到物理映射。</p><h3 id="2-3-8-ranges"><a href="#2-3-8-ranges" class="headerlink" title="2.3.8 ranges"></a>2.3.8 ranges</h3><p>属性名：ranges</p><p>值类型：&lt;empty&gt; or &lt;prop-encoded-array&gt; encoded as an arbitrary number of (child-bus-address, parent-bus-address, length) triplets.</p><p>描述：</p><p><code>ranges</code> 属性提供了一种定义总线地址空间（子地址空间）和总线节点父节点地址空间（父地址空间）之间的映射或转换的方法。</p><p><code>ranges</code> 属性值的格式是任意数量的 (child-bus-address, parent-bus-address, length) 三元组</p><ul><li><code>child-bus-address</code> 是子总线地址空间内的物理地址。表示地址的 cell 数量由总线确定，可以从该节点（ <code>ranges</code> 属性所在的节点）的 <code>#address-cells</code> 确定。</li><li><code>parent-bus-address</code> 是父总线地址空间内的物理地址。表示地址的 cell 数量由总线确定，可以从定义父地址空间的节点的 <code>#address-cells</code> 属性确定。</li><li><code>length</code> 指定子地址空间中范围的大小。表示大小的 cell 数量可以从该节点（ <code>ranges</code> 属性所在的节点）的 <code>#size-cells</code> 确定。</li></ul><p>如果该属性使用 &lt;empty&gt; 值定义，则它指定父地址空间和子地址空间相同，并且不需要地址转换。</p><p>如果该属性不存在于总线节点中，则假定该节点的子节点与父地址空间之间不存在映射。</p><p>地址翻译示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br>    <span class="hljs-attr">ranges</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0xe0000000</span> <span class="hljs-number">0x00100000</span>&gt;</span><span class="hljs-punctuation">;</span><br><br>    <span class="hljs-title class_">serial@4600</span> <span class="hljs-punctuation">&#123;</span><br>        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;serial&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ns16550&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x4600</span> <span class="hljs-number">0x100</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0xA</span> <span class="hljs-number">0x8</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;ipic</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>soc 节点指定 <code>ranges</code> 属性：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&lt;<span class="hljs-number">0</span>x0 <span class="hljs-number">0</span>xe<span class="hljs-number">0000000</span> <span class="hljs-number">0x00100000</span>&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>此属性值指定对于 1024 KB 范围的地址空间，子节点的物理地址 0x0 映射到父地址的物理地址 0xe0000000。使用此映射，serial 设备节点可以通过 load 或 store 地址 0xe0004600（偏移量为 0x4600（在 <code>reg</code> 中指定）加上在 <code>ranges</code> 中指定的 0xe0000000）来寻址。</p><h3 id="2-3-9-dma-ranges"><a href="#2-3-9-dma-ranges" class="headerlink" title="2.3.9 dma-ranges"></a>2.3.9 dma-ranges</h3><p>属性名：dma-ranges</p><p>值类型：&lt;empty&gt; or &lt;prop-encoded-array&gt; encoded as an arbitrary number of (child-bus-address, parent-bus-address, length) triplets.</p><p>描述：</p><p><code>dma-ranges</code> 属性用于描述内存映射总线的 DMA（Direct Memory Access）结构，其设备树父级可以从源自总线的 DMA 操作访问。它提供了一种定义总线物理地址空间与总线父物理地址空间之间的映射或转换的方法。</p><p><code>dma-ranges</code> 属性值的格式是任意数量的 (child-bus-address, parent-bus-address, length) 三元组。每个三元组描述一个连续的 DMA 地址范围。</p><ul><li><code>child-bus-address</code> 是子总线地址空间内的物理地址。表示地址的 cell 数量由总线确定，可以从该节点（ <code>dma-ranges</code> 属性所在的节点）的 <code>#address-cells</code> 确定。</li><li><code>parent-bus-address</code> 是父总线地址空间内的物理地址。表示地址的 cell 数量由总线确定，可以从定义父地址空间的节点的 <code>#address-cells</code> 属性确定。</li><li><code>length</code> 指定子地址空间中范围的大小。表示大小的 cell 数量可以从该节点（ <code>dma-ranges</code> 属性所在的节点）的 <code>#size-cells</code> 确定。</li></ul><h3 id="2-3-10-dma-coherent"><a href="#2-3-10-dma-coherent" class="headerlink" title="2.3.10 dma-coherent"></a>2.3.10 dma-coherent</h3><p>属性名：dma-coherent</p><p>值类型：&lt;empty&gt; </p><p>描述：</p><p>针对默认情况下 I&#x2F;O 不连贯的体系结构，<code>dma-coherent</code> 属性用于指示设备能够进行连贯的 DMA 操作。某些体系结构默认具有连贯的 DMA，并且此属性不适用于这些体系结构。</p><h3 id="2-3-11-name-deprecated"><a href="#2-3-11-name-deprecated" class="headerlink" title="2.3.11 name (deprecated)"></a>2.3.11 name (deprecated)</h3><p>属性名：name</p><p>值类型：&lt;string&gt; </p><p>描述：</p><p><code>name</code> 属性是指定节点名称的字符串。此属性已弃用，不推荐使用。但是，它可能用于较旧的 non-DTSpec-compliant 设备树。操作系统应该根据节点名的 <code>node-name</code> 部分来确定节点的名称（参见 <a href="#2-2-1-%E8%8A%82%E7%82%B9%E5%90%8D">第 2.2.1 节</a> ）。</p><h3 id="2-3-12-device-type-deprecated"><a href="#2-3-12-device-type-deprecated" class="headerlink" title="2.3.12 device_type (deprecated)"></a>2.3.12 device_type (deprecated)</h3><p>属性名：device_type</p><p>值类型：&lt;string&gt; </p><p>描述：</p><p><code>device_type</code> 属性在 IEEE 1275 中用于描述设备的 FCode 编程模型。由于 DTSpec 没有 FCode，因此不推荐新的应用使用该属性，并且它应该仅包含在 cpu 和 memory 节点上，以便与 IEEE 1275–derived 设备树兼容。</p><h2 id="2-4-中断和中断映射"><a href="#2-4-中断和中断映射" class="headerlink" title="2.4 中断和中断映射"></a>2.4 中断和中断映射</h2><p>DTSpec 采用中断树模型来表示 <em>Open Firmware Recommended Practice: Interrupt Mapping, Version 0.9 [<a href="#bibliography">b7</a>]</em> 中指定的中断。在设备树中存在一个逻辑中断树，它表示平台硬件中中断的层次结构和路由。虽然通常称为中断树，但从技术上讲，它是一个有向无环图（Directed Acyclic Graph）。</p><p>中断源到中断控制器的物理连接在设备树中以 <code>interrupt-parent</code> 属性表示。代表中断生成设备的节点包含一个 <code>interrupt-parent</code> 属性，该属性具有一个 <code>phandle</code> 值，该值指向设备的中断被路由到的设备，通常是中断控制器。如果中断生成设备没有 <code>interrupt-parent</code> 属性，则假定其中断父级为其设备树父级。</p><p>每个中断生成设备都包含一个 <code>interrupts</code> 属性，其值描述该设备的一个或多个中断源。每个源都用称为 <em>中断说明符（Interrupt Specifier）</em> 的信息表示。中断说明符的格式和含义特定于中断域，即其取决于其中断域根节点上的属性。中断域的根使用 <code>#interrupt-cells</code> 属性来定义编码中断说明符所需的 &lt;u32&gt; 值的数量。例如，对于 Open PIC 中断控制器，中断说明符采用两个 32-bit 值，由中断号和电平&#x2F;感应信息组成。</p><p>中断域是解释中断说明符的上下文。域的根是（1）中断控制器或（2）中断联结。</p><ol><li><em>中断控制器（Interrupt Controller）</em> 是一个物理设备，需要一个驱动程序来处理通过它路由的中断。它也可能级联到另一个中断域。中断控制器由设备树中该节点上存在的 <code>interrupt-controller</code> 属性指定。</li><li><em>中断联结（Interrupt Nexus）</em> 定义了一个中断域和另一个中断域之间的转换。转换基于域特定和总线特定的信息。域之间的这种转换是使用 <code>interrupt-map</code> 属性执行的。例如，PCI 控制器设备节点可以定义从 PCI 中断命名空间（INTA、INTB 等）到具有中断请求（IRQ，Interrupt Request）编号的中断控制器的转换的中断联结。</li></ol><p>中断树的根是在中断树的遍历到达没有 <code>interrupts</code> 属性的中断控制器节点时确定的，因此没有显式的中断父节点。</p><p>参见 Fig. 2.3 中的设备树图形表示示例，其中展示了中断父关系。它展示了设备树的自然结构以及每个节点在逻辑中断树中的位置。</p><p><img src="/images/devicetree-specification/fig2.3.png" alt="Fig. 2.3: Example of the interrupt tree"></p><p>在 Fig. 2.3 所示的示例中：</p><ul><li>open-pic 中断控制器是中断树的根。</li><li>中断树根有三个子节点 —— 将它们的中断直接路由到 open-pic 的设备<ul><li>device1</li><li>PCI host controller</li><li>GPIO Controller</li></ul></li><li>有三个中断域：一个植根于 open-pic 节点，一个植根于 PCI host bridge 节点，一个植根于 GPIO Controller 节点。</li><li>有两个联结节点：一个在 PCI host bridge 上，一个在 GPIO controller 上。</li></ul><h3 id="2-4-1-中断生成设备的属性"><a href="#2-4-1-中断生成设备的属性" class="headerlink" title="2.4.1 中断生成设备的属性"></a>2.4.1 中断生成设备的属性</h3><h4 id="interrupts"><a href="#interrupts" class="headerlink" title="interrupts"></a>interrupts</h4><p>属性名：interrupts</p><p>值类型：&lt;prop-encoded-array&gt; encoded as arbitrary number of interrupt specifiers</p><p>描述：</p><p>设备节点的 <code>interrupts</code> 属性定义设备生成的一个或多个中断。<code>interrupts</code> 属性的值由任意数量的中断说明符组成。中断说明符的格式由中断域根的绑定定义。</p><p><code>interrupts</code> 会被 <code>interrupts-extended</code> 属性覆盖，通常只应使用其中一个。</p><p>示例：</p><p>在 open PIC-compatible 中断域中中断说明符的常见定义由两个 cell 组成：中断号和电平&#x2F;感应信息。参见以下示例，该示例定义了一个中断说明符，中断号为 0xA，电平&#x2F;感应编码为 8。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">interrupts</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span>xA <span class="hljs-number">8</span>&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="interrupt-parent"><a href="#interrupt-parent" class="headerlink" title="interrupt-parent"></a>interrupt-parent</h4><p>属性名：interrupt-parent</p><p>值类型：&lt;phandle&gt;</p><p>描述：</p><p>由于中断树中节点的层次结构可能与设备树不匹配，因此可以使用 <code>interrupt-parent</code> 属性来明确定义中断父级。该值是中断父级的 <code>phandle</code>。如果设备中缺少此属性，则假定其中断父级为其设备树父级。</p><h4 id="interrupts-extended"><a href="#interrupts-extended" class="headerlink" title="interrupts-extended"></a>interrupts-extended</h4><p>属性名：interrupts-extended</p><p>值类型：&lt;phandle&gt; &lt;prop-encoded-array&gt;</p><p>描述：</p><p><code>interrupts-extended</code> 属性列出设备生成的中断。当设备连接到多个中断控制器时，应使用 <code>interrupts-extended</code> 代替 <code>interrupts</code> ，因为它使用每个中断说明符对父 <code>phandle</code> 进行编码。</p><p>示例：</p><p>此示例展示了具有连接到两个独立中断控制器的两个中断输出的设备如何使用 <code>interrupts-extended</code> 属性来描述连接。pic 是 <code>#interrupt-cells</code> 说明符为 2 的中断控制器，而 gic 是 <code>#interrupts-cells</code> 说明符为 1 的中断控制器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">interrupts</span>-extended = &lt;&amp;pic <span class="hljs-number">0</span>xA <span class="hljs-number">8</span>&gt;, &lt;&amp;gic <span class="hljs-number">0</span>xda&gt;;<br></code></pre></td></tr></table></figure><p><code>interrupts</code> 和 <code>interrupts-extended</code> 属性是互斥的。设备节点 <strong>应该</strong> 只使用其中之一。只有在需要与不理解 <code>interrupts-extended</code> 的软件兼容时才允许同时使用两者。如果 <code>interrupts-extended</code> 和 <code>interrupts</code> 都存在，则 <code>interrupts-extended</code> 优先。</p><h3 id="2-4-2-中断控制器的属性"><a href="#2-4-2-中断控制器的属性" class="headerlink" title="2.4.2 中断控制器的属性"></a>2.4.2 中断控制器的属性</h3><h4 id="interrupt-cells"><a href="#interrupt-cells" class="headerlink" title="#interrupt-cells"></a>#interrupt-cells</h4><p>属性名：#interrupt-cells</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>#interrupt-cells</code> 属性定义了为中断域编码中断说明符所需的 cell 数量。</p><h4 id="interrupt-controller"><a href="#interrupt-controller" class="headerlink" title="interrupt-controller"></a>interrupt-controller</h4><p>属性名：interrupt-controller</p><p>值类型：&lt;empty&gt;</p><p>描述：</p><p><code>interrupt-controller</code> 属性的存在将节点定义为中断控制器节点。</p><h3 id="2-4-3-中断联结属性"><a href="#2-4-3-中断联结属性" class="headerlink" title="2.4.3 中断联结属性"></a>2.4.3 中断联结属性</h3><p>中断联结节点 <strong>必须</strong> 具有 <code>#interrupt-cells</code> 属性。</p><h4 id="interrupt-map"><a href="#interrupt-map" class="headerlink" title="interrupt-map"></a>interrupt-map</h4><p>属性名：interrupt-map</p><p>值类型：&lt;prop-encoded-array&gt; encoded as an arbitrary number of interrupt mapping entries.</p><p>描述：</p><p><code>interrupt-map</code> 是联结节点上的一个属性，它将一个中断域与一组父中断域桥接，并指定子域中的中断说明符如何映射到它们各自的父域。</p><p>中断映射是一个表，其中每一行是一个映射条目，由五个部分组成：<code>child unit address</code> 、 <code>child interrupt specifier</code> 、 <code>interrupt-parent</code> 、 <code>parent unit address</code> 、 <code>parent interrupt specifier</code> 。</p><ul><li><code>child unit address</code> 被映射的子节点的单元地址。指定这个所需的 32-bit cell 的数量由子节点所在总线节点的 <code>#address-cells</code> 属性描述。</li><li><code>child interrupt specifier</code> 被映射的子节点的中断说明符。指定这个所需的 32-bit cell 的数量由该节点（包含 <code>interrupt-map</code> 属性的联结节点）的 <code>#interrupt-cells</code> 属性描述。</li><li><code>interrupt-parent</code> 单个 &lt;phandle&gt; 值，指向子域映射到的中断父级。</li><li><code>parent unit address</code> 中断父域中的单元地址。指定这个所需的 32-bit cell 的数量由 <code>interrupt-parent</code> 字段指向的节点的 <code>#address-cells</code> 属性描述。</li><li><code>parent interrupt specifier</code> 父域中的中断说明符。指定这个所需的 32-bit cell 的数量由 <code>interrupt-parent</code> 字段指向的节点的 <code>#interrupt-cells</code> 属性描述。</li></ul><p>通过将单元地址&#x2F;中断说明符对与中断映射中的子部分进行匹配，在中断映射表上执行查找。因为单元中断说明符中的某些字段可能不相关，所以在查找完成之前应用掩码。此掩码在 <code>interrupt-map-mask</code> 属性中定义。</p><blockquote><p>注：子节点和中断父节点都需要定义 <code>#address-cells</code> 和 <code>#interrupt-cells</code> 属性。如果不需要单元地址部分，那么 <code>#address-cells</code> <strong>必须</strong> 显式定义为零。</p></blockquote><h4 id="interrupt-map-mask"><a href="#interrupt-map-mask" class="headerlink" title="interrupt-map-mask"></a>interrupt-map-mask</h4><p>属性名：interrupt-map-mask</p><p>值类型：&lt;prop-encoded-array&gt; encoded as a bit mask</p><p>描述：</p><p>为中断树中的联结节点指定了 <code>interrupt-map-mask</code> 属性。此属性指定一个掩码，该掩码与在 <code>interrupt-map</code> 属性中指定的表中查找的传入单元中断说明符进行与运算。</p><h4 id="interrupt-cells-1"><a href="#interrupt-cells-1" class="headerlink" title="#interrupt-cells"></a>#interrupt-cells</h4><p>属性名：#interrupt-cells</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>#interrupt-cells</code> 属性定义了为中断域编码中断说明符所需的 cell 数量。</p><h3 id="2-4-4-中断映射示例"><a href="#2-4-4-中断映射示例" class="headerlink" title="2.4.4 中断映射示例"></a>2.4.4 中断映射示例</h3><p>以下展示了具有 PCI 总线控制器的设备树片段的表示和用于描述两个 PCI 槽（IDSEL 0x11,0x12）的中断路由的示例中断映射。槽 1 和 2 的 INTA、INTB、INTC 和 INTD 引脚连接到 Open PIC 中断控制器。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br><br>    <span class="hljs-title class_">open-pic</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupt-controller</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-meta">#address-cells = &lt;0&gt;;</span><br>        <span class="hljs-meta">#interrupt-cells = &lt;2&gt;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-title class_">pci</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-meta">#interrupt-cells = &lt;1&gt;;</span><br>        <span class="hljs-meta">#size-cells = &lt;2&gt;;</span><br>        <span class="hljs-meta">#address-cells = &lt;3&gt;;</span><br>        <span class="hljs-attr">interrupt-map-mask</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0xf800</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">interrupt-map</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><br><span class="hljs-params">            /* IDSEL <span class="hljs-number">0x11</span> - PCI slot <span class="hljs-number">1</span> */</span><br><span class="hljs-params">            <span class="hljs-number">0x8800</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">2</span> <span class="hljs-number">1</span> /* INTA */</span><br><span class="hljs-params">            <span class="hljs-number">0x8800</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">3</span> <span class="hljs-number">1</span> /* INTB */</span><br><span class="hljs-params">            <span class="hljs-number">0x8800</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">4</span> <span class="hljs-number">1</span> /* INTC */</span><br><span class="hljs-params">            <span class="hljs-number">0x8800</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">1</span> <span class="hljs-number">1</span> /* INTD */</span><br><span class="hljs-params">            /* IDSEL <span class="hljs-number">0x12</span> - PCI slot <span class="hljs-number">2</span> */</span><br><span class="hljs-params">            <span class="hljs-number">0x9000</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">3</span> <span class="hljs-number">1</span> /* INTA */</span><br><span class="hljs-params">            <span class="hljs-number">0x9000</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">4</span> <span class="hljs-number">1</span> /* INTB */</span><br><span class="hljs-params">            <span class="hljs-number">0x9000</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">1</span> <span class="hljs-number">1</span> /* INTC */</span><br><span class="hljs-params">            <span class="hljs-number">0x9000</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-variable">&amp;open</span>-pic <span class="hljs-number">2</span> <span class="hljs-number">1</span> /* INTD */</span><br><span class="hljs-params">        &gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>一个 Open PIC 中断控制器被表示并被标识为具有 <code>interrupt-controller</code> 属性的中断控制器。</p><p><code>interrupt-map</code> 表中的每一行由五个部分组成：子单元地址和中断说明符，它映射到具有指定父单元地址和中断说明符的 <code>interrupt-parent</code> 节点。</p><ul><li>例如， <code>interrupt-map</code> 表的第一行指定槽 1 的 INTA 映射。该行组成的如下所示：<br>子单元地址：0x8800 0 0<br>子中断说明符：1<br>中断父级：&amp;open-pic<br>父单元地址：（空，因为 open-pic 节点中 <code>#address-cells = &lt;0&gt;</code> ）<br>父中断说明符：2 1<ul><li>子单元地址为 <code>&lt;0x8800 0 0&gt;</code> 。该值使用三个 32-bit cell 编码，由 PCI 控制器的 <code>#address-cells</code> 属性值（值为 3）确定。这三个 cell 代表 PCI 地址，正如 PCI 总线绑定所描述的那样。<ul><li>编码包括总线号（0x0 &lt;&lt; 16）、设备号（0x11 &lt;&lt; 11）和功能号（0x0 &lt;&lt; 8）。</li></ul></li><li>子中断说明符是 <code>&lt;1&gt;</code> ，它指定了 PCI 绑定所描述的 INTA。这需要一个由 PCI 控制器的 <code>#interrupt-cells</code> 属性（值为 1）指定的 32-bit cell，它是子中断域。</li><li>中断父级由指向槽的中断父级的 <code>phandle</code> 指定，即 Open PIC 中断控制器。</li><li>父级没有单元地址，因为父级中断域（open-pic 节点）的 <code>#address-cells</code> 值为 <code>&lt;0&gt;</code> 。</li><li>父中断说明符是 <code>&lt;2 1&gt;</code> 。表示中断说明符的 cell 数量（两个 cell）由中断父节点（open-pic 节点）上的 <code>#interrupt-cells</code> 属性确定。<ul><li><code>&lt;2 1&gt;</code> 的值是 Open PIC 中断控制器的设备绑定指定的值（参见 <a href="#4-5-simple-bus-compatible-value">第 4.5 节</a> ）。值 <code>&lt;2&gt;</code> 指定 INTA 连接到的中断控制器上的物理中断源编号。值 <code>&lt;1&gt;</code> 指定电平&#x2F;感应编码。</li></ul></li></ul></li></ul><p>在此示例中， <code>interrupt-map-mask</code> 属性的值为 <code>&lt;0xf800 0 0 7&gt;</code> 。在执行查找 <code>interrupt-map</code> 表之前，此掩码应用于子单元中断说明符。</p><p>要查找 IDSEL 0x12（槽 2），功能 0x3 的 INTB 的 open-pic 中断源编号将执行以下步骤：</p><ul><li>子单元地址和中断说明符形成值 <code>&lt;0x9300 0 0 2&gt;</code> 。<ul><li>地址的编码包括总线号（0x0 &lt;&lt; 16）、设备号（0x12 &lt;&lt; 11）和功能号（0x3 &lt;&lt; 8）。</li><li>中断说明符为 2，这是根据 PCI 绑定对 INTB 的编码。</li></ul></li><li>应用 <code>interrupt-map-mask</code> 值 <code>&lt;0xf800 0 0 7&gt;</code> ，结果为 <code>&lt;0x9000 0 0 2&gt;</code> 。</li><li>在映射到父中断说明符 <code>&lt;4 1&gt;</code> 的 <code>interrupt-map</code> 表中查找该结果。</li></ul><h2 id="2-5-联结节点和说明符映射"><a href="#2-5-联结节点和说明符映射" class="headerlink" title="2.5 联结节点和说明符映射"></a>2.5 联结节点和说明符映射</h2><h3 id="2-5-1-联结节点属性"><a href="#2-5-1-联结节点属性" class="headerlink" title="2.5.1 联结节点属性"></a>2.5.1 联结节点属性</h3><p>一个联结节点应该有一个 <code>#&lt;specifier&gt;-cells</code> 属性，其中 <code>&lt;specifier&gt;</code> 是一些说明符空间，例如“gpio”、“clock”、“reset”等。</p><h4 id="lt-specifier-gt-map"><a href="#lt-specifier-gt-map" class="headerlink" title="&lt;specifier&gt;-map"></a>&lt;specifier&gt;-map</h4><p>属性：&lt;specifier&gt;-map</p><p>值类型：&lt;prop-encoded-array&gt; encoded as an arbitrary number of specifier mapping entries.</p><p>描述：</p><p><code>&lt;specifier&gt;-map</code> 是联结节点中的一个属性，它将一个说明符域与一组父说明符域桥接，并描述子域中的说明符如何映射到它们各自的父域。</p><p>该映射是一个表，其中每一行都是一个映射条目，由三个部分组成： <code>child specifier</code> 、 <code>specifier parent</code> 和 <code>parent specifier</code> 。</p><ul><li><code>child specifier</code> 是被映射的子节点的说明符。指定此部分所需的 32-bit cell 的数量由该节点（包含 <code>&lt;specifier&gt;-map</code> 属性的联结节点）的 <code>#&lt;specifier&gt;-cells</code> 属性描述。</li><li><code>specifier parent</code> 单个 &lt;phandle&gt; 值，指向子域映射到的说明符父系。</li><li><code>parent specifier</code> 父域中的说明符。指定此部分所需的 32-bit cell 的数量由说明符父节点的 <code>#&lt;specifier&gt;-cells</code> 属性描述。</li></ul><p>通过将说明符与映射中的子说明符进行匹配，在映射表上执行查找。因为说明符中的某些字段可能不相关或需要修改，所以在查找完成之前应用掩码。此掩码在 <code>&lt;specifier&gt;-map-mask</code> 属性中定义（参见 <a href="#2-5-1-%E8%81%94%E7%BB%93%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7">第 2.5.1 节</a> ）。</p><p>类似地，当说明符被映射时，单元说明符中的某些字段可能需要保持不变，并从子节点传递到父节点。在这种情况下，可以指定 <code>&lt;specifier&gt;-map-pass-thru</code> 属性（参见 <a href="#2-5-1-%E8%81%94%E7%BB%93%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7">第 2.5.1 节</a> ）以将掩码应用于子说明符并复制与父单元说明符匹配的任何位。</p><h4 id="lt-specifier-gt-map-mask"><a href="#lt-specifier-gt-map-mask" class="headerlink" title="&lt;specifier&gt;-map-mask"></a>&lt;specifier&gt;-map-mask</h4><p>属性：&lt;specifier&gt;-map-mask</p><p>值类型：&lt;prop-encoded-array&gt; encoded as a bit mask</p><p>描述：</p><p>联结节点可以指定一个 <code>&lt;specifier&gt;-map-mask</code> 属性。此属性指定一个掩码，该掩码与在 <code>&lt;specifier&gt;-map</code> 属性中指定的表中查找的子单元说明符进行“与”运算。如果未指定此属性，则假定掩码是设置了所有位的掩码。</p><h4 id="lt-specifier-gt-map-pass-thru"><a href="#lt-specifier-gt-map-pass-thru" class="headerlink" title="&lt;specifier&gt;-map-pass-thru"></a>&lt;specifier&gt;-map-pass-thru</h4><p>属性：&lt;specifier&gt;-map-pass-thru</p><p>值类型：&lt;prop-encoded-array&gt; encoded as a bit mask</p><p>描述：</p><p>联结节点可以指定一个 <code>&lt;specifier&gt;-map-pass-thru</code> 属性。此属性指定应用于在 <code>&lt;specifier&gt;-map</code> 属性中指定的表中查找的子单元说明符的掩码。子单元说明符中的任何匹配位都将复制到父说明符。如果未指定此属性，则假定掩码是未设置位的掩码。</p><h4 id="lt-specifier-gt-cells"><a href="#lt-specifier-gt-cells" class="headerlink" title="#&lt;specifier&gt;-cells"></a>#&lt;specifier&gt;-cells</h4><p>属性：#&lt;specifier&gt;-cells</p><p>值类型：&lt;u32&gt;</p><p>描述：</p><p><code>#&lt;specifier&gt;-cells</code> 属性定义了对域的说明符进行编码所需的 cell 数。</p><h3 id="2-5-2-说明符映射示例"><a href="#2-5-2-说明符映射示例" class="headerlink" title="2.5.2 说明符映射示例"></a>2.5.2 说明符映射示例</h3><p>以下展示了具有两个 GPIO 控制器的设备树片段的表示形式和一个示例说明符映射，用于描述两个控制器上的几个 gpio 通过板上的连接器到设备的 GPIO 路由。扩展设备节点位于连接器节点的一侧，带有两个 GPIO 控制器的 SoC 位于连接器的另一侧。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">soc</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    soc_gpio1:</span> <span class="hljs-title class_">gpio-controller1</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-meta">#gpio-cells = &lt;2&gt;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    soc_gpio2:</span> <span class="hljs-title class_">gpio-controller2</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-meta">#gpio-cells = &lt;2&gt;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">connector:</span> <span class="hljs-title class_">connector</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#gpio-cells = &lt;2&gt;;</span><br>    <span class="hljs-attr">gpio-map</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-variable">&amp;soc_gpio1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>&gt;</span>,<br>               <span class="hljs-params">&lt;<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-variable">&amp;soc_gpio2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span>&gt;</span>,<br>               <span class="hljs-params">&lt;<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-variable">&amp;soc_gpio1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span>&gt;</span>,<br>               <span class="hljs-params">&lt;<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-variable">&amp;soc_gpio2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">gpio-map-mask</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0xf</span> <span class="hljs-number">0x0</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">gpio-map-pass-thru</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x0</span> <span class="hljs-number">0x1</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br><br><span class="hljs-title class_">expansion_device</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">reset-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;connector</span> <span class="hljs-number">2</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p><code>gpio-map</code> 表中的每一行由三部分组成：一个子单元说明符，它映射到一个带有父说明符的 gpio-controller 节点。</p><ul><li>例如，说明符映射表的第一行指定了连接器的 GPIO 0 的映射。该行的部分展示了：<br>子说明符：0 0<br>说明符父系：&amp;soc_gpio1<br>父说明符：1 0<ul><li>子说明符是 <code>&lt;0 0&gt;</code> ，它使用 <code>flags</code> 字段 0 指定连接器中的 GPIO 0。这需要连接器节点的 <code>#gpio-cells</code> 属性指定的两个 32-bit cell，它是子说明符域。</li><li>说明符父系由指向连接器的说明符父系（SoC 中的第一个 GPIO 控制器）的 phandle 指定。</li><li>父说明符是 <code>&lt;1 0&gt;</code> 。表示 gpio 说明符的 cell 数量（两个 cell）由说明符父节点 soc_gpio1 上的 <code>#gpio-cells</code> 属性确定。<ul><li><code>&lt;1 0&gt;</code> 的值是设备绑定为 GPIO 控制器指定的值。值 <code>&lt;1&gt;</code> 指定连接器上的 GPIO 0 连接到的 GPIO 控制器上的 GPIO 引脚号。值 <code>&lt;0&gt;</code> 指定标志（低电平有效、高电平有效等）。</li></ul></li></ul></li></ul><p>在此示例中， <code>gpio-map-mask</code> 属性的值为 <code>&lt;0xf 0&gt;</code> 。在执行查找 <code>gpio-map</code> 表之前，此掩码应用于子单元说明符。同样， <code>gpio-map-pass-thru</code> 属性的值为 <code>&lt;0x0 0x1&gt;</code> 。在将子单元说明符映射到父单元说明符时，此掩码将应用于子单元说明符。此掩码中设置的任何位都将从父单元说明符中清除，并从子单元说明符复制到父单元说明符。</p><p>要从扩展设备的 <code>reset-gpios</code> 属性中查找 GPIO 2 的连接器说明符源编号，将执行以下步骤：</p><ul><li>子说明符形成值 <code>&lt;2 GPIO_ACTIVE_LOW&gt;</code> 。<ul><li>说明符根据 GPIO 绑定使用低电平有效标志对 GPIO 2 进行编码。</li></ul></li><li><code>gpio-map-mask</code> 值 <code>&lt;0xf 0x0&gt;</code> 与子说明符进行“与”运算，结果为 <code>&lt;0x2 0&gt;</code> 。</li><li>在映射到父说明符 <code>&lt;3 0&gt;</code> 和 <code>&amp;soc_gpio1</code> phandle 的 <code>gpio-map</code> 表中查找结果。</li><li><code>gpio-map-pass-thru</code> 值 <code>&lt;0x0 0x1&gt;</code> 与在 <code>gpio-map</code> 表中找到的父说明符进行反转和与运算，得到 <code>&lt;3 0&gt;</code> 。子说明符与 <code>gpio-map-pass-thru</code> 掩码进行“与”运算，形成 <code>&lt;0 GPIO_ACTIVE_LOW&gt;</code> ，然后与清除的父说明符 <code>&lt;3 0&gt;</code> 进行“或”运算，得到 <code>&lt;3 GPIO_ACTIVE_LOW&gt;</code> 。</li><li>说明符 <code>&lt;3 GPIO_ACTIVE_LOW&gt;</code> 附加到映射的 phandle <code>&amp;soc_gpio1</code> 中，从而产生 <code>&lt;&amp;soc_gpio1 3 GPIO_ACTIVE_LOW&gt;</code> 。</li></ul><h1 id="3-设备节点要求"><a href="#3-设备节点要求" class="headerlink" title="3. 设备节点要求"></a>3. 设备节点要求</h1><h2 id="3-1-基本设备节点类型"><a href="#3-1-基本设备节点类型" class="headerlink" title="3.1 基本设备节点类型"></a>3.1 基本设备节点类型</h2><p>以下小节指定了 DTSpec-compliant 设备树中所需的基本设备节点集的要求。</p><p>所有设备树都 <strong>必须</strong> 有一个根节点，并且以下节点 <strong>必须</strong> 出现在所有设备树的根部：</p><ul><li>一个 &#x2F;cpus 节点</li><li>最少一个 &#x2F;memory 节点</li></ul><h2 id="3-2-根节点"><a href="#3-2-根节点" class="headerlink" title="3.2 根节点"></a>3.2 根节点</h2><p>设备树有单个根节点，所有其他设备节点都是其后代。根节点的完整路径是 &#x2F;。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.1: Root Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td style="white-space: nowrap;">#address-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of &lt;u32&gt; cells to represent the address in the reg property in children of root.</td>  </tr>  <tr>    <td>#size-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of &lt;u32&gt; cells to represent the size in the reg property in children of root.</td>  </tr>  <tr>    <td>model</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>Specifies a string that uniquely identifies the model of the system board. The recommended format is “manufacturer,model-number”.</td>  </tr>  <tr>    <td>compatible</td>    <td>R</td>    <td>&lt;stringlist&gt;</td>    <td>Specifies a list of platform architectures with which this platform is compatible. This property can be used by operating systems in selecting platform specific code. The recommended form of the property value is: "manufacturer,model"<br>For example: compatible = "fsl,mpc8572ds"</td>  </tr>  <tr>    <td style="white-space: nowrap;">serial-number</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>Specifies a string representing the device's serial number.</td>  </tr>  <tr>    <td>chassis-type</td>    <td>OR</td>    <td>&lt;string&gt;</td>    <td>      Specifies a string that identifies the form-factor of the system. The property value can be one of:      <ul>        <li>"desktop"</li>        <li>"laptop"</li>        <li>"convertible"</li>        <li>"server"</li>        <li>"tablet"</li>        <li>"handset"</li>        <li>"watch"</li>        <li>"embedded"</li>      </ul>    </td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h2 id="3-3-x2f-aliases-节点"><a href="#3-3-x2f-aliases-节点" class="headerlink" title="3.3 &#x2F;aliases 节点"></a>3.3 &#x2F;aliases 节点</h2><p>设备树 <strong>可以</strong> 有一个别名节点（&#x2F;aliases），它定义了一个或多个别名属性。别名节点 <strong>必须</strong> 位于设备树的根上并具有节点名称 &#x2F;aliases。</p><p>&#x2F;aliases 节点的每个属性都定义了一个别名。属性名称指定别名。属性值指定设备树中节点的完整路径。例如，属性 <code>serial0 = &quot;/simple-bus@fe000000/serial@llc500&quot;</code> 定义别名 <code>serial0</code> 。</p><p>别名 <strong>必须</strong> 为以下字符集中的 1 到 31 个字符的小写文本字符串。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.2: Valid characters for alias names</caption><thead>  <tr>    <th style="text-align:center;">Character</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align:center;">0-9</td>    <td>digit</td>  </tr>  <tr>    <td style="text-align:center;">a-z</td>    <td>lowercase letter</td>  </tr>  <tr>    <td style="text-align:center;">-</td>    <td>dash</td>  </tr></tbody></table><p>别名值是设备路径并被编码为字符串。该值表示节点的完整路径，但路径不需要引用叶节点。</p><p>客户程序可以使用别名属性名称来引用完整的设备路径作为其字符串值的全部或部分。客户程序在将字符串视为设备路径时，应检测并使用别名。</p><p>示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">aliases</span> <span class="hljs-punctuation">&#123;</span><br>    serial0 = <span class="hljs-string">&quot;/simple-bus@fe000000/serial@llc500&quot;</span><span class="hljs-punctuation">;</span><br>    ethernet0 = <span class="hljs-string">&quot;/simple-bus@fe000000/ethernet@31c000&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>给定别名 <code>serial0</code>，客户程序会查找 <code>/aliases</code> 节点并确定别名指的是设备路径 <code>/simple-bus@fe000000/serial@llc500</code> 。</p><h2 id="3-4-x2f-memory-节点"><a href="#3-4-x2f-memory-节点" class="headerlink" title="3.4 &#x2F;memory 节点"></a>3.4 &#x2F;memory 节点</h2><p>所有设备树都需要一个内存设备节点，它描述了系统的物理内存布局。如果系统有多个内存范围，可以创建多个内存节点，或者可以在单个内存节点的 <code>reg</code> 属性中指定范围。</p><p>节点名称的 <code>unit-name</code> 部分（参见 <a href="#2-2-1-%E8%8A%82%E7%82%B9%E5%90%8D">第 2.2.1 节</a> ）应为 memory。</p><p>客户程序可以使用它选择的任何存储属性访问任何内存预留（参见 <a href="#5-3-memory-reservation-block">第 5.3 节</a> ）未覆盖的内存。但是，在更改用于访问真实页面的存储属性之前，客户程序负责执行体系结构与实现所需的操作，可能包括从缓存中刷新真实页面。引导程序负责确保在不采取与存储属性更改相关联的任何操作的情况下，客户程序可以安全地访问所有内存（包括内存预留覆盖的内存），因为 WIMG &#x3D; 0b001x。即：</p><ul><li>不要求直写</li><li>不禁止缓存</li><li>内存一致性</li><li>需要不保护或保护</li></ul><p>如果支持 VLE 存储属性，则 VLE&#x3D;0。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.3: /memory Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>device_type</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>Value shall be “memory”</td>  </tr>  <tr>    <td>reg</td>    <td>R</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>Consists of an arbitrary number of address and size pairs that specify the physical address and size of the memory ranges.</td>  </tr>  <tr>    <td style="white-space: nowrap;">initial-mapped-area</td>    <td>O</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>Specifies the address and size of the Initial Mapped Area<br>Is a prop-encoded-array consisting of a triplet of (effective address, physical address, size).<br>The effective and physical address shall each be 64-bit (&lt;u64&gt; value), and the size shall be 32-bits (&lt;u32&gt; value).</td>  </tr>  <tr>    <td>hotpluggable</td>    <td>O</td>    <td>&lt;empty&gt;</td>    <td>Specifies an explicit hint to the operating system that this memory may potentially be removed later.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h3 id="3-4-1-x2f-memory-节点和-uefi"><a href="#3-4-1-x2f-memory-节点和-uefi" class="headerlink" title="3.4.1 &#x2F;memory 节点和 UEFI"></a>3.4.1 &#x2F;memory 节点和 UEFI</h3><p>通过 [<a href="#bibliography">UEFI</a>] 引导时，系统内存映射是通过 [<a href="#bibliography">UEFI</a>] § 7.2 中定义的 <code>GetMemoryMap()</code> UEFI 引导时服务获得的，如果存在，操作系统必须忽略任何 &#x2F;memory 节点。</p><h3 id="3-4-2-x2f-memory-示例"><a href="#3-4-2-x2f-memory-示例" class="headerlink" title="3.4.2 &#x2F;memory 示例"></a>3.4.2 &#x2F;memory 示例</h3><p>给定具有以下物理内存布局的 64-bit Power 系统：</p><ul><li>RAM：起始地址 0x0，长度 0x80000000（2 GB）</li><li>RAM：起始地址 0x100000000，长度 0x100000000（4 GB）</li></ul><p>内存节点可以定义如下，假设 <code>#address-cells = &lt;2&gt;</code> 和 <code>#size-cells = &lt;2&gt;</code> 。</p><p>示例 1：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">memory@0</span> <span class="hljs-punctuation">&#123;</span><br>    device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;memory&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x000000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x80000000</span></span><br><span class="hljs-params">           <span class="hljs-number">0x000000001</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000001</span> <span class="hljs-number">0x00000000</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">memory@0</span> <span class="hljs-punctuation">&#123;</span><br>    device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;memory&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x000000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x80000000</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br><br><span class="hljs-title class_">memory@100000000</span> <span class="hljs-punctuation">&#123;</span><br>    device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;memory&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x000000001</span> <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00000001</span> <span class="hljs-number">0x00000000</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p><code>reg</code> 属性用于定义两个内存范围的地址和大小。2 GB I&#x2F;O 区域被跳过。请注意，根节点的 <code>#address-cells</code> 和 <code>#size-cells</code> 属性指定的值为 2，这意味着需要两个 32-bit cell 来定义内存节点的 <code>reg</code> 属性的地址和长度。</p><h2 id="3-5-x2f-reserved-memory-节点"><a href="#3-5-x2f-reserved-memory-节点" class="headerlink" title="3.5 &#x2F;reserved-memory 节点"></a>3.5 &#x2F;reserved-memory 节点</h2><p>Reserved memory 被指定为 &#x2F;reserved-memory 节点下的一个节点。操作系统 <strong>必须</strong> 将 reserved memory 排除在正常使用之外。可以创建描述特定 reserved memory（从正常使用中排除）区域的子节点。这样的内存区域通常是为各种设备驱动程序的特殊用途而设计的。</p><p>每个内存区域的参数可以通过以下节点编码到设备树中：</p><h3 id="3-5-1-x2f-reserved-memory-父节点"><a href="#3-5-1-x2f-reserved-memory-父节点" class="headerlink" title="3.5.1 &#x2F;reserved-memory 父节点"></a>3.5.1 &#x2F;reserved-memory 父节点</h3><table><caption style="caption-side: top; white-space: nowrap;">Table 3.4: /reserved-memory Parent Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td style="white-space: nowrap;">#address-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of &lt;u32&gt; cells to represent the address in the reg property in children of root.</td>  </tr>  <tr>    <td>#size-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of &lt;u32&gt; cells to represent the size in the reg property in children of root.</td>  </tr>  <tr>    <td>ranges</td>    <td>R</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>This property represents the mapping between parent address to child address spaces (see Section 2.3.8, ranges).</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><p><code>#address-cells</code> 和 <code>#size-cells</code> 应该使用与根节点相同的值，并且 <code>ranges</code> 应该为空，以便地址转换逻辑正常工作。</p><h3 id="3-5-2-x2f-reserved-memory-x2f-子节点"><a href="#3-5-2-x2f-reserved-memory-x2f-子节点" class="headerlink" title="3.5.2 &#x2F;reserved-memory&#x2F; 子节点"></a>3.5.2 &#x2F;reserved-memory&#x2F; 子节点</h3><p>reserved-memory 节点的每个子节点指定一个或多个 reserved memory 区域。每个子节点可以使用 <code>reg</code> 属性来指定特定范围的 reserved memory，或者使用带有可选约束的 <code>size</code> 属性来请求动态分配的内存块。</p><p>按照通用名称推荐的做法，节点名称应该反映节点的用途（即“<strong>framebuffer</strong>”或“<strong>dma-pool</strong>”）。如果节点是静态分配，则应将单元地址（<code>@&lt;address&gt;</code>）附加到名称中。</p><p>Reserved memory 节点需要用于静态分配的 <code>reg</code> 属性或用于动态分配的 <code>size</code> 属性。动态分配可以使用 <code>alignment</code> 和 <code>alloc-ranges</code> 属性来限制从哪里分配内存。如果 <code>reg</code> 和 <code>size</code> 都存在，则该区域被视为静态分配，其中 <code>reg</code> 属性优先，并且忽略 <code>size</code> 。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.5: /reserved-memory/ Child Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>reg</td>    <td>O</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>Consists of an arbitrary number of address and size pairs that specify the physical address and size of the memory ranges.</td>  </tr>  <tr>    <td>size</td>    <td>O</td>    <td>&lt;prop-encoded-array&gt;</td>    <td>Size in bytes of memory to reserve for dynamically allocated regions. Size of this property is based on parent node’s #size-cells property.</td>  </tr>  <tr>    <td>alignment</td>    <td>O</td>    <td>&lt;prop-encoded-array&gt;</td>    <td>Address boundary for alignment of allocation. Size of this property is based on parent node’s #size-cells property.</td>  </tr>  <tr>    <td style="white-space: nowrap;">alloc-ranges</td>    <td>O</td>    <td>&lt;prop-encoded-array&gt;</td>    <td>Specifies regions of memory that are acceptable to allocate from. Format is (address, length pairs) tuples in same format as for reg properties.</td>  </tr>  <tr>    <td>compatible</td>    <td>O</td>    <td>&lt;stringlist&gt;</td>    <td>      May contain the following strings:      <ul>        <li>shared-dma-pool: This indicates a region of memory meant to be used as a shared pool of DMA buffers for a set of devices. It can be used by an operating system to instantiate the necessary pool management subsystem if necessary</li>        <li>vendor specific string in the form &lt;vendor&gt;,[&lt;device&gt;-]&lt;usage&gt;</li>      </ul>    </td>  </tr>  <tr>    <td>no-map</td>    <td>O</td>    <td>&lt;empty&gt;</td>    <td>If present, indicates the operating system must not create a virtual mapping of the region as part of its standard mapping of system memory, nor permit speculative access to it under any circumstances other than under the control of the device driver using the region.</td>  </tr>  <tr>    <td>reusable</td>    <td>O</td>    <td>&lt;empty&gt;</td>    <td>The operating system can use the memory in this region with the limitation that the device driver(s) owning the region need to be able to reclaim it back. Typically that means that the operating system can use that region to store volatile or cached data that can be otherwise regenerated or migrated elsewhere.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><p><code>no-map</code> 和 <code>reusable</code> 属性是互斥的，不能在同一个节点中同时使用。</p><p>Linux 实现注释：</p><ul><li>如果存在 <code>linux,cma-default</code> 属性，则 Linux 将使用该区域作为连续内存分配器的默认池。</li><li>如果存在 <code>linux,dma-default</code> 属性，则 Linux 将使用该区域作为一致 DMA 分配器的默认池。</li></ul><h3 id="3-5-3-设备节点对-reserved-memory-的引用"><a href="#3-5-3-设备节点对-reserved-memory-的引用" class="headerlink" title="3.5.3 设备节点对 reserved memory 的引用"></a>3.5.3 设备节点对 reserved memory 的引用</h3><p>&#x2F;reserved-memory 节点中的区域可以通过向设备节点添加 <code>memory-region</code> 属性被其他设备节点引用。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.6: Properties for referencing reserved-memory regions</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>memory-region</td>    <td>O</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>phandle, specifier pairs to children of /reserved-memory</td>  </tr>  <tr>    <td style="white-space: nowrap;">memory-region-names</td>    <td>O</td>    <td>&lt;stringlist&gt;</td>    <td>A list of names, one for each corresponding entry in the memory-region property</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><h3 id="3-5-4-x2f-reserved-memory-和-uefi"><a href="#3-5-4-x2f-reserved-memory-和-uefi" class="headerlink" title="3.5.4 &#x2F;reserved-memory 和 UEFI"></a>3.5.4 &#x2F;reserved-memory 和 UEFI</h3><p>当通过 [<a href="#bibliography">UEFI</a>] 引导时，静态 &#x2F;reserved-memory 区域也必须列在通过 [<a href="#bibliography">UEFI</a>] § 7.2 中定义的 <code>GetMemoryMap()</code> UEFI 引导时服务获得的系统内存映射中。Reserved memory 区域需要包含在 UEFI 内存映射中，以防止 UEFI 应用程序进行分配。</p><p>具有 <code>no-map</code> 属性的保留区域必须以 <code>EfiReservedMemoryType</code> 类型列在内存映射中。所有其他保留区域必须以 <code>EfiBootServicesData</code> 类型列出。</p><p>动态 reserved memory 区域不得在 [<a href="#bibliography">UEFI</a>] 内存映射中列出，因为它们是由操作系统在退出固件启动服务后分配的。</p><h3 id="3-5-5-x2f-reserved-memory-示例"><a href="#3-5-5-x2f-reserved-memory-示例" class="headerlink" title="3.5.5 &#x2F;reserved-memory 示例"></a>3.5.5 &#x2F;reserved-memory 示例</h3><p>此示例为 Linux 内核定义了 3 个连续区域：所有设备驱动程序的一个默认区域（名为 <code>linux,cma</code> 并且 <code>size</code> 为 64MiB），一个专用于帧缓冲设备（名为 <code>framebuffer@78000000</code> ，8MiB），一个用于多媒体处理（名为 <code>multimedia@77000000</code> ，64MiB)。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">/</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br><br>    <span class="hljs-title class_">memory</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x40000000</span> <span class="hljs-number">0x40000000</span>&gt;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-title class_">reserved-memory</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>        <span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br>        <span class="hljs-attr">ranges</span><span class="hljs-punctuation">;</span><br><br>        <span class="hljs-comment">/* global autoconfigured region for contiguous allocations */</span><br>        linux,<span class="hljs-title class_">cma</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shared-dma-pool&quot;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">reusable</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x4000000</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">alignment</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x2000</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">linux,cma-default</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">        display_reserved:</span> <span class="hljs-title class_">framebuffer@78000000</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x78000000</span> <span class="hljs-number">0x800000</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">        multimedia_reserved:</span> <span class="hljs-title class_">multimedia@77000000</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;acme,multimedia-memory&quot;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x77000000</span> <span class="hljs-number">0x4000000</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">/* ... */</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    fb0:</span> <span class="hljs-title class_">video@12300000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">memory-region</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;display_reserved</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    scaler:</span> <span class="hljs-title class_">scaler@12500000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">memory-region</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;multimedia_reserved</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    codec:</span> <span class="hljs-title class_">codec@12600000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">memory-region</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;multimedia_reserved</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="3-6-x2f-chosen-节点"><a href="#3-6-x2f-chosen-节点" class="headerlink" title="3.6 &#x2F;chosen 节点"></a>3.6 &#x2F;chosen 节点</h2><p>&#x2F;chosen 节点不代表系统中的真实设备，但描述了系统固件在运行时选择或指定的参数。它 <strong>必须</strong> 是根节点的子节点。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.7: /chosen Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>bootargs</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>A string that specifies the boot arguments for the client program. The value could potentially be a null string if no boot arguments are required.</td>  </tr>  <tr>    <td style="white-space: nowrap;">stdout-path</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>A string that specifies the full path to the node representing the device to be used for boot console output. If the character “:” is present in the value it terminates the path. The value may be an alias. If the stdin-path property is not specified, stdout-path should be assumed to define the input device.</td>  </tr>  <tr>    <td>stdin-path</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>A string that specifies the full path to the node representing the device to be used for boot console input. If the character “:” is present in the value it terminates the path. The value may be an alias.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><p>示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">chosen</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">bootargs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>可能会遇到旧版本的设备树，其中包含不推荐使用的 <code>stdout-path</code> 属性形式，称为 <code>linux,stdout-path</code> 。为了兼容性，如果 <code>stdout-path</code> 属性不存在，客户程序可能希望支持 <code>linux,stdout-path</code> 。这两个属性的含义和用途是相同的。</p><h2 id="3-7-x2f-cpus-节点属性"><a href="#3-7-x2f-cpus-节点属性" class="headerlink" title="3.7 &#x2F;cpus 节点属性"></a>3.7 &#x2F;cpus 节点属性</h2><p>所有设备树都需要一个 &#x2F;cpus 节点。它并不代表系统中的真实设备，而是充当代表系统 CPU 的子 cpu 节点的容器。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.8: /cpus Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td style="white-space: nowrap;">#address-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>The value specifies how many cells each element of the reg property array takes in children of this node.</td>  </tr>  <tr>    <td>#size-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Value shall be 0. Specifies that no size is required in the reg property in children of this node.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><p>&#x2F;cpus 节点可能包含跨 cpu 节点通用的属性。有关详细信息，请参阅 <a href="#3-8-cpuscpu-%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7">第 3.8 节</a> 。</p><p>示例参见 <a href="#3-8-4-%E7%A4%BA%E4%BE%8B">第 3.8.4 节</a> 。</p><h2 id="3-8-x2f-cpus-x2f-cpu-节点属性"><a href="#3-8-x2f-cpus-x2f-cpu-节点属性" class="headerlink" title="3.8 &#x2F;cpus&#x2F;cpu* 节点属性"></a>3.8 &#x2F;cpus&#x2F;cpu* 节点属性</h2><p>一个 cpu 节点代表一个硬件执行块，它足够独立，能够运行操作系统而不干扰可能运行其他操作系统的其他 CPU。</p><p>共享 MMU 的硬件线程通常会在一个 cpu 节点下表示。如果设计了其他更复杂的 CPU 拓扑，则 CPU 的绑定必须描述拓扑（例如，线程不共享 MMU）。</p><p>CPU 和线程通过统一的编号空间进行编号，该编号空间应尽可能匹配中断控制器的 CPUs&#x2F;threads 编号。</p><p>跨 cpu 节点具有相同值的属性可以放在 &#x2F;cpus 节点中。客户程序必须首先检查特定的 cpu 节点，但如果未找到预期的属性，则它应该查看父 &#x2F;cpus 节点。这导致在所有 CPU 中相同的属性的详细表示。</p><p>每个 CPU 节点的节点名称应为 cpu。</p><h3 id="3-8-1-x2f-cpus-x2f-cpu-节点的通用属性"><a href="#3-8-1-x2f-cpus-x2f-cpu-节点的通用属性" class="headerlink" title="3.8.1 &#x2F;cpus&#x2F;cpu* 节点的通用属性"></a>3.8.1 &#x2F;cpus&#x2F;cpu* 节点的通用属性</h3><p>下表描述了 cpu 节点的通用属性。Table 3.9 中描述的一些属性是具有特定适用细节的选定标准属性。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.9: /cpus/cpu* Node General Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>device_type</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>Value shall be "cpu".</td>  </tr>  <tr>    <td>reg</td>    <td>R</td>    <td>array</td>    <td>The value of reg is a &lt;prop-encoded-array&gt; that defines a unique CPU/thread id for the CPU/threads represented by the CPU node.<br>If a CPU supports more than one thread (i.e. multiple streams of execution) the reg property is an array with 1 element per thread. The #address-cells on the /cpus node specifies how many cells each element of the array takes. Software can determine the number of threads by dividing the size of reg by the parent node’s #address-cells.<br>If a CPU/thread can be the target of an external interrupt the reg property value must be a unique CPU/thread id that is addressable by the interrupt controller.<br>If a CPU/thread cannot be the target of an external interrupt, then reg must be unique and out of bounds of the range addressed by the interrupt controller.<br>If a CPU/thread’s PIR (pending interrupt register) is modifiable, a client program should modify PIR to match the reg property value.<br>If PIR cannot be modified and the PIR value is distinct from the interrupt controller number space, the CPUs binding may define a bindingspecific representation of PIR values if desired.</td>  </tr>  <tr>    <td>clock-frequency</td>    <td>R</td>    <td>array</td>    <td>      Specifies the current clock speed of the CPU in Hertz. The value is a &lt;prop-encoded-array&gt; in one of two forms:      <ul>        <li>A 32-bit integer consisting of one &lt;u32&gt; specifying the frequency.</li>        <li>A 64-bit integer represented as a &lt;u64&gt; specifying the frequency.</li>      </ul>    </td>  </tr>  <tr>    <td style="white-space: nowrap;">timebase-frequency</td>    <td>R</td>    <td>array</td>    <td>      Specifies the current frequency at which the timebase and decrementer registers are updated (in Hertz). The value is a &lt;prop-encoded-array&gt; in one of two forms:      <ul>        <li>A 32-bit integer consisting of one &lt;u32&gt; specifying the frequency.</li>        <li>A 64-bit integer represented as a &lt;u64&gt;.</li>      </ul>    </td>  </tr>  <tr>    <td>status</td>    <td>SD</td>    <td>&lt;string&gt;</td>    <td>A standard property describing the state of a CPU. This property shall be present for nodes representing CPUs in a symmetric multiprocessing (SMP) configuration. For a CPU node the meaning of the "okay", "disabled" and "fail" values are as follows:<br>"okay": The CPU is running.<br>"disabled": The CPU is in a quiescent state.<br>"fail": The CPU is not operational or does not exist.<br><br>A quiescent CPU is in a state where it cannot interfere with the normal operation of other CPUs, nor can its state be affected by the normal operation of other running CPUs, except by an explicit method for enabling or reenabling the quiescent CPU (see the enablemethod property).<br>In particular, a running CPU shall be able to issue broadcast TLB invalidates without affecting a quiescent CPU.<br>Examples: A quiescent CPU could be in a spin loop, held in reset, and electrically isolated from the system bus or in another implementation dependent state.<br>A CPU with "fail" status does not affect the system in any way. The status is assigned to nodes for which no corresponding CPU exists.</td>  </tr>  <tr>    <td>enable-method</td>    <td>SD</td>    <td>&lt;stringlist&gt;</td>    <td>Describes the method by which a CPU in a disabled state is enabled. This property is required for CPUs with a status property with a value of "disabled". The value consists of one or more strings that define the method to release this CPU. If a client program recognizes any of the methods, it may use it. The value shall be one of the following:<br>"spin-table": The CPU is enabled with the spin table method defined in the DTSpec.<br>"[vendor],[method]": Implementation dependent string that describes the method by which a CPU is released from a "disabled" state. The required format is: "[vendor],[method]", where vendor is a string describing the name of the manufacturer and method is a string describing the vendor specific mechanism.<br><br>Example: "fsl,MPC8572DS"<br>Note: Other methods may be added to later revisions of the DTSpec specification.</td>  </tr>  <tr>    <td>cpu-release-addr</td>    <td>SD</td>    <td>&lt;u64&gt;</td>    <td>The cpu-release-addr property is required for cpu nodes that have an enable-method property value of "spin-table". The value specifies the physical address of a spin table entry that releases a secondary CPU from its spin loop.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><table><caption style="caption-side: top; white-space: nowrap;">Table 3.10: /cpus/cpu* Node Power ISA Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>power-isa-version</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>A string that specifies the numerical portion of the Power ISA version string. For example, for an implementation complying with Power ISA Version 2.06, the value of this property would be "2.06".</td>  </tr>  <tr>    <td>power-isa-*</td>    <td>O</td>    <td>&lt;empty&gt;</td>    <td>If the power-isa-version property exists, then for each category from the Categories section of Book I of the Power ISA version indicated, the existence of a property named power-isa-[CAT], where [CAT] is the abbreviated category name with all uppercase letters converted to lowercase, indicates that the category is supported by the implementation.<br>For example, if the power-isa-version property exists and its value is "2.06" and the power-isa-e.hv property exists, then the implementation supports [Category:Embedded.Hypervisor] as defined in Power ISA Version 2.06.</td>  </tr>  <tr>    <td>cache-op-block-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the block size in bytes upon which cache block instructions operate (e.g., dcbz).<br>Required if different than the L1 cache block size.</td>  </tr>  <tr>    <td style="white-space: nowrap;">reservation-granule-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the reservation granule size supported by this processor in bytes.</td>  </tr>  <tr>    <td>mmu-type</td>    <td>O</td>    <td>&lt;string&gt;</td>    <td>      Specifies the CPU’s MMU type.<br>Valid values are shown below:      <ul>        <li>"mpc8xx"</li>        <li>"ppc40x"</li>        <li>"ppc440"</li>        <li>"ppc476"</li>        <li>"power-embedded"</li>        <li>"powerpc-classic"</li>        <li>"power-server-stab"</li>        <li>"power-server-slb"</li>        <li>"none"</li>      </ul>    </td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><p>可能会遇到在 CPU 节点上包含 <code>bus-frequency</code> 属性的旧版本的设备树。为了兼容性，客户程序可能希望支持 <code>bus-frequency</code> 。该值的格式与 <code>clock-frequency</code> 的格式相同。推荐的做法是使用 <code>clock-frequency</code> 属性来表示总线节点上的总线频率。</p><h3 id="3-8-2-tlb-属性"><a href="#3-8-2-tlb-属性" class="headerlink" title="3.8.2 TLB 属性"></a>3.8.2 TLB 属性</h3><p>cpu 节点的以下属性描述了处理器 MMU 中的转译后备缓冲器（Translate Look-aside Buffer）。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.11: /cpu/cpu* Node Power ISA TLB Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>tlb-split</td>    <td>SD</td>    <td>&lt;empty&gt;</td>    <td>If present specifies that the TLB has a split configuration, with separate TLBs for instructions and data. If absent, specifies that the TLB has a unified configuration. Required for a CPU with a TLB in a split configuration.</td>  </tr>  <tr>    <td>tlb-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of entries in the TLB. Required for a CPU with a unified TLB for instruction and data addresses.</td>  </tr>  <tr>    <td>tlb-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in the TLB. Required for a CPU with a unified TLB for instruction and data addresses.</td>  </tr>  <tr>    <td style="white-space: nowrap;">d-tlb-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of entries in the data TLB. Required for a CPU with a split TLB configuration.</td>  </tr>  <tr>    <td>d-tlb-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in the data TLB. Required for a CPU with a split TLB configuration.</td>  </tr>  <tr>    <td>i-tlb-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of entries in the instruction TLB. Required for a CPU with a split TLB configuration.</td>  </tr>  <tr>    <td>i-tlb-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in the instruction TLB. Required for a CPU with a split TLB configuration.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h3 id="3-8-3-internal-l1-cache-属性"><a href="#3-8-3-internal-l1-cache-属性" class="headerlink" title="3.8.3 Internal (L1) Cache 属性"></a>3.8.3 Internal (L1) Cache 属性</h3><p>cpu 节点的以下属性描述了处理器的内部（L1）缓存。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.12: /cpu/cpu* Node Power ISA Cache Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>cache-unified</td>    <td>SD</td>    <td>&lt;empty&gt;</td>    <td>If present, specifies the cache has a unified organization. If not present, specifies that the cache has a Harvard architecture with separate caches for instructions and data.</td>  </tr>  <tr>    <td>cache-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the size in bytes of a unified cache. Required if the cache is unified (combined instructions and data).</td>  </tr>  <tr>    <td>cache-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in a unified cache. Required if the cache is unified (combined instructions and data)</td>  </tr>  <tr>    <td>cache-block-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the block size in bytes of a unified cache. Required if the processor has a unified cache (combined instructions and data)</td>  </tr>  <tr>    <td>cache-line-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the line size in bytes of a unified cache, if different than the cache block size. Required if the processor has a unified cache (combined instructions and data).</td>  </tr>  <tr>    <td>i-cache-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the size in bytes of the instruction cache. Required if the cpu has a separate cache for instructions.</td>  </tr>  <tr>    <td>i-cache-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in the instruction cache. Required if the cpu has a separate cache for instructions.</td>  </tr>  <tr>    <td style="white-space: nowrap;">i-cache-block-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the block size in bytes of the instruction cache. Required if the cpu has a separate cache for instructions.</td>  </tr>  <tr>    <td>i-cache-line-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the line size in bytes of the instruction cache, if different than the cache block size. Required if the cpu has a separate cache for instructions.</td>  </tr>  <tr>    <td>d-cache-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the size in bytes of the data cache. Required if the cpu has a separate cache for data.</td>  </tr>  <tr>    <td>d-cache-sets</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the number of associativity sets in the data cache. Required if the cpu has a separate cache for data.</td>  </tr>  <tr>    <td>d-cache-block-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the block size in bytes of the data cache. Required if the cpu has a separate cache for data.</td>  </tr>  <tr>    <td>d-cache-line-size</td>    <td>SD</td>    <td>&lt;u32&gt;</td>    <td>Specifies the line size in bytes of the data cache, if different than the cache block size. Required if the cpu has a separate cache for data.</td>  </tr>  <tr>    <td>next-level-cache</td>    <td>SD</td>    <td>&lt;phandle&gt;</td>    <td>If present, indicates that another level of cache exists. The value is the phandle of the next level of cache. The phandle value type is fully described in Section 2.3.3.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><p>可能会遇到旧版本的设备树，其中包含 <code>next-level-cache</code> 属性的已弃用形式，称为 <code>l2-cache</code> 。为了兼容性，如果 <code>next-level-cache</code> 属性不存在，客户程序可能希望支持 <code>l2-cache</code> 。这两个属性的含义和用途是相同的。</p><h3 id="3-8-4-示例"><a href="#3-8-4-示例" class="headerlink" title="3.8.4 示例"></a>3.8.4 示例</h3><p>以下是一个带有一个子 cpu 节点的 &#x2F;cpus 节点的示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">cpus</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br>    <span class="hljs-title class_">cpu@0</span> <span class="hljs-punctuation">&#123;</span><br>        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpu&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">d-cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1 - 32 bytes</span><br>        <span class="hljs-attr">i-cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1 - 32 bytes</span><br>        <span class="hljs-attr">d-cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x8000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1, 32K</span><br>        <span class="hljs-attr">i-cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x8000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1, 32K</span><br>        <span class="hljs-attr">timebase-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">82500000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 82.5 MHz</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">825000000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 825 MHz</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="3-9-多级共享缓存节点（-x2f-cpus-x2f-cpu-x2f-l-cache）"><a href="#3-9-多级共享缓存节点（-x2f-cpus-x2f-cpu-x2f-l-cache）" class="headerlink" title="3.9 多级共享缓存节点（&#x2F;cpus&#x2F;cpu*&#x2F;l?-cache）"></a>3.9 多级共享缓存节点（&#x2F;cpus&#x2F;cpu*&#x2F;l?-cache）</h2><p>处理器和系统可以实现额外级别的缓存层次结构。例如，二级（L2）或三级（L3）缓存。这些缓存可能与 CPU 紧密集成，也可能在多个 CPU 之间共享。</p><p><code>compatible</code> 值为 <code>&quot;cache&quot;</code> 的设备节点描述了这些类型的缓存。</p><p>cache 节点 <strong>必须</strong> 定义 <code>phandle</code> 属性，所有与缓存关联或共享缓存的 cpu 节点或 cache 节点均 <strong>必须</strong> 包含 <code>next-level-cache</code> 属性，该属性指定 cache 节点的 <code>phandle</code> 。</p><p>cache 节点可以表示在 CPU 节点或设备树中的任何其他适当位置下。</p><p>多级共享缓存用 Table 3-9 中的属性表示。L1 缓存属性在 Table 3-8 中描述。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 3.13: /cpu/cpu*/l?-cache Node Power ISA Multiple-level and Shared Cache Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>compatible</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>A standard property. The value shall include the string "cache".</td>  </tr>  <tr>    <td style="white-space: nowrap;">cache-level</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the level in the cache hierarchy. For example, a level 2 cache has a value of 2.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h3 id="3-9-1-示例"><a href="#3-9-1-示例" class="headerlink" title="3.9.1 示例"></a>3.9.1 示例</h3><p>参阅以下表示两个 CPU 的设备树的示例，每个 CPU 都有自己的片上 L2 和共享的 L3。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">cpus</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br>    <span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br><br>    <span class="hljs-title class_">cpu@0</span> <span class="hljs-punctuation">&#123;</span><br>        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpu&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">cache-unified</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x8000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1, 32 KB</span><br>        <span class="hljs-attr">cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">timebase-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">82500000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 82.5 MHz</span><br>        <span class="hljs-attr">next-level-cache</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;</span>L2_0&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// phandle to L2</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">        L2_0:</span><span class="hljs-title class_">l2-cache</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cache&quot;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-unified</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x40000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 256 KB</span><br><br>            <span class="hljs-attr">cache-sets</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1024</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-level</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">2</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">next-level-cache</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;</span>L3&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// phandle to L3</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">            L3:</span><span class="hljs-title class_">l3-cache</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cache&quot;</span><span class="hljs-punctuation">;</span><br>                <span class="hljs-attr">cache-unified</span><span class="hljs-punctuation">;</span><br>                <span class="hljs-attr">cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x40000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 256 KB</span><br>                <span class="hljs-attr">cache-sets</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x400</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 1024</span><br>                <span class="hljs-attr">cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span><br>                <span class="hljs-attr">cache-level</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">3</span>&gt;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-punctuation">&#125;;</span><br>        <span class="hljs-punctuation">&#125;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-title class_">cpu@1</span> <span class="hljs-punctuation">&#123;</span><br>        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cpu&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">cache-unified</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">cache-block-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x8000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// L1, 32 KB</span><br>        <span class="hljs-attr">timebase-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">82500000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 82.5 MHz</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">825000000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 825 MHz</span><br>        <span class="hljs-attr">cache-level</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">2</span>&gt;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">next-level-cache</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;</span>L2_1&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// phandle to L2</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">        L2_1:</span><span class="hljs-title class_">l2-cache</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cache&quot;</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-unified</span><span class="hljs-punctuation">;</span><br>            <span class="hljs-attr">cache-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x40000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 256 KB</span><br>            <span class="hljs-attr">cache-sets</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x400</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 1024</span><br>            <span class="hljs-attr">cache-line-size</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">32</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 32 bytes</span><br>            <span class="hljs-attr">next-level-cache</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;</span>L3&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// phandle to L3</span><br>        <span class="hljs-punctuation">&#125;;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h1 id="4-设备绑定"><a href="#4-设备绑定" class="headerlink" title="4. 设备绑定"></a>4. 设备绑定</h1><p>本章包含有关如何在设备树中表示特定类型和类别的设备的要求，称为绑定（Binding）。设备节点的 <code>compatible</code> 属性描述了该节点遵守的特定绑定（或多个绑定）。</p><p>绑定可以定义为彼此的扩展。例如，可以将新的总线类型定义为简单总线绑定的扩展。在这种情况下， <code>compatible</code> 属性将包含几个标识每个绑定的字符串 —— 从最特定的到最通用的（参见 <a href="#2-3-1-compatible">第 2.3.1 节</a> ）。</p><h2 id="4-1-绑定准则"><a href="#4-1-绑定准则" class="headerlink" title="4.1 绑定准则"></a>4.1 绑定准则</h2><h3 id="4-1-1-一般原则"><a href="#4-1-1-一般原则" class="headerlink" title="4.1.1 一般原则"></a>4.1.1 一般原则</h3><p>为设备创建新的设备树表示时，应创建一个绑定，以完全描述设备的所需属性和值。这组属性应具有足够的描述性，以便为设备驱动程序提供所需的设备属性。</p><p>一些推荐的做法包括：</p><ol><li>使用 <a href="#2-3-1-compatible">第 2.3.1 节</a> 中描述的约定定义一个 <code>compatible</code> 字符串。</li><li>使用适用于新设备的标准属性（在 <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> 和 <a href="#2-4-%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E6%98%A0%E5%B0%84">第 2.4 节</a> 中定义）。这种用法通常至少包括 <code>reg</code> 和 <code>interrupts</code> 属性。</li><li>如果新设备适合 DTSpec 定义的设备类之一，则使用 <a href="#4-%E8%AE%BE%E5%A4%87%E7%BB%91%E5%AE%9A">第 4 节</a>（设备绑定）中指定的约定。</li><li>如果适用，请使用 <a href="#4-1-2-%E6%9D%82%E9%A1%B9%E5%B1%9E%E6%80%A7">第 4.1.2 节</a> 中指定的其他属性约定。</li><li>如果绑定需要新属性，那么建议属性名格式为：<code>&quot;&lt;company&gt;,&lt;property-name&gt;&quot;</code>，其中 <code>&lt;company&gt;</code> 是一个 OUI 或短的唯一字符串，例如标识出绑定的创建者的股票代码。<br>示例：<code>&quot;ibm,ppc-interrupt-server#s&quot;</code></li></ol><h3 id="4-1-2-杂项属性"><a href="#4-1-2-杂项属性" class="headerlink" title="4.1.2 杂项属性"></a>4.1.2 杂项属性</h3><p>本节定义了可能适用于许多设备类型和设备类别的有用属性列表。在这里定义它们是为了便于名称和用法的标准化。</p><h4 id="clock-frequency-属性"><a href="#clock-frequency-属性" class="headerlink" title="clock-frequency 属性"></a>clock-frequency 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.1: clock-frequency Property</caption><tbody>  <tr>    <td>Property</td>    <td>clock-frequency</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies the frequency of a clock in Hz. The value is a,in one of two forms:<br>a 32-bit integer consisting of one,specifying the frequency<br>a 64-bit integer represented as a,specifying the frequency</td>  </tr></tbody></table><h4 id="reg-shift-属性"><a href="#reg-shift-属性" class="headerlink" title="reg-shift 属性"></a>reg-shift 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.2: reg-shift Property</caption><tbody>  <tr>    <td>Property</td>    <td>reg-shift</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>The reg-shift property provides a mechanism to represent devices that are identical in most respects except for the number of bytes between registers. The reg-shift property specifies in bytes how far the discrete device registers are separated from each other. The individual register location is calculated by using following formula: “registers address” &lt;&lt; reg-shift. If unspecified, the default value is 0.<br>For example, in a system where 16540 UART registers are located at addresses 0x0, 0x4, 0x8, 0xC, 0x10, 0x14, 0x18, and 0x1C, a reg-shift = &lt;2&gt; property would be used to specify register locations.</td>  </tr></tbody></table><h4 id="label-属性"><a href="#label-属性" class="headerlink" title="label 属性"></a>label 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.3: label Property</caption><tbody>  <tr>    <td>Property</td>    <td>label</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;string&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>The label property defines a human readable string describing a device. The binding for a given device specifies the exact meaning of the property for that device.</td>  </tr></tbody></table><h2 id="4-2-串行设备"><a href="#4-2-串行设备" class="headerlink" title="4.2 串行设备"></a>4.2 串行设备</h2><h3 id="4-2-1-串行类别绑定"><a href="#4-2-1-串行类别绑定" class="headerlink" title="4.2.1 串行类别绑定"></a>4.2.1 串行类别绑定</h3><p>串行设备类别由各种类型的点对点串行线路设备组成。串行线路设备的示例包括 8250 UART、16550 UART、HDLC 设备和 BISYNC 设备。在大多数情况下，与 RS-232 标准兼容的硬件适用于串行设备类别。</p><p>I2C 和 SPI（Serial Peripheral Interface）设备 <strong>不能</strong> 表示为串行端口设备，因为它们有自己的特定表示。</p><h4 id="clock-frequency-属性-1"><a href="#clock-frequency-属性-1" class="headerlink" title="clock-frequency 属性"></a>clock-frequency 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.4: clock-frequency Property</caption><tbody>  <tr>    <td>Property</td>    <td>clock-frequency</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies the frequency in Hertz of the baud rate generator’s input clock.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">clock-frequency = &lt;100000000&gt;;</td>  </tr></tbody></table><h4 id="current-speed-属性"><a href="#current-speed-属性" class="headerlink" title="current-speed 属性"></a>current-speed 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.5: current-speed Property</caption><tbody>  <tr>    <td>Property</td>    <td>current-speed</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies the current speed of a serial device in bits per second. A boot program should set this property if it has initialized the serial device.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">115,200 Baud: current-speed = &lt;115200&gt;;</td>  </tr></tbody></table><h3 id="4-2-2-national-semiconductor-16450-x2f-16550-compatible-uart-requirements"><a href="#4-2-2-national-semiconductor-16450-x2f-16550-compatible-uart-requirements" class="headerlink" title="4.2.2 National Semiconductor 16450&#x2F;16550 Compatible UART Requirements"></a>4.2.2 National Semiconductor 16450&#x2F;16550 Compatible UART Requirements</h3><p>与 National Semiconductor 16450&#x2F;16550 UART（Universal Asynchronous Receiver Transmitter）兼容的串行设备应使用以下属性在设备树中表示。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 4.6: ns16550 UART Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>compatible</td>    <td>R</td>    <td>&lt;stringlist&gt;</td>    <td>Value shall include “ns16550”.</td>  </tr>  <tr>    <td style="white-space: nowrap;">clock-frequency</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Specifies the frequency (in Hz) of the baud rate generator’s input clock</td>  </tr>  <tr>    <td>current-speed</td>    <td>OR</td>    <td>&lt;u32&gt;</td>    <td>Specifies current serial device speed in bits per second</td>  </tr>  <tr>    <td>reg</td>    <td>R</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>Specifies the physical address of the registers device within the address space of the parent bus</td>  </tr>  <tr>    <td>interrupts</td>    <td>OR</td>    <td>&lt;prop-encoded-array&gt;</td>    <td>Specifies the interrupts generated by this device. The value of the interrupts property consists of one or more interrupt specifiers. The format of an interrupt specifier is defined by the binding document describing the node’s interrupt parent.</td>  </tr>  <tr>    <td>reg-shift</td>    <td>O</td>    <td>&lt;u32&gt;</td>    <td>Specifies in bytes how far the discrete device registers are separated from each other. The individual register location is calculated by using following formula: "registers address" &lt;&lt; reg-shift. If unspecified, the default value is 0.</td>  </tr>  <tr>    <td>virtual-reg</td>    <td>SD</td>    <td>&lt;u32&gt; or &lt;u64&gt;</td>    <td>See Section 2.3.7. Specifies an effective address that maps to the first physical address specified in the reg property. This property is required if this device node is the system’s console.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h2 id="4-3-网络设备"><a href="#4-3-网络设备" class="headerlink" title="4.3 网络设备"></a>4.3 网络设备</h2><p>网络设备是面向分组（Packet）的通信设备。在此类别中的设备都假定其实现了七层 OSI 模型的数据链路层（第 2 层）并使用 MAC（Media Access Control）地址。网络设备的示例包括 Ethernet、FDDI、802.11 和 Token-Ring。</p><h3 id="4-3-1-网络类别绑定"><a href="#4-3-1-网络类别绑定" class="headerlink" title="4.3.1 网络类别绑定"></a>4.3.1 网络类别绑定</h3><h4 id="address-bits-属性"><a href="#address-bits-属性" class="headerlink" title="address-bits 属性"></a>address-bits 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.7: address-bits Property</caption><tbody>  <tr>    <td>Property</td>    <td>address-bits</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies number of address bits required to address the device described by this node. This property specifies number of bits in MAC address. If unspecified, the default value is 48.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">address-bits = &lt;48&gt;;</td>  </tr></tbody></table><h4 id="local-mac-address-属性"><a href="#local-mac-address-属性" class="headerlink" title="local-mac-address 属性"></a>local-mac-address 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.8: local-mac-address Property</caption><tbody>  <tr>    <td>Property</td>    <td>local-mac-address</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt; encoded as an array of hex numbers</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies MAC address that was assigned to the network device described by the node containing this property.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">local-mac-address = [ 00 00 12 34 56 78 ];</td>  </tr></tbody></table><h4 id="mac-address-属性"><a href="#mac-address-属性" class="headerlink" title="mac-address 属性"></a>mac-address 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.9: mac-address Property</caption><tbody>  <tr>    <td>Property</td>    <td>mac-address</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt; encoded as an array of hex numbers</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies the MAC address that was last used by the boot program. This property should be used in cases where the MAC address assigned to the device by the boot program is different from the local-macaddress property. This property shall be used only if the value differs from local-mac-address property value.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">mac-address = [ 01 02 03 04 05 06 ];</td>  </tr></tbody></table><h4 id="max-frame-size-属性"><a href="#max-frame-size-属性" class="headerlink" title="max-frame-size 属性"></a>max-frame-size 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.10: max-frame-size Property</caption><tbody>  <tr>    <td>Property</td>    <td>max-frame-size</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies maximum packet length in bytes that the physical interface can send and receive.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">max-frame-size = &lt;1518&gt;;</td>  </tr></tbody></table><h3 id="4-3-2-ethernet-的特定考量"><a href="#4-3-2-ethernet-的特定考量" class="headerlink" title="4.3.2 Ethernet 的特定考量"></a>4.3.2 Ethernet 的特定考量</h3><p>基于 IEEE 802.3 LAN 标准集的网络设备（统一称为 Ethernet）除了网络设备类别的特定属性外，还可以使用以下属性在设备树中表示。</p><p>本节中列出的属性扩充了网络设备类别中列出的属性。</p><h4 id="max-speed-属性"><a href="#max-speed-属性" class="headerlink" title="max-speed 属性"></a>max-speed 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.11: max-speed Property</caption><tbody>  <tr>    <td>Property</td>    <td>max-speed</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;u32&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies maximum speed (specified in megabits per second) supported the device.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">max-speed = &lt;1000&gt;;</td>  </tr></tbody></table><h4 id="phy-connection-type-属性"><a href="#phy-connection-type-属性" class="headerlink" title="phy-connection-type 属性"></a>phy-connection-type 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.12: phy-connection-type Property</caption><tbody>  <tr>    <td>Property</td>    <td>phy-connection-type</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;string&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies interface type between the Ethernet device and a physical layer (PHY) device. The value of this property is specific to the implementation.<br>Recommended values are shown in the following table.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">phy-connection-type = "mii";</td>  </tr></tbody></table><table><caption style="caption-side: top; white-space: nowrap;">Table 4.13: Defined values for the phy-connection-type Property</caption><thead>  <tr>    <th>Connection type</th>    <th>Value</th>  </tr></thead><tbody>  <tr>    <td>Media Independent Interface</td>    <td>mii</td>  </tr>  <tr>    <td>Reduced Media Independent Interface</td>    <td>rmii</td>  </tr>  <tr>    <td>Gigabit Media Independent Interface</td>    <td>gmii</td>  </tr>  <tr>    <td>Reduced Gigabit Media Independent</td>    <td>rgmii</td>  </tr>  <tr>    <td>rgmii with internal delay</td>    <td>rgmii-id</td>  </tr>  <tr>    <td>rgmii with internal delay on TX only</td>    <td style="white-space: nowrap;">rgmii-txid</td>  </tr>  <tr>    <td>rgmii with internal delay on RX only</td>    <td>rgmii-rxid</td>  </tr>  <tr>    <td>Ten Bit Interface</td>    <td>tbi</td>  </tr>  <tr>    <td>Reduced Ten Bit Interface</td>    <td>rtbi</td>  </tr>  <tr>    <td>Serial Media Independent Interface</td>    <td>smii</td>  </tr>  <tr>    <td>Serial Gigabit Media Independent Interface</td>    <td>sgmii</td>  </tr>  <tr>    <td>Reverse Media Independent Interface</td>    <td>rev-mii</td>  </tr>  <tr>    <td>10 Gigabits Media Independent Interface</td>    <td>xgmii</td>  </tr>  <tr>    <td>Multimedia over Coaxial</td>    <td>moca</td>  </tr>  <tr>    <td>Quad Serial Gigabit Media Independent Interface</td>    <td>qsgmii</td>  </tr>  <tr>    <td style="white-space: nowrap;">Turbo Reduced Gigabit Media Independent Interface</td>    <td>trgmii</td>  </tr></tbody></table><h4 id="phy-handle-属性"><a href="#phy-handle-属性" class="headerlink" title="phy-handle 属性"></a>phy-handle 属性</h4><table><caption style="caption-side: top; white-space: nowrap;">Table 4.14: phy-handle Property</caption><tbody>  <tr>    <td>Property</td>    <td>phy-handle</td>  </tr>  <tr>    <td style="white-space: nowrap;">Value type</td>    <td style="white-space: nowrap;">&lt;phandle&gt;</td>  </tr>  <tr>    <td style="vertical-align:top;">Description</td>    <td>Specifies a reference to a node representing a physical layer (PHY) device connected to this Ethernet device. This property is required in case where the Ethernet device is connected a physical layer device.</td>  </tr>  <tr>    <td style="white-space: nowrap;">Example</td>    <td style="white-space: nowrap;">phy-handle = &lt;&PHY0&gt;;</td>  </tr></tbody></table><h2 id="4-4-power-isa-open-pic-中断控制器"><a href="#4-4-power-isa-open-pic-中断控制器" class="headerlink" title="4.4 Power ISA Open PIC 中断控制器"></a>4.4 Power ISA Open PIC 中断控制器</h2><p>本节规定了表示 Open PIC compatible 中断控制器的要求。Open PIC 中断控制器实现了 Open PIC 架构（由 AMD 和 Cyrix 联合开发）并在 Open Programmable Interrupt Controller (PIC) Register Interface Specification Revision 1.2 [<a href="#bibliography">b18</a>] 中被指定。</p><p>Open PIC 中断域中的中断说明符用两个 cell 编码。第一个 cell 定义中断号。第二个 cell 定义了感应和电平信息。</p><p>感应和电平信息 <strong>必须</strong> 在中断说明符中编码如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>= low <span class="hljs-keyword">to</span> high edge sensitive type enabled<br><span class="hljs-symbol">1 </span>= active low level sensitive type enabled<br><span class="hljs-symbol">2 </span>= active high level sensitive type enabled<br><span class="hljs-symbol">3 </span>= high <span class="hljs-keyword">to</span> low edge sensitive type enabled<br></code></pre></td></tr></table></figure><table><caption style="caption-side: top; white-space: nowrap;">Table 4.15: Open-PIC properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>compatible</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>Value shall include "open-pic"</td>  </tr>  <tr>    <td>reg</td>    <td>R</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>Specifies the physical address of the registers device within the address space of the parent bus</td>  </tr>  <tr>    <td style="white-space: nowrap;">interrupt-controller</td>    <td>R</td>    <td>&lt;empty&gt;</td>    <td>Specifies that this node is an interrupt controller</td>  </tr>  <tr>    <td>#interrupt-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Shall be 2.</td>  </tr>  <tr>    <td>#address-cells</td>    <td>R</td>    <td>&lt;u32&gt;</td>    <td>Shall be 0.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><blockquote><p>注：所有其他标准属性（ <a href="#2-3-%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7">第 2.3 节</a> ）都是允许的，但都是可选的。</p></blockquote><h2 id="4-5-simple-bus-compatible-value"><a href="#4-5-simple-bus-compatible-value" class="headerlink" title="4.5 simple-bus Compatible Value"></a>4.5 simple-bus Compatible Value</h2><p>片上系统处理器可能具有无法探测设备的内部 I&#x2F;O 总线。无需额外配置即可直接访问总线上的设备。这种类型的总线表示为具有 <code>&quot;simple-bus&quot;</code> compatible 值的节点。</p><table><caption style="caption-side: top; white-space: nowrap;">Table 4.16: simple-bus Compatible Node Properties</caption><thead>  <tr>    <th style="white-space: nowrap;">Property Name</th>    <th>Usage</th>    <th>Value Type</th>    <th>Definition</th>  </tr></thead><tbody>  <tr>    <td>compatible</td>    <td>R</td>    <td>&lt;string&gt;</td>    <td>Value shall include “simple-bus”.</td>  </tr>  <tr>    <td>ranges</td>    <td>R</td>    <td style="white-space: nowrap;">&lt;prop-encoded-array&gt;</td>    <td>This property represents the mapping between parent address to child address spaces (see Section 2.3.8, ranges).</td>  </tr>  <tr>    <td style="white-space: nowrap;">nonposted-mmio</td>    <td>O</td>    <td>&lt;empty&gt;</td>    <td>Specifies that direct children of this bus should use non-posted memory accesses (i.e. a nonposted mapping mode) for MMIO ranges.</td>  </tr>  <tr>    <td colspan="4">Usage legend: R=Required, O=Optional, OR=Optional but Recommended, SD=See Definition</td>  </tr></tbody></table><h1 id="5-flattened-devicetree-dtb-format"><a href="#5-flattened-devicetree-dtb-format" class="headerlink" title="5. FLATTENED DEVICETREE (DTB) FORMAT"></a>5. FLATTENED DEVICETREE (DTB) FORMAT</h1><p>DTB（Devicetree Blob）格式是设备树数据的扁平二进制编码。它用于在软件程序之间交付设备树数据。例如，在引导操作系统时，固件会将 DTB 传递给操作系统内核。</p><blockquote><p>注：IEEE1275 Open Firmware [<a href="#bibliography">IEEE1275</a>] 没有定义 DTB 格式。在大多数 Open Firmware 兼容平台上，设备树是通过调用固件方法来遍历树结构来提取的。</p></blockquote><p>DTB 格式在单个、线性、无指针的数据结构中对设备树数据进行编码。它由一个小尺寸的 header（参见 <a href="#5-2-header">第 5.2 节</a> ）组成，随后是三个可变大小的部分：memory reservation block（参见 <a href="#5-3-memory-reservation-block">第 5.3 节</a> ）、structure block（参见 <a href="#5-4-structure-block">第 5.4 节</a> ）和 strings block（参见 <a href="#5-5-strings-block">第 5.5 节</a> ）。这些应该按该顺序出现在扁平设备树中。因此，设备树结构作为一个整体，当在地址处加载到内存中时，将类似于 Fig. 5.1 中的图（地址从顶部开始由低到高）。</p><p><img src="/images/devicetree-specification/fig5.1.png" alt="Fig. 5.1: Devicetree .dtb Structure"></p><p>free space 部分可能不存在，但在某些情况下，它们可能需要满足各个块的对齐约束（参见 <a href="#5-6-%E5%AF%B9%E9%BD%90">第 5.6 节</a> ）。</p><h2 id="5-1-versioning"><a href="#5-1-versioning" class="headerlink" title="5.1 Versioning"></a>5.1 Versioning</h2><p>自该格式的原始定义以来，已经定义了几个版本的扁平设备树结构。Header 中的字段给出版本，以便客户程序可以确定设备树是否以兼容格式编码。</p><p>本文档仅描述了该格式的第 17 版。DTSpec-compliant 引导程序应提供版本 17 或更高版本的设备树，并应提供与版本 16 向后兼容的版本的设备树。DTSpec-compliant 客户程序应接受与版本 17 向后兼容的任何版本的设备树，并且也可以接受其他的版本。</p><blockquote><p>注：版本是关于设备树的二进制结构的，而不是它的内容。</p></blockquote><h2 id="5-2-header"><a href="#5-2-header" class="headerlink" title="5.2 Header"></a>5.2 Header</h2><p>设备树的 header 布局由以下 C 结构定义。Header 的所有字段都是 32-bit 整数，以 big-endian 格式存储。</p><p><strong>Flattened Devicetree Header Fields</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdt_header</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> magic;<br>    <span class="hljs-type">uint32_t</span> totalsize;<br>    <span class="hljs-type">uint32_t</span> off_dt_struct;<br>    <span class="hljs-type">uint32_t</span> off_dt_strings;<br>    <span class="hljs-type">uint32_t</span> off_mem_rsvmap;<br>    <span class="hljs-type">uint32_t</span> version;<br>    <span class="hljs-type">uint32_t</span> last_comp_version;<br>    <span class="hljs-type">uint32_t</span> boot_cpuid_phys;<br>    <span class="hljs-type">uint32_t</span> size_dt_strings;<br>    <span class="hljs-type">uint32_t</span> size_dt_struct;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>magic</code> This field shall contain the value 0xd00dfeed (big-endian).</li><li><code>totalsize</code> This field shall contain the total size in bytes of the devicetree data structure. This size shall encompass all sections of the structure: the header, the memory reservation block, structure block and strings block, as well as any free space gaps between the blocks or after the final block.</li><li><code>off_dt_struct</code> This field shall contain the offset in bytes of the structure block (see Section 5.4) from the beginning of the header.</li><li><code>off_dt_strings</code> This field shall contain the offset in bytes of the strings block (see Section 5.5) from the beginning of the header.</li><li><code>off_mem_rsvmap</code> This field shall contain the offset in bytes of the memory reservation block (see Section 5.3) from the beginning of the header.</li><li><code>version</code> This field shall contain the version of the devicetree data structure. The version is 17 if using the structure as defined in this document. An DTSpec boot program may provide the devicetree of a later version, in which case this field shall contain the version number defined in whichever later document gives the details of that version.</li><li><code>last_comp_version</code> This field shall contain the lowest version of the devicetree data structure with which the version used is backwards compatible. So, for the structure as defined in this document (version 17), this field shall contain 16 because version 17 is backwards compatible with version 16, but not earlier versions. As per Section 5.1, a DTSpec boot program should provide a devicetree in a format which is backwards compatible with version 16, and thus this field shall always contain 16.</li><li><code>boot_cpuid_phys</code> This field shall contain the physical ID of the system’s boot CPU. It shall be identical to the physical ID given in the reg property of that CPU node within the devicetree.</li><li><code>size_dt_strings</code> This field shall contain the length in bytes of the strings block section of the devicetree blob.</li><li><code>size_dt_struct</code> This field shall contain the length in bytes of the structure block section of the devicetree blob.</li></ul><h2 id="5-3-memory-reservation-block"><a href="#5-3-memory-reservation-block" class="headerlink" title="5.3 Memory Reservation Block"></a>5.3 Memory Reservation Block</h2><h3 id="5-3-1-目的"><a href="#5-3-1-目的" class="headerlink" title="5.3.1 目的"></a>5.3.1 目的</h3><p><strong>Memory Reservation Block</strong> 为客户程序提供物理内存中保留的区域列表；也就是说，它不能用于一般的内存分配。它用于保护重要的数据结构不被客户程序覆盖。例如，在某些具有 IOMMU 的系统上，由 DTSpec 引导程序初始化的 TCE（Translation Control Entry）表需要以这种方式进行保护。同样，在客户程序运行时使用的任何引导程序代码或数据都需要保留（例如，Open Firmware 平台上的 RTAS）。DTSpec 不要求引导程序提供任何此类运行时组件，但它并不禁止实现这样做以作为扩展。</p><p>更具体地说，客户程序不应访问保留区域中的内存，除非引导程序提供的其他信息明确表明它可以这样做。客户程序可以以指示的方式访问 reserved memory 的指示部分。引导程序可以向客户程序指示 reserved memory 的特定用途的方法可能出现在本文档、它的可选扩展或特定于平台的文档中。</p><p>引导程序提供的保留区域可以但不是必须包含 devicetree blob 本身。客户程序应确保在使用此数据结构之前不会覆盖它，无论它是否在保留区域中。</p><p>Any memory that is declared in a memory node and is accessed by the boot program or caused to be accessed by the boot program after client entry must be reserved. Examples of this type of access include (e.g., speculative memory reads through a non-guarded virtual page).</p><p>This requirement is necessary because any memory that is not reserved may be accessed by the client program with arbitrary storage attributes.</p><p>Any accesses to reserved memory by or caused by the boot program must be done as not Caching Inhibited and Memory Coherence Required (i.e., WIMG &#x3D; 0bx01x), and additionally for Book III-S implementations as not Write Through Required (i.e., WIMG &#x3D; 0b001x). Further, if the VLE storage attribute is supported, all accesses to reserved memory must be done as VLE&#x3D;0.</p><p>This requirement is necessary because the client program is permitted to map memory with storage attributes specified as not Write Through Required, not Caching Inhibited, and Memory Coherence Required (i.e., WIMG &#x3D; 0b001x), and VLE&#x3D;0 where supported. The client program may use large virtual pages that contain reserved memory. However, the client program may not modify reserved memory, so the boot program may perform accesses to reserved memory as Write Through Required where conflicting values for this storage attribute are architecturally permissible.</p><h3 id="5-3-2-格式"><a href="#5-3-2-格式" class="headerlink" title="5.3.2 格式"></a>5.3.2 格式</h3><p>Memory Reservation Block 由成对的 64-bit big-endian 整数对组成，每一对由以下 C 结构表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fdt_reserve_entry</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> address;<br>    <span class="hljs-type">uint64_t</span> size;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每对都给出了 reserved memory 区域的物理地址和大小（以字节为单位）。这些给定区域 <strong>不能</strong> 相互重叠。保留块列表 <strong>必须</strong> 以地址和大小都等于 0 的条目结束。请注意，地址和大小值始终为 64-bit。在 32-bit CPU 上，该值的高 32-bit 被忽略。</p><p>Memory Reservation Block 中的每个 uint64_t 以及整个 memory reservation block 都 <strong>必须</strong> 位于距 devicetree blob 开始的 8-byte 对齐偏移处（参见 <a href="#5-6-%E5%AF%B9%E9%BD%90">第 5.6 节</a> ）。</p><h3 id="5-3-3-memory-reservation-block-和-uefi"><a href="#5-3-3-memory-reservation-block-和-uefi" class="headerlink" title="5.3.3 Memory Reservation Block 和 UEFI"></a>5.3.3 Memory Reservation Block 和 UEFI</h3><p>与 &#x2F;reserved-memory 节点（ <a href="#3-5-4-reserved-memory-%E5%92%8C-uefi">第 3.5.4 节</a> ）一样，通过 [<a href="#bibliography">UEFI</a>] 引导时，Memory Reservation Block 中的条目也必须列在通过 <code>GetMemoryMap()</code> 获得的系统内存映射中，以防止 UEFI 应用程序分配。Memory Reservation Block 条目 <strong>应该</strong> 以 <code>EfiReservedMemoryType</code> 类型列出。</p><h2 id="5-4-structure-block"><a href="#5-4-structure-block" class="headerlink" title="5.4 Structure Block"></a>5.4 Structure Block</h2><p>Structure Block 描述了设备树本身的结构和内容。它由一系列带有数据的标记组成，如下所述。这些被组织成线性树结构，如下所述。</p><p>Structure Block 中的每个标记，以及 structure block 本身，都 <strong>必须</strong> 位于距 devicetree blob 开始的 4-byte 对齐偏移处（参见 <a href="#5-6-%E5%AF%B9%E9%BD%90">第 5.6 节</a> ）。</p><h3 id="5-4-1-词法结构"><a href="#5-4-1-词法结构" class="headerlink" title="5.4.1 词法结构"></a>5.4.1 词法结构</h3><p>Structure Block 由一系列片段组成，每个片段都以一个标记开头，即一个 big-endian 32-bit 整数。一些标记后面会紧随额外的数据，其格式由标记值确定。所有标记都 <strong>必须</strong> 在 32-bit 边界上对齐，这可能需要在前一个标记的数据之后插入填充字节（值为 0x0）。</p><p>五种标记类型如下：</p><ul><li><code>FDT_BEGIN_NODE (0x00000001)</code> 标记标志着节点表示的开始。其后 <strong>必须</strong> 紧随节点的单元名称以作为额外数据。名称以空字符结尾的字符串存储，并且如果有单元地址的话，则 <strong>必须</strong> 包括单元地址（参见 <a href="#2-2-1-%E8%8A%82%E7%82%B9%E5%90%8D">第 2.2.1 节</a> ）。节点名称后跟零填充字节（如果需要对齐），然后是下一个标记（可以是除 <code>FDT_END</code> 之外的任何标记）。</li><li><code>FDT_END_NODE (0x00000002)</code> 标记标志着节点表示的结束。这个标记没有额外的数据，因此紧随其后的是下一个标记（可以是除 <code>FDT_PROP</code> 之外的任何标记）。</li><li><code>FDT_PROP (0x00000003)</code> 标记标志着设备树中一个属性表示的开始。其后 <strong>必须</strong> 紧随描述属性的额外数据。该数据首先包含属性的长度和名称，表示为以下 C 结构：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len;<br>    <span class="hljs-type">uint32_t</span> nameoff;<br>&#125;<br></code></pre></td></tr></table></figure>  此结构中的两个字段都是 32-bit big-endian 整数。<ul><li><code>len</code> 以字节为单位给出属性值的长度（可能为零，表示为空属性，参见 <a href="#2-2-4-%E5%B1%9E%E6%80%A7">第 2.2.4 节</a> ）。</li><li><code>nameoff</code> 为 strings block（见 <a href="#5-5-strings-block">第 5.5 节</a> ）提供了一个偏移量，在该块中，属性的名称被存储为一个以空字符结尾的字符串。<br>  在这个结构之后，属性的值以长度为 <code>len</code> 的字节串形式给出。该值后跟零填充字节（如有必要）以对齐下一个 32-bit 边界，然后是下一个标记，该标记可以是除 <code>FDT_END</code> 之外的任何标记。</li></ul></li><li><code>FDT_NOP (0x00000004)</code> 标记会被解析设备树的任何程序忽略。这个标记没有额外的数据，因此紧随其后的是下一个标记。树中的属性或节点定义可以用 <code>FDT_NOP</code> 标记覆盖以将其从树中删除，而无需在 devicetree blob 中移动树表示的其他部分。</li><li><code>FDT_END (0x00000009)</code> 标记标志着 structure block 的结束。Structure Block <strong>必须</strong> 只有一个 <code>FDT_END</code> 标记，并且它应该是 structure block 中的最后一个标记。它没有额外的数据，因此紧随其后的字节与 structure block 开头的偏移量等于 devicetree blob header 中的 <code>size_dt_struct</code> 字段的值。</li></ul><h3 id="5-4-2-树结构"><a href="#5-4-2-树结构" class="headerlink" title="5.4.2 树结构"></a>5.4.2 树结构</h3><p>设备树结构表示为一棵线性树：每个节点的表示以 <code>FDT_BEGIN_NODE</code> 标记开始，以 <code>FDT_END_NODE</code> 标记结束。节点的属性和子节点（如果有）在 <code>FDT_END_NODE</code> 之前表示，因此这些子节点的 <code>FDT_BEGIN_NODE</code> 和 <code>FDT_END_NODE</code> 标记嵌套在父节点的标记中。</p><p>整个 structure block 由根节点的表示（包含所有其他节点的表示）组成，后跟一个 <code>FDT_END</code> 标记以标注整个 structure block 的结束。</p><p>更准确地说，每个节点的表示由以下部分组成：</p><ul><li>（可选）任意数量的 <code>FDT_NOP</code> 标记</li><li><code>FDT_BEGIN_NODE</code> 标记<ul><li>节点名称为空终止字符串</li><li>[零填充字节对齐 4-byte 边界]</li></ul></li><li>对于节点的每个属性：<ul><li>（可选）任意数量的 <code>FDT_NOP</code> 标记</li><li><code>FDT_PROP</code> 标记<ul><li><a href="#5-4-1-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84">第 5.4.1 节</a> 中给出的属性信息</li><li>[零填充字节对齐 4-byte 边界]</li></ul></li></ul></li><li>这种格式的所有子节点的表示</li><li>（可选）任意数量的 <code>FDT_NOP</code> 标记</li><li><code>FDT_END_NODE</code> 标记</li></ul><p>请注意，此过程要求特定节点的所有属性定义都位于该节点的任何子节点定义之前。虽然如果属性和子节点混合在一起，结构不会有歧义，但处理扁平树所需的代码被此要求简化了。</p><h2 id="5-5-strings-block"><a href="#5-5-strings-block" class="headerlink" title="5.5 Strings Block"></a>5.5 Strings Block</h2><p>Strings Block 包含树中使用的所有属性名称的字符串。这些以空结尾的字符串在本部分中简单地连接在一起，并从 structure block 中通过偏移量引用到 strings block 中。</p><p>Strings Block 没有对齐约束，并且可以出现在距 devicetree blob 开头的任何偏移处。</p><h2 id="5-6-对齐"><a href="#5-6-对齐" class="headerlink" title="5.6 对齐"></a>5.6 对齐</h2><p>devicetree blob <strong>必须</strong> 位于一个 8-byte 对齐的地址。为了保持对 32-bit 机器的向后兼容性，某些软件支持 4-byte 对齐，但这并不 DTSpec-compliant。</p><p>对于要在没有未对齐内存访问的情况下使用的 memory reservation block 和 structure block 中的数据，它们 <strong>必须</strong> 位于适当对齐的内存地址。具体来说，memory reservation block <strong>必须</strong> 与 8-byte 边界对齐，structure block <strong>必须</strong> 与 4-byte 边界对齐。</p><p>此外，可以在不破坏子块对齐的情况下重新定位整个 devicetree blob。</p><p>如前几节所述，structure block 和 strings block <strong>必须</strong> 具有与 devicetree blob 开头对齐的偏移量。为了确保块的内存对齐，确保将设备树作为一个整体加载到与任何子块的最大对齐对齐的地址，即与 8-byte 边界对齐就足够了。DTSpec-compliant 的引导程序 <strong>必须</strong> 在将 devicetree blob 传递给客户程序之前将其加载到这样一个对齐的地址。如果 DTSpec 客户程序将 devicetree blob 重新定位到内存中，它 <strong>应该</strong> 只对另一个 8-byte 对齐的地址执行此操作。</p><h1 id="6-devicetree-source-dts-format-version-1"><a href="#6-devicetree-source-dts-format-version-1" class="headerlink" title="6. DEVICETREE SOURCE (DTS) FORMAT (VERSION 1)"></a>6. DEVICETREE SOURCE (DTS) FORMAT (VERSION 1)</h1><p>DTS（Devicetree Source）格式是设备树的文本表示，其格式可以由 dtc 处理成内核期望的二进制设备树。以下描述不是 DTS 的正式语法定义，而是描述用于表示设备树的基本构造。</p><p>DTS 文件的名称 <strong>应该</strong> 以“.dts”结尾。</p><h2 id="6-1-编译器指令"><a href="#6-1-编译器指令" class="headerlink" title="6.1 编译器指令"></a>6.1 编译器指令</h2><p>可以从 DTS 文件中包含其他源文件。包含文件的名称应以“.dtsi”结尾。包含的文件又可以包含其他文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/include/</span> <span class="hljs-string">&quot;FILE&quot;</span><br></code></pre></td></tr></table></figure><h2 id="6-2-标签"><a href="#6-2-标签" class="headerlink" title="6.2 标签"></a>6.2 标签</h2><p>源格式允许将标签（Label）附加到设备树中的任何节点或属性值。Phandle 和路径引用可以通过引用标签而不是显式指定 phandle 值或节点的完整路径来自动生成。标签仅用于 devicetree 源格式，不编码进 DTB 二进制文件。</p><p>标签的长度 <strong>必须</strong> 在 1 到 31 个字符之间，仅由 Table 6.1 中的字符组成，并且不得以数字开头。</p><p>标签是通过在标签名称后附加一个冒号（‘:’）来创建的。引用是通过在标签名称前加上和号（‘&amp;’）来创建的。</p><table><caption style="caption-side: top">Table 6.1: Valid characters for DTS labels</caption><thead>  <tr>    <th style="text-align: center">Character</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">0-9</td>    <td>digit</td>  </tr>  <tr>    <td style="text-align: center">a-z</td>    <td>lowercase letter</td>  </tr>  <tr>    <td style="text-align: center">A-Z</td>    <td>uppercase letter</td>  </tr>  <tr>    <td style="text-align: center">_</td>    <td>underscore</td>  </tr></tbody></table><h2 id="6-3-节点和属性定义"><a href="#6-3-节点和属性定义" class="headerlink" title="6.3 节点和属性定义"></a>6.3 节点和属性定义</h2><p>设备树节点使用节点名称和单元地址定义，大括号标记节点定义的开始和结束。它们前面可能有一个标签。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[label:]</span> node-name<span class="hljs-selector-attr">[@unit-address]</span> &#123;<br>    <span class="hljs-selector-attr">[properties definitions]</span><br>    <span class="hljs-selector-attr">[child nodes]</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>节点可能包含属性定义和&#x2F;或子节点定义。如果两者都存在，则属性 <strong>必须</strong> 位于子节点之前。</p><p>之前定义的节点 <strong>可以</strong> 被删除。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">/<span class="hljs-built_in">delete-node/</span> <span class="hljs-string">node-name</span>;<br>/<span class="hljs-built_in">delete-node/</span> &amp;<span class="hljs-string">label</span>;<br></code></pre></td></tr></table></figure><p>属性定义是以下形式的名称值对：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[label:]</span> <span class="hljs-attr">property-name</span> = value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>或者是具有以下形式的空（零长度）值的属性：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[<span class="hljs-keyword">label</span>:] <span class="hljs-keyword">property</span>-<span class="hljs-keyword">name</span>;<br></code></pre></td></tr></table></figure><p>以前定义的属性 <strong>可以</strong> 被删除。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">/<span class="hljs-built_in">delete-property/</span> <span class="hljs-string">property-name</span>;<br></code></pre></td></tr></table></figure><p>属性值可以定义为 32-bit 整数 cell 的数组、以空字符结尾的字符串、字节字符串或这些的组合。</p><ul><li>cell 数组由空格分隔的 C 样式整数列表的尖括号表示。例子：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">interrupts</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">17</span> <span class="hljs-number">0</span>xc&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>值可以表示为括号内的算术、按位或逻辑表达式。  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Arithmetic operators<br><br>+   <span class="hljs-built_in">add</span><br>-   <span class="hljs-built_in">subtract</span><br>*   <span class="hljs-built_in">multiply</span><br>/   <span class="hljs-built_in">divide</span><br>%   modulo<br></code></pre></td></tr></table></figure>  <figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">Bitwise operators<br><br>&amp;  <span class="hljs-built_in"> and</span><br><span class="hljs-built_in"></span>|  <span class="hljs-built_in"> or</span><br><span class="hljs-built_in"></span>^   exclusive<span class="hljs-built_in"> or</span><br><span class="hljs-built_in"></span>~  <span class="hljs-built_in"> not</span><br><span class="hljs-built_in"></span>&lt;&lt;  left shift<br>&gt;&gt;  right shift<br></code></pre></td></tr></table></figure>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Logical operators<br><br><span class="hljs-meta">&amp;&amp;  and</span><br><span class="hljs-string">||  or</span><br>!   not<br></code></pre></td></tr></table></figure>  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Relational operators<br><br>&lt;   less than<br>&gt;   greater than<br>&lt;=  less than or equal<br>&gt;=  greater than or equal<br><span class="hljs-section">==  equal</span><br>!=  not equal<br></code></pre></td></tr></table></figure>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Ternary operators<br><br>?:  (condition ? value_if_true : <span class="hljs-type">value_if_false</span>)<br></code></pre></td></tr></table></figure></li><li>一个 64-bit 值由两个 32-bit cell 表示。例子：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">clock-frequency</span> <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0</span>x00000001 <span class="hljs-number">0</span>x00000000&gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>以空字符结尾的字符串值使用双引号表示（属性值被认为包括以空字符结尾的字符）。例子：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>一个字节串用方括号 [] 括起来，每个字节由两个十六进制数字表示。每个字节之间的空格是可选的。例子：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">local-mac-address</span> <span class="hljs-operator">=</span> [<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">34</span> <span class="hljs-number">56</span> <span class="hljs-number">78</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>  或等效地：  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">local-mac-address</span> <span class="hljs-operator">=</span> [<span class="hljs-number">000012345678</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>值可能有几个逗号分隔的部分，它们连接在一起。例子：  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">compatible</span> = <span class="hljs-string">&quot;ns16550&quot;</span>, <span class="hljs-string">&quot;ns8250&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">example</span> = &lt;<span class="hljs-number">0</span>xf00f0000 <span class="hljs-number">19</span>&gt;, <span class="hljs-string">&quot;a strange property format&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>在 cell 数组中，对另一个节点的引用将扩展为该节点的 <code>phandle</code> 。引用 <strong>可以</strong> 是 &amp; 后跟一个节点的标签。例子：  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">interrupt-parent</span> = &lt; &amp;mpic &gt;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>  或者它们 <strong>可以</strong> 是 &amp; 后跟一个节点的完整路径，用大括号括起来。例子：  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>errupt-parent = &lt; &amp;&#123;/soc/<span class="hljs-built_in">int</span>errupt-<span class="hljs-symbol">controller@</span><span class="hljs-number">40000</span>&#125; &gt;;<br></code></pre></td></tr></table></figure></li><li>在 cell 数组之外，对另一个节点的引用将扩展到该节点的完整路径。例子：  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ethernet0</span> = &amp;EMAC0<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure></li><li>标签也 <strong>可以</strong> 出现在属性值的任何部分之前或之后，或者在 cell 数组的 cell 之间，或者在字节串的字节之间。例子：  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">reg</span> = reglabel: &lt;<span class="hljs-number">0</span> sizelabel: <span class="hljs-number">0</span>x1000000&gt;<span class="hljs-comment">;</span><br><span class="hljs-attr">prop</span> = [ab cd ef byte4: <span class="hljs-number">00</span> ff fe]<span class="hljs-comment">;</span><br><span class="hljs-attr">str</span> = start: <span class="hljs-string">&quot;string value&quot;</span> end: <span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6-4-文件布局"><a href="#6-4-文件布局" class="headerlink" title="6.4 文件布局"></a>6.4 文件布局</h2><p>版本 1 DTS 文件具有整体布局：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">/dts-v1/;<br><span class="hljs-string">[memory reservations]</span><br>    / &#123;<br><span class="hljs-string">        [property definitions]</span><br><span class="hljs-string">        [child nodes]</span><br>    &#125;;<br></code></pre></td></tr></table></figure><p><code>/dts-v1/;</code> <strong>必须</strong> 存在以将文件标识为版本 1 DTS（没有此标记的 dts 文件将被 dtc 视为处于过时的版本 0 中，除了其他小的但不兼容的更改之外，它使用不同的整数格式）。</p><p>Memory reservations（参见 <a href="#5-3-memory-reservation-block">第 5.3 节</a> ）由以下形式的行表示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">/memreserve/ <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">length</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>其中 <code>&lt;address&gt;</code> 和 <code>&lt;length&gt;</code> 是 64-bit C-style 整数，例如，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Reserve memory region 0x10000000..0x10003fff */</span><br><span class="hljs-regexp">/memreserve/</span> <span class="hljs-number">0</span>x10000000 <span class="hljs-number">0</span>x4000;<br></code></pre></td></tr></table></figure><p>这 <code>/ &#123; ... &#125;;</code> 部分定义了设备树的根节点，所有设备树数据都包含在其中。</p><p>支持 C-style（ <code>/* ... \*/</code> ）和 C++-style（ <code>//</code> ）注释。</p><h1 id="bibliography"><a href="#bibliography" class="headerlink" title="BIBLIOGRAPHY"></a>BIBLIOGRAPHY</h1><p>[IEEE1275] <em>Boot (Initialization Configuration) Firmware: Core Requirements and Practices</em>, 1994, This is the core standard (also known as IEEE 1275) that defines the devicetree concept adopted by the DTSpec and ePAPR. It is available from Global Engineering (<a href="http://global.ihs.com/">http://global.ihs.com/</a>).</p><p>[b7] <em>Open Firmware Recommended Practice: Interrupt Mapping</em>, Version 0.9, Open Firmware Working Group, 1996 (<a href="http://devicetree.org/open-firmware/practice/imap/imap0_9d.pdf">http://devicetree.org/open-firmware/practice/imap/imap0_9d.pdf</a>)</p><p>[CHRP] <em>PowerPC Microprocessor Common Hardware Reference Platform (CHRP) Binding</em>, Version 1.8, Open Firmware Working Group, 1998 (<a href="http://devicetree.org/open-firmware/bindings/chrp/chrp1_8a.ps">http://devicetree.org/open-firmware/bindings/chrp/chrp1_8a.ps</a>). This document specifies the properties for Open PIC-compatible interrupt controllers.</p><p>[PAPR] <em>Power.org Standard for Power Architecture Platform Requirements</em>, power.org</p><p>[b18] <em>The Open Programmable Interrupt Controller (PIC) Register Interface Specification Revision 1.2</em>, AMD and Cyrix, October 1995</p><p>[EPAPR] <em>Power.org Standard for Embedded Power Architecture Platform Requirements</em>, power.org, 2011, <a href="https://www.power.org/documentation/power-org-standard-for-embedded-power-architecture-platform-requirements-epapr-v1-1-2/">https://www.power.org/documentation/power-org-standard-for-embedded-power-architecture-platform-requirements-epapr-v1-1-2/</a></p><p>[UEFI] <a href="https://uefi.org/sites/default/files/resources/UEFI_Spec_2_8_A_Feb14.pdf">Unified Extensable Firmware Interface Specification v2.8 Errata A</a>, February 2020, <a href="http://www.uefi.org/">UEFI Forum</a></p>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>Devicetree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>i.MX RT1060 Manufacturing User&#39;s Guide</title>
    <link href="/2022/05/25/imx-rt1060-manufacturing-users-guide/"/>
    <url>/2022/05/25/imx-rt1060-manufacturing-users-guide/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Document identifier: IMXRT1060MFUUG<br>Rev. 3, 29 June 2020</p></blockquote><hr><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>该文档描述了 i.MX RT 设备的可引导映像的生成。还说明了 i.MX RT BootROM 和 MCUBOOT-based Flashloader 的交互过程，以及将可引导映像编程到外部闪存中的过程，外部闪存可以是：</p><ul><li>QuadSPI NOR &#x2F; Octal Flash &#x2F; HyperFlash</li><li>Serial NAND</li><li>eMMC</li><li>SD</li><li>Parallel NOR</li><li>SLC raw NAND</li><li>SPI NOR&#x2F;EEPROM</li></ul><p>i.MX RT BootROM 驻留在 ROM 中并且能够装载 RAM。Flashloader 会被装载到 SRAM 中，以便从引导设备中将引导映像装载到 RAM。它还会验证和执行引导映像。</p><p>本文档介绍 Flashloader，它是 i.MX RT BootROM 的一个配套工具，也是一个用于将引导映像编程到可引导设备的完整解决方案。Flashloader 是在 SRAM 中运行的，因此应通过 ROM serial download interface 将其下载到 SRAM。Flashloader 会进行一些准备工作并配置用于引导的设备。它在可引导介质上创建引导配置结构、帮助对加密映像进行编程、生成密钥 blob，并使用用于下载引导映像的 MCUBOOT 命令接口协议与串行外设（如 USB 和 UART）上的 master 进行通信。</p><p>它还采用了 elftosb 实用程序。elftosb 实用程序将 elf 映像转换为 i.MX RT 设备的已签名、已加密和可引导的映像。它还会创建所有引导结构，如映像向量表、引导数据。它生成使用 NXP 签名工具（cst）进行代码签名或加密所需的输入命令序列文件。它还调用 cst 来生成签名，并将其包装成 BootROM 可接受的引导映像。</p><p>本文档介绍了 MfgTool2.exe（Manufacturing Tool）在制造环境中用于生产设备（使用所有可用工具在可引导介质上编程引导映像）的用法。</p><h1 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h1><h2 id="2-1-i-mx-rt-bootrom"><a href="#2-1-i-mx-rt-bootrom" class="headerlink" title="2.1 i.MX RT BootROM"></a>2.1 i.MX RT BootROM</h2><p>i.MX RT BootROM 是所有 i.MX RT 设备的标准引导加载程序。它驻留在 ROM 中，并支持从外部闪存设备（XIP 和 non-XIP）中引导。它还通过 UART 或 USB-HID 接口向 i.MX RT 设备的内部 RAM 提供串行下载器功能。</p><p>i.MX RT BootROM 是现有 i.MX MPU ROM bootloader 的一个特定实现。i.MX RT BootROM 提供串行下载器功能以使用 SDP 命令接口进行闪存编程。有关其他信息，请参阅 <em>i.MX RT1060 processor reference manual</em> 中的“<em>System Boot</em>”。使用 MfgTool 应用程序可以将 MCU Boot based flashloader 下载到内部 SRAM 中。然后，flashloader 代码执行开始，并通过 MCU Boot 接口启用闪存编程功能。</p><h2 id="2-2-mcuboot-based-flashloader"><a href="#2-2-mcuboot-based-flashloader" class="headerlink" title="2.2 MCUBOOT-based Flashloader"></a>2.2 MCUBOOT-based Flashloader</h2><p>MCUBOOT-based Flashloader 是 MCU Bootloader 的一个特定实现。它被用作生产制造的一次性编程辅助工具。Flashloader 支持大多数 MCUBOOT 命令以启用外部闪存编程。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em>。</p><h2 id="2-3-主机实用程序"><a href="#2-3-主机实用程序" class="headerlink" title="2.3 主机实用程序"></a>2.3 主机实用程序</h2><p>MfgTool 是一个 GUI 主机程序，用于在串行下载器模式下与运行 i.MX RT BootROM 的设备进行交互。它还可以用于通过与 Flashloader 交互来对应用程序映像进行编程。</p><p>blhost 是一个 CLI 主机程序，用于与运行 MCUBOOT-based bootloaders 的设备进行交互。它是 MfgTool 的一部分。</p><p>elftosb 实用程序是一个 CLI 主机程序，用于为 i.MX RT BootROM 生成可引导映像。</p><p>cst 是一个 CLI 主机程序，用于为 i.MX RT BootROM 生成证书、映像签名和加密映像。</p><h2 id="2-4-术语"><a href="#2-4-术语" class="headerlink" title="2.4 术语"></a>2.4 术语</h2><p>Table 1 总结了本文档中包含的术语和缩写。</p><table><caption style="caption-side: top">Table 1. Terminology and Abbreviations</caption><thead>  <tr>    <th style="text-align: center">Terminology</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">MCUBOOT</td>    <td>MCU Bootloader</td>  </tr>  <tr>    <td style="text-align: center">KeyBlob</td>    <td>KeyBlob is a data structure that wraps the DEK for image decryption using the AES-CCM algorithm</td>  </tr>  <tr>    <td style="text-align: center">DEK</td>    <td>"Key" used to decrypt the encrypted bootable image</td>  </tr>  <tr>    <td style="text-align: center">SB file</td>    <td>The SB file is the NXP binary file format for bootable images. The file consists of sections, sequence of bootloader commands, and data that assists MCU Bootloader in programming the image to target memory. The image data can also be encrypted in the SB file. The file can be downloaded to the target using the MCU Bootloader receive-sb-file command.</td>  </tr>  <tr>    <td style="text-align: center">CST</td>    <td>Code Signing Tool</td>  </tr>  <tr>    <td style="text-align: center">XIP</td>    <td>Execute-In-Place</td>  </tr></tbody></table><h1 id="3-i-mx-rt-可引导映像"><a href="#3-i-mx-rt-可引导映像" class="headerlink" title="3 i.MX RT 可引导映像"></a>3 i.MX RT 可引导映像</h1><h2 id="3-1-目标闪存设备中的可引导映像布局"><a href="#3-1-目标闪存设备中的可引导映像布局" class="headerlink" title="3.1 目标闪存设备中的可引导映像布局"></a>3.1 目标闪存设备中的可引导映像布局</h2><p>支持两种引导映像：</p><ul><li>XIP（Execute-In-Place）引导映像：此类引导映像仅适用于连接到 QuadSPI 或 FlexSPI 接口的 Serial NOR 设备和连接到 WEIM 或 SEMC 接口的 Parallel NOR 设备。引导设备内存与目标内存相同。ROM 可以直接引导这种引导映像。</li><li>Non-XIP 引导映像：此类引导映像通常用于 NAND、SD 和 eMMC 设备。引导设备内存与目标内存不同。ROM 可以从引导设备内存中将引导映像加载到目标内存，然后从目标内存引导。</li></ul><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure1.jpg" alt="Figure 1. Bootable image layout"></p><h2 id="3-2-引导映像格式"><a href="#3-2-引导映像格式" class="headerlink" title="3.2 引导映像格式"></a>3.2 引导映像格式</h2><p>本节介绍引导映像格式和数据结构。elftosb 实用程序可帮助客户自动生成引导映像格式文件。本文档稍后将介绍 elftosb 实用程序的用法。</p><p>可引导映像必须具有以下数据结构：</p><ul><li>映像向量表（IVT，Image Vector Table）：一个位于固定地址的指针列表，ROM 会检查该列表以确定可引导映像的其他组件的位置</li><li>引导数据（Boot Data）：一个指示可引导映像位置、映像大小（以字节为单位）和插件标志的表</li><li>设备配置数据（DCD，Device configuration data）（可选）：IC 配置数据配置 DDR&#x2F;SDRAM 内存</li><li>用户应用程序和数据（User application and data）</li><li>CSF（可选）：通过 CST 生成的用于安全引导的签名块</li><li>KeyBlob（可选）：一个数据结构，包含用于加密引导的 wrapped DEK</li></ul><p>每个可引导映像都以适当的 IVT 开始。一般来说，对于支持 XIP 特性的外部存储设备，IVT 偏移量为 0x1000，否则为 0x400。例如，对于 RT1060 上的 FlexSPI NOR，IVT 必须从地址 0x60001000 开始（起始地址为 0x6000_0000，IVT 偏移量为 0x1000）。有关更多信息，请参阅相应的处理器参考手册。</p><h3 id="3-2-1-ivt-和-boot-data"><a href="#3-2-1-ivt-和-boot-data" class="headerlink" title="3.2.1 IVT 和 Boot Data"></a>3.2.1 IVT 和 Boot Data</h3><p>IVT 是 BootROM 从引导设备中读取的数据结构。此数据结构提供包含执行成功引导所需的数据组件的可引导映像。</p><p>有关详细信息，请参阅设备参考手册的 <em>System Boot</em> 章节中的 <em>Program image</em> 小节。</p><table><caption style="caption-side: top">Table 2. IVT data structure</caption><thead>  <tr>    <th>Offset</th>    <th>Field</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="white-space:nowrap">0x00 - 0x03</td>    <td>header</td>    <td>      <ul>        <li>Byte 0 tag, fixed to 0xD1</li>        <li>Byte 1,2 length, bit endian format containing the overall length of the IVT in bytes, fixed to 0x00, 0x20</li>        <li>Byte 3: version, valid values: 0x40, 0x41, 0x42, 0x43</li>      </ul>    </td>  </tr>  <tr>    <td style="white-space:nowrap">0x04 - 0x07</td>    <td>entry</td>    <td>Absolute address of the first instruction to execute from the image, or the vector address of the image</td>  </tr>  <tr>    <td style="white-space:nowrap">0x08 - 0x0b</td>    <td>reserved1</td>    <td>Reserved for future use, set to 0</td>  </tr>  <tr>    <td style="white-space:nowrap">0x0c - 0x0f</td>    <td>dcd</td>    <td>Absolute address of the image DCD. It is optional, so this field can be set to NULL if no DCD is required</td>  </tr>  <tr>    <td style="white-space:nowrap">0x10 - 0x13</td>    <td>boot_data</td>    <td>Absolute address of the boot data</td>  </tr>  <tr>    <td style="white-space:nowrap">0x14 - 0x17</td>    <td>self</td>    <td>Absolute address of the IVT</td>  </tr>  <tr>    <td style="white-space:nowrap">0x18 - 0x1b</td>    <td>csf</td>    <td>Absolute address of the Command Sequence File (CSF) used by the HAB library</td>  </tr>  <tr>    <td style="white-space:nowrap">0x1c - 0x1f</td>    <td>reserved2</td>    <td>Reserved, set to 0</td>  </tr></tbody></table><h3 id="3-2-2-boot-data-结构"><a href="#3-2-2-boot-data-结构" class="headerlink" title="3.2.2 Boot Data 结构"></a>3.2.2 Boot Data 结构</h3><table><caption style="caption-side: top">Table 3. Boot Data structure</caption><thead>  <tr>    <th style="text-align: center">Offset</th>    <th style="text-align: center">Field</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center; white-space:nowrap">0x00-0x03</td>    <td style="text-align: center">start</td>    <td>Absolute address of the bootable image</td>  </tr>  <tr>    <td style="text-align: center; white-space:nowrap">0x04-0x07</td>    <td style="text-align: center">length</td>    <td>Size of the bootable image</td>  </tr>  <tr>    <td style="text-align: center; white-space:nowrap">0x08-0x0b</td>    <td style="text-align: center">plugin</td>    <td>Plugin flag, set to 0 because plugin boot is not supported on the RT1010</td>  </tr></tbody></table><h2 id="3-3-签名映像"><a href="#3-3-签名映像" class="headerlink" title="3.3 签名映像"></a>3.3 签名映像</h2><p>可引导映像可以通过 CST 工具进行签名。该工具根据给定的输入命令序列文件（csf 文件）生成由命令序列和签名组成的二进制文件格式的 CSF 数据。有关更多详细信息，请参阅 CST 发行包中的文档。</p><p>在本文档中，将介绍一种使用 elftosb 实用程序生成签名映像的简单方法。</p><h2 id="3-4-加密映像"><a href="#3-4-加密映像" class="headerlink" title="3.4 加密映像"></a>3.4 加密映像</h2><p>有两种类型的加密映像格式：</p><p><strong>已加密的 XIP 映像格式</strong></p><p>Flashloader 在对设备上的映像进行编程时使用 AES CTR 算法生成加密的 XIP 图像。在执行时，硬件引擎进行动态解密。</p><p><strong>通过 CST 生成的加密映像</strong></p><p>为了提高安全级别，可以通过 CST 对可引导映像进行签名和进一步加密。KeyBlob 必须在设备上生成。如果发生任何安全违规，硬件将删除所有敏感密钥，从而无法克隆敏感密钥。</p><p>在本文档中，将介绍一种使用 elftosb 实用程序生成签名映像的简单方法。</p><h1 id="4-生成-i-mx-rt-可引导映像"><a href="#4-生成-i-mx-rt-可引导映像" class="headerlink" title="4 生成 i.MX RT 可引导映像"></a>4 生成 i.MX RT 可引导映像</h1><p>i.MX RT 设备有两种类型的可引导映像。</p><ul><li>普通引导映像：这种类型的映像可以直接通过 BootROM 引导。</li><li>插件式引导映像：这种类型的映像可用于从 BootROM 本身不支持的设备中加载引导映像。</li></ul><p>两种类型的映像都可以针对不同的生产阶段和不同的安全级别要求进行签名和加密：</p><ul><li>未签名映像：映像不包含与验证相关的数据，在开发阶段使用。</li><li>已签名映像：映像包含与验证相关的数据（CSF 部分），在生产阶段使用。</li><li>已加密映像：映像包含加密的应用数据和验证相关数据，在安全要求较高的生产阶段使用。</li></ul><p>可以使用 elftosb 实用程序生成上述类型的可引导映像。elftosb 实用程序的详细用法可在 <em>elftosb Users Guide</em> 中找到。</p><h2 id="4-1-elftosb-实用程序简介"><a href="#4-1-elftosb-实用程序简介" class="headerlink" title="4.1 elftosb 实用程序简介"></a>4.1 elftosb 实用程序简介</h2><p>elftosb 实用程序是一个 CLI 主机程序，用于为 i.MX RT BootROM 生成 i.MX RT 可引导映像。该实用程序还生成带有命令序列和可引导映像的包装的二进制文件。要创建 SB 文件，请使用命令行选项和输入文本文件（也称为 BD 或命令文件）。</p><h3 id="4-1-1-elftosb-实用程序选项"><a href="#4-1-1-elftosb-实用程序选项" class="headerlink" title="4.1.1 elftosb 实用程序选项"></a>4.1.1 elftosb 实用程序选项</h3><p>Table 4 显示了用于创建 i.MX RT 可引导映像的命令行选项。</p><table><caption style="caption-side: top">Table 4. elftosb utility options</caption><thead>  <tr>    <th style="text-align: center">Option</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">-f</td>    <td>Specify the bootable image format<br><br>To create the i.MX RT bootable image, the usage for family argument "-f" is: "-f imx"<br><br>To create the SB file, the usage is: "-f kinetis"</td>  </tr>  <tr>    <td style="text-align: center">-c</td>    <td>Command file to generate corresponding bootable image<br><br>For example, "-c program_flexspi_nor_hyperflash.bd"</td>  </tr>  <tr>    <td style="text-align: center">-o</td>    <td>Output file path<br><br>For example, "-o ivt_flashloader.bin"</td>  </tr>  <tr>    <td style="text-align: center">-V</td>    <td>Print extra detailed log information</td>  </tr>  <tr>    <td style="text-align: center">-?</td>    <td>Print help info</td>  </tr></tbody></table><h3 id="4-1-2-bd-文件"><a href="#4-1-2-bd-文件" class="headerlink" title="4.1.2 BD 文件"></a>4.1.2 BD 文件</h3><p>每个 BD 文件由以下四个块组成：options、sources、constants、section</p><ul><li>映像路径在“sources”块中定义。</li><li>常量变量在“constants”块中定义。</li><li>内存配置和编程相关操作在“section”块中定义。</li></ul><p>elftosb 实用程序支持两种类型的 BD 文件。第一种文件用于 i.MX RT 可引导映像生成。在使用 elftosb 实用程序生成引导映像期间，“-f imx”选项是必需的。第二种文件包含用于内存编程的命令。在此用例中，“-f kinetis”标志是强制要求的。</p><h3 id="4-1-3-用于-i-mx-rt-可引导映像生成的-bd-文件"><a href="#4-1-3-用于-i-mx-rt-可引导映像生成的-bd-文件" class="headerlink" title="4.1.3 用于 i.MX RT 可引导映像生成的 BD 文件"></a>4.1.3 用于 i.MX RT 可引导映像生成的 BD 文件</h3><p>用于 i.MX RT 可引导映像生成的 BD 文件通常由四个块组成。这些块是 options、sources、constants 和 section。</p><h4 id="4-1-3-1-options-块"><a href="#4-1-3-1-options-块" class="headerlink" title="4.1.3.1 Options 块"></a>4.1.3.1 Options 块</h4><p>Table 5 显示了用于生成可引导映像的 Options 块的选项。</p><table><caption style="caption-side: top">Table 5. Supported options in the "Options" block</caption><thead>  <tr>    <th style="text-align: center">Options</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">Flags</td>    <td>Generates unsigned, signed, encrypted boot images, and plugin images:      <ul>        <li>bit 2 - Encrypted image flag</li>        <li>bit 3 - Signed image flag</li>        <li>bit 4 - Plugin image flag</li>      </ul>      For example:      <ul>        <li>0x00 - unsigned image</li>        <li>0x08 - signed image</li>        <li>0x04 - encrypted image (encrypted image is always a signed image)</li>        <li>0x18 - signed plugin image</li>      </ul>    </td>  </tr>  <tr>    <td style="text-align: center">startAddress</td>    <td>Provides the starting address of the target memory where image should be loaded by ROM.</td>  </tr>  <tr>    <td style="text-align: center">ivtOffset</td>    <td>Provides offset where the IVT data structure must appear in the boot image. The default is 0x400 if not specified.<br><br>The valid value is 0x400 or 0x1000 for i.MX RT boot image.</td>  </tr>  <tr>    <td style="text-align: center">initialLoadSize</td>    <td>Defines the start of the executable image data from elf or the srec file.<br><br>The default value is 0x2000 if not specified.<br><br>In general, this value should be 0x1000 or 0x2000.</td>  </tr>  <tr>    <td style="text-align: center">DCDFilePath</td>    <td>Defines the path to DCD file.<br><br>If not specified, the DCD pointer in the IVT will be set to NULL (0) else the dcd file contents will be loaded at offset 0x40 from ivtOffset. The dcd file size is limited to (initialLoadSize - ivtOffset-0x40).</td>  </tr>  <tr>    <td style="text-align: center">cstFolderPath</td>    <td>Defines the path for platform dependent CST. (windows, linux)<br><br>If not specified, elftosb tool will search for cst executable in same path as elftosb executable.</td>  </tr>  <tr>    <td style="text-align: center">entryPointAddress</td>    <td>Provides the entry point address for ELF or SREC image.<br><br>If not specified, ELF image uses its source image entry point address but SREC image will use default entry point address (0).</td>  </tr></tbody></table><h4 id="4-1-3-2-sources-块"><a href="#4-1-3-2-sources-块" class="headerlink" title="4.1.3.2 Sources 块"></a>4.1.3.2 Sources 块</h4><p>通常，该部分提供所有应用程序映像路径。目前，i.MX RT 可引导映像生成支持 ELF 文件和 SREC 文件，例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">sources &#123;<br>    elfFile <span class="hljs-operator">=</span> extern(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-3-constants-块"><a href="#4-1-3-3-constants-块" class="headerlink" title="4.1.3.3 Constants 块"></a>4.1.3.3 Constants 块</h4><p>Constants 块提供一个常量变量，用于生成 CSF 数据以进行映像验证和解密。对于未签名映像，Constants 块是可选的。下面列出了支持的常量。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Constants &#123;<br>    SEC_CSF_HEADER <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span><br>    SEC_CSF_INSTALL_SRK <span class="hljs-operator">=</span> <span class="hljs-number">21</span><span class="hljs-comment">;</span><br>    SEC_CSF_INSTALL_CSFK <span class="hljs-operator">=</span> <span class="hljs-number">22</span><span class="hljs-comment">;</span><br>    SEC_CSF_INSTALL_NOCAK <span class="hljs-operator">=</span> <span class="hljs-number">23</span><span class="hljs-comment">;</span><br>    SEC_CSF_AUTHENTICATE_CSF <span class="hljs-operator">=</span> <span class="hljs-number">24</span><span class="hljs-comment">;</span><br>    SEC_CSF_INSTALL_KEY <span class="hljs-operator">=</span> <span class="hljs-number">25</span><span class="hljs-comment">;</span><br>    SEC_CSF_ AUTHENTICATE_DATA <span class="hljs-operator">=</span> <span class="hljs-number">26</span><span class="hljs-comment">;</span><br>    SEC_CSF_INSTALL_SECRET_KEY <span class="hljs-operator">=</span> <span class="hljs-number">27</span><span class="hljs-comment">;</span><br>    SEC_CSF_DECRYPT_DATA <span class="hljs-operator">=</span> <span class="hljs-number">28</span><span class="hljs-comment">;</span><br>    SEC_NOP <span class="hljs-operator">=</span> <span class="hljs-number">29</span><span class="hljs-comment">;</span><br>    SEC_SET_MID <span class="hljs-operator">=</span> <span class="hljs-number">30</span><span class="hljs-comment">;</span><br>    SEC_SET_ENGINE <span class="hljs-operator">=</span> <span class="hljs-number">31</span><span class="hljs-comment">;</span><br>    SEC_INIT <span class="hljs-operator">=</span> <span class="hljs-number">32</span><span class="hljs-comment">;</span><br>    SEC_UNLOCK <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-4-section-块"><a href="#4-1-3-4-section-块" class="headerlink" title="4.1.3.4 Section 块"></a>4.1.3.4 Section 块</h4><p>Section 块用于创建 i.MX RT 可引导映像的 section，例如，CSF 数据的所有 section。对于未签名映像，Section 块是固定的空白 section，如下所示。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">section</span> (<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于已签名和已加密的映像，elftosb 实用程序定义了以下 sections，以生成 CST 生成 CSF 数据所需的 CSF 描述符文件。</p><ul><li>SEC_CSF_HEADER</li></ul><p>该 section 定义了生成 CSF 头所需的必要元素以及用于其余 CSF 中其他 section 的默认值。</p><table><caption style="caption-side: top">Table 6. Elements for CSF Header section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">Header_Version</td>    <td>HAB library version<br><br>Valid values: 4.0, 4.1, 4.2, 4.3</td>  </tr>  <tr>    <td style="text-align: center">Header_HashAlgorithm</td>    <td>Default Hash Algorithm<br><br>Valid values: sha1, sha256, sha512</td>  </tr>  <tr>    <td style="text-align: center">Header_Engine</td>    <td>Default Engine<br><br>Valid values: ANY, DCP, CAAM, SW</td>  </tr>  <tr>    <td style="text-align: center">Header_EngineConfiguration</td>    <td>Default Engine Configuration<br><br>Recommended value: 0</td>  </tr>  <tr>    <td style="text-align: center">Header_CertificateFormat</td>    <td>Default Certificate Format<br><br>Valid values: WTLS, X509</td>  </tr>  <tr>    <td style="text-align: center">Header_SignatureFormat</td>    <td>Default signature format<br><br>Valid values: PKCS, CMS</td>  </tr>  <tr>    <td style="text-align: center">Header_SecurityConfiguration</td>    <td>Fused security configuration<br><br>Valid values: Engineering, Production</td>  </tr>  <tr>    <td style="text-align: center">Header_UID</td>    <td>Generic (matches any value)<br><br>U0, U1,... Un<br><br>where each Ui=0..255 and n&lt;255</td>  </tr>  <tr>    <td style="text-align: center">Header_CustomerCode</td>    <td>Value expected in "customer code" fuses<br><br>0..255</td>  </tr></tbody></table><p>示例 section 块如下所示。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">section (SEC_CSF_HEADER;<br>    <span class="hljs-attribute">Header_Version</span>=<span class="hljs-string">&quot;4.3&quot;</span>,<br>    <span class="hljs-attribute">Header_HashAlgorithm</span>=<span class="hljs-string">&quot;sha256&quot;</span>,<br>    <span class="hljs-attribute">Header_Engine</span>=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    <span class="hljs-attribute">Header_EngineConfiguration</span>=0,<br>    <span class="hljs-attribute">Header_CertificateFormat</span>=<span class="hljs-string">&quot;x509&quot;</span>,<br>    <span class="hljs-attribute">Header_SignatureFormat</span>=<span class="hljs-string">&quot;CMS&quot;</span><br>    )<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_INSTALL_SRK</li></ul><p>该 section 包含用于验证和安装根公钥的元素，以供后续 section 使用，如下表所示。</p><table><caption style="caption-side: top">Table 7. Elements for CSF Install SRK section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">InstallSRK_Table</td>    <td>Path pointing to the Super Root Key Table file</td>  </tr>  <tr>    <td style="text-align: center">InstallSRK_Source</td>    <td>SRK index with the SRK table</td>  </tr>  <tr>    <td style="text-align: center">InstallSRK_HashAlgorithm</td>    <td>SRK table hash algorithm.<br><br>Valid values: SHA1, SHA256 and SHA512</td>  </tr></tbody></table><p>示例 section 块如下所示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">section (SEC_CSF_INSTALL_SRK;<br>    InstallSRK_Table=<span class="hljs-string">&quot;keys/SRK_1_2_3_4_table.bin&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallSRK_SourceIndex=<span class="hljs-number">0</span><br>    )<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_INSTALL_CSFK</li></ul><p>该 section 包含用于验证和安装公钥的元素，以供后续 section 使用。</p><table><caption style="caption-side: top">Table 8. Elements for CSF Install CSFK section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">InstallCSFK_File</td>    <td>File path pointing to CSFK certificate</td>  </tr>  <tr>    <td style="text-align: center">InstallCSFK_CertificateFormat</td>    <td>CSFK certificate format<br><br>Valid values: WTLS, X509</td>  </tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">section (SEC_CSF_INSTALL_CSFK;<br>    InstallCSFK_File=<span class="hljs-string">&quot;crts/CSF1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallCSFK_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;x509&quot;</span><br>    )<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_INSTALL_NOCAK</li></ul><p>Install NOCAK 命令验证并安装用于快速验证机制（HAB 4.1.2 及更高版本）的公钥。使用这种机制，一个密钥用于所有签名。下表列出了 install NOCAK 命令参数。</p><table><caption style="caption-side: top">Table 9. Elements for CSF Install NOCAK section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">InstallNOCAK_File</td>    <td>File path pointing to CSFK certificate</td>  </tr>  <tr>    <td style="text-align: center">InstallNOCAK_CertificateFormat</td>    <td>CSFK certificate format<br><br>Valid values: WTLS, X509</td>  </tr></tbody></table><p>示例 section 块如下所示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">section (SEC_CSF_INSTALL_NOCAK;<br>    InstallNOCAK_File= <span class="hljs-string">&quot;crts/SRK1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallNOCAK_CertificateFormat= <span class="hljs-string">&quot;WTLS&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;WTLS&quot;</span>, <span class="hljs-string">&quot;X509&quot;</span><br>    )<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_AUTHENTICATE_CSF</li></ul><p>该 section 用于使用上一节中提到的 CSFK 对执行它的 CSF 进行验证。有关详细信息，请参阅下表。</p><table><caption style="caption-side: top">Table 10. Elements for CSF Authenticate CSF section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">AuthenticateCSF_Engine</td>    <td>CSF signature hash engine<br><br>Valid values: ANY, SAHARA, RTIC, DCP, CAAM and SW</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateCSF_EngineConfiguration</td>    <td>Configuration flags for the hash engine. Note that the hash is computed over an internal RAM copy of the CSF<br><br>Valid engine configuration values corresponding to engine name.</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateCSF_SignatureFormat</td>    <td>CSF signature format<br><br>Valid values: PKCS1, CMS</td>  </tr></tbody></table><p>示例 section 块如下所示。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">section</span> (<span class="hljs-variable">SEC_CSF_AUTHENTICATE_CSF</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_INSTALL_KEY</li></ul><p>该 section 包含用于验证和安装公钥的元素，以供后续 section 使用，如下表所示。</p><table><caption style="caption-side: top">Table 11. Elements for CSF Install Key section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">InstallKey_File</td>    <td>File path pointing to a Public key file</td>  </tr>  <tr>    <td style="text-align: center">InstallKey_VerificationIndex</td>    <td>Verification key index in Key store<br><br>Valid values: 0, 2, 3, 4</td>  </tr>  <tr>    <td style="text-align: center">InstallKey_TargetIndex</td>    <td>Target key index in key store<br><br>Valid values: 2, 3, 4</td>  </tr>  <tr>    <td style="text-align: center">InstallKey_CertificateFormat</td>    <td>Valid values: WTLS, X509</td>  </tr>  <tr>    <td style="text-align: center">InstallKey_HashAlgorithm</td>    <td>Hash algorithm for certificate binding.<br><br>If present, a hash of the certificate specified in the File argument is included in the command to prevent installation from other sharing the same verification key<br><br>Valid values: SHA1, SHA256, SHA512</td>  </tr></tbody></table><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">section (SEC_CSF_INSTALL_KEY;<br>    InstallKey_File=<span class="hljs-string">&quot;crts/IMG1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>,<br>    InstallKey_VerificationIndex=<span class="hljs-number">0</span>, <span class="hljs-regexp">//</span> Accepts integer or string<br>    InstallKey_TargetIndex=<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> Accepts integer or string<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_AUTHENTICATE_DATA</li></ul><p>该 section 包含用于验证内存中预加载数据真实性的元素。</p><table><caption style="caption-side: top">Table 12. Elements for CSF Authenticate Data section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">AuthenticateData_VerificationIndex</td>    <td>Verification key index in key store</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateData_Engine</td>    <td>Data signature hash engine<br><br>Valid values: ANY, DCP, CAAM, SW</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateData_EngineConfiguration</td>    <td>Configuration flags for the engine</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateData_SignatureFormat</td>    <td>Data signature format<br><br>Valid values: PKCS1, CMS</td>  </tr>  <tr>    <td style="text-align: center">AuthenticateData_Binding</td>    <td>64-bit unique ID (UID) for binding.<br><br>If present, authentication succeeds only if the UID fuse value matches this argument, and the TYPE fuse value matches the Security Configuration argument from the Header command<br><br>Valid values:<br><br>U0, U1, ... U7<br><br>with<br><br>Ui: 0, ..., 255.<br><br>UID bytes separated by commas</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">section (SEC_CSF_AUTHENTICATE_DATA;<br>    <span class="hljs-attribute">AuthenticateData_VerificationIndex</span>=2,<br>    <span class="hljs-attribute">AuthenticateData_Engine</span>=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    <span class="hljs-attribute">AuthenticateData_EngineConfiguration</span>=0)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_INSTALL_SECRET_KEY</li></ul><p>该 section 包含用于将密钥安装到用于 KeyBlob 解密的 MCU 密钥存储的元素。该 section 是加密映像生成所必需的，而不是签名映像所必需的。</p><table><caption style="caption-side: top">Table 13. Elements for CSF Install Secret Key section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">SecretKey_Name</td>    <td>Specifies the file path used for CST to generate the random decryption key file</td>  </tr>  <tr>    <td style="text-align: center">SecretKey_Length</td>    <td>Key length in bits<br><br>Valid values: 128, 192, and 256</td>  </tr>  <tr>    <td style="text-align: center">SecretKey_VerifyIndex</td>    <td>Master KEK index<br><br>Valid values: 0 or 1</td>  </tr>  <tr>    <td style="text-align: center">SecretKey_TargetIndex</td>    <td>Target secret key store index<br><br>Valid values: 0-3</td>  </tr>  <tr>    <td style="text-align: center">SecretKey_BlobAddress</td>    <td>Internal or external DDR address</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">section (SEC_CSF_INSTALL_SECRET_KEY;<br>    <span class="hljs-attribute">SecretKey_Name</span>=<span class="hljs-string">&quot;dek.bin&quot;</span>,<br>    <span class="hljs-attribute">SecretKey_Length</span>=128,<br>    <span class="hljs-attribute">SecretKey_VerifyIndex</span>=0,<br>    <span class="hljs-attribute">SecretKey_TargetIndex</span>=0)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_CSF_DECRYPT_DATA</li></ul><p>该 section 是加密映像生成所必需的，而不是签名映像所必需的。它包含用于使用存储在密钥存储中的密钥解密和验证代码&#x2F;数据块列表的必要元素，如下表所示。</p><table><caption style="caption-side: top">Table 14. Elements for CSF Decrypt Data section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">Decrypt_Engine</td>    <td>MAC engine<br><br>Valid value: CAAM, DCP</td>  </tr>  <tr>    <td style="text-align: center">Decrypt_EngineConfiguration</td>    <td>Configuration flags for the engine<br><br>Default value: 0</td>  </tr>  <tr>    <td style="text-align: center">Decrypt_VerifyIndex</td>    <td>Secret key index in the Secret key store<br><br>Valid values: 0-3</td>  </tr>  <tr>    <td style="text-align: center">Decrypt_MacBytes</td>    <td>Size of MAC in bytes<br><br>If engine is CAAM, the valid value is even number between 4-16. The recommended value is 16.<br><br>If engine is DCP, the valid value is 16.</td>  </tr></tbody></table><p>示例 section 块如下所示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">section (SEC_CSF_DECRYPT_DATA;<br>    Decrypt_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    Decrypt_EngineConfiguration=<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid engine configuration values&quot;</span><br>    Decrypt_VerifyIndex=<span class="hljs-number">0</span>,<br>    Decrypt_MacBytes=<span class="hljs-number">16</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_NOP</li></ul><p>该 section 中的命令无效。它也没有参数。</p><p>示例 section 块如下所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">section</span> (SEC_NOP)<br>    <span class="hljs-comment">// NOP command has no arguments</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_SET_MID</li></ul><p>Set MID 命令选择一系列 fuse 位置以用作制造标识符（MID，manufacturing identifier）。在使用 Install Key 命令中带有 MID 绑定标志的密钥进行验证时，MID 值与 Authenticate Data 签名绑定。</p><table><caption style="caption-side: top">Table 15. Elements for CSF Set MID section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">SetMID_Bank</td>    <td>Fuse bank containing MID.<br><br>Valid values: 0, …, 255</td>  </tr>  <tr>    <td style="text-align: center">SetMID_Row</td>    <td>Starting row number of MID within bank.<br><br>Valid values: 0, …, 255</td>  </tr>  <tr>    <td style="text-align: center">SetMID_Fuse</td>    <td>Starting fuse of MID within row.<br><br>Valid values: 0, …, 255</td>  </tr>  <tr>    <td style="text-align: center">SetMID_Bits</td>    <td>Number of bits for MID.<br><br>Valid values: 0, …, 255</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">section <span class="hljs-params">(SEC_SET_MID;</span><br><span class="hljs-params">    <span class="hljs-attr">SetMID_Bank</span> = 4,</span><br><span class="hljs-params">    <span class="hljs-attr">SetMID_Row</span> = 0,</span><br><span class="hljs-params">    <span class="hljs-attr">SetMID_Fuse</span> = 7,</span><br><span class="hljs-params">    <span class="hljs-attr">SetMID_Bits</span> = 64)</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_SET_ENGINE</li></ul><p>Set Engine 命令为给定算法选择默认引擎和引擎配置。</p><table><caption style="caption-side: top">Table 16. Elements for CSF Set Engine section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">SetEngine_Engine</td>    <td>Engine<br><br>Use ANY to restore the HAB internal criteria.<br><br>Valid values: ANY, SAHARA, RTIC, DCP, CAAM and SW</td>  </tr>  <tr>    <td style="text-align: center">SetEngine_HashAlgorithm</td>    <td>Hash algorithm<br><br>Valid values: SHA1, SHA256 and SHA512</td>  </tr>  <tr>    <td style="text-align: center">SetEngine_EngineConfiguration</td>    <td>Configuration flags for the engine.<br><br>Valid engine configuration values corresponding to engine name.</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">section</span> (SEC_SET_ENGINE;<br>    <span class="hljs-attribute">SetEngine_HashAlgorithm</span> = <span class="hljs-string">&quot;sha256&quot;</span>,<br>    SetEngine_Engine = <span class="hljs-string">&quot;DCP&quot;</span>,<br>    SetEngine_EngineConfiguration = <span class="hljs-string">&quot;0&quot;</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_INIT</li></ul><p>Init 命令在退出内部 BootROM 时初始化指定的引擎特性。</p><table><caption style="caption-side: top">Table 17. Elements for CSF Init section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">INIT_Engine</td>    <td>Engine to initialize<br><br>Valid value – SRTC</td>  </tr>  <tr>    <td style="text-align: center">INIT_Features</td>    <td>Comma-separated list of features to initialize<br><br>Valid engine feature corresponding to engine argument.</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">section (SEC_INIT<span class="hljs-comment">;</span><br>    Init_Engine <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SRTC&quot;</span>)<br>    // Init_Features<span class="hljs-operator">=</span> <span class="hljs-string">&quot;MID&quot;</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>SEC_UNLOCK</li></ul><p>Unlock 命令可防止在退出内部 BootROM 时锁定指定的引擎特性。</p><table><caption style="caption-side: top">Table 18. Elements for CSF Unlock section generation</caption><thead>  <tr>    <th style="text-align: center">Element</th>    <th>Description</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">Unlock_Engine</td>    <td>Engine to unlock<br><br>Valid values: SRTC, CAAM, SNVS and OCOTP</td>  </tr>  <tr>    <td style="text-align: center">Unlock_features</td>    <td>Comma-separated list of features to unlock<br><br>Valid engine feature corresponding to engine argument.</td>  </tr>  <tr>    <td style="text-align: center">Unlock_UID</td>    <td>Device specific 64-bit UID<br><br>U0, U1, …, U7 with Ui=0...255<br><br>UID bytes separated by commas</td>  </tr></tbody></table><p>示例 section 块如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">section</span> (SEC_UNLOCK;<br>    <span class="hljs-attribute">Unlock_Engine</span> = <span class="hljs-string">&quot;OCOTP&quot;</span>,<br>    Unlock_features = <span class="hljs-string">&quot;JTAG, SRK REVOKE&quot;</span>,<br>    Unlock_UID = <span class="hljs-string">&quot;0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef&quot;</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-用于内存编程的-bd-文件"><a href="#4-1-4-用于内存编程的-bd-文件" class="headerlink" title="4.1.4 用于内存编程的 BD 文件"></a>4.1.4 用于内存编程的 BD 文件</h3><p>通常，“load”、“enable”和“erase”命令是 BD 文件中用于内存编程的最常用命令。</p><ol><li>“load”命令：该命令加载原始二进制文件、srec 文件、elf 文件和十六进制字符串。它还支持将数据加载到外部存储设备，例如：<ul><li>Load itcm_boot_image.bin &gt; 0x8000;（将数据加载到 ITCM）</li><li>Load flexspi_nor_boot_image.bin &gt; 0x60001000;（将数据加载到内存映射的存储设备）</li><li>Load semc_nor_boot_image.bin &gt; 0x80001000;（将数据加载到 SEMC NOR，内存映射的存储设备）</li><li>Load spinand boot_image.bin &gt; 0x04;（将数据加载到 SPI NAND）</li><li>Load sdcard boot_image.bin &gt; 0x400;（将数据加载到 SD Card）</li><li>Load mmccard boot_image.bin &gt; 0x400;（将数据加载到 eMMC）</li><li>Load spieeprom boot_image.bin &gt; 0x400;（将数据加载到 SPI EEPROM&#x2F;NOR）</li><li>Load semcnand boot_image.bin &gt; 0x400;（通过 SEMC 将数据加载到 SLC raw NAND）</li><li>Load fuse 0x00000000 &gt; 0x10;（将数据加载到 Fuse block）</li></ul></li><li>“enable”命令：该命令配置外部存储设备，例如：<ul><li>Enable flexspinor 0x1000</li><li>Enable spinand 0x1000</li><li>Enable sdcard 0x1000</li><li>Enable mmccard 0x1000</li><li>Enable spieeprom 0x1000</li><li>Enable semcnor 0x1000</li><li>Enable semcnand 0x1000</li></ul></li><li>“erase”命令：该命令擦除所选存储设备中的存储范围。例如：<ul><li>Erase 0x60000000..0x60010000（从 FlexSPI NOR 中擦除 64 KB）</li><li>Erase spinand 0x4..0x08（从 SPI NAND 中擦除 4 blocks）</li><li>Erase sdcard 0x400..0x14000</li><li>Erase mmccard 0x400..0x14000</li><li>Erase spieeprom 0x400..0x14000</li><li>Erase semcnand 0x400..0x14000</li></ul></li></ol><h2 id="4-2-生成未签名的普通-i-mx-rt-可引导映像"><a href="#4-2-生成未签名的普通-i-mx-rt-可引导映像" class="headerlink" title="4.2 生成未签名的普通 i.MX RT 可引导映像"></a>4.2 生成未签名的普通 i.MX RT 可引导映像</h2><p>通常，在开发阶段会生成并编程未签名的可引导映像到目标存储器。</p><p>elftosb 实用程序支持使用工具链生成的选项、BD 文件和 ELF&#x2F;SREC 文件生成未签名的可引导映像。</p><p>以 Flashloader 项目为例，以下是为 Flashloader 创建可引导映像的步骤。</p><p><strong>步骤 1</strong>：创建一个 BD 文件。对于未签名映像的创建，“constants”块是可选的，如下所示。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">options &#123;<br>    flags <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x00<span class="hljs-comment">;</span><br>    startAddress <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x20000000<span class="hljs-comment">;</span><br>    ivtOffset <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x400<span class="hljs-comment">;</span><br>    initialLoadSize <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x2000<span class="hljs-comment">;</span><br>&#125;<br>sources &#123;<br>    elfFile <span class="hljs-operator">=</span> extern(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br>section (<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 BD 文件后，将其放入 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 2</strong>：将发行包中提供的 Flashloader.srec 复制到 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 3</strong>：使用 elftosb 实用程序生成可引导映像。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure2.jpg" alt="Figure 2. Example command to generate unsigned boot image"></p><p>然后，elftosb 实用程序会生成两个可引导映像。</p><p>第一个是 ivt_flashloader_unsigned.bin。从 0 到 ivt_offset 的内存区域被填充字节（0x00s）填充。</p><p>第二个是 ivt_flashloader_nopadding.bin，其直接从 ivtdata 开始，并且在 ivt 之前不进行任何填充。</p><h2 id="4-3-生成已签名的普通-i-mx-rt-可引导映像"><a href="#4-3-生成已签名的普通-i-mx-rt-可引导映像" class="headerlink" title="4.3 生成已签名的普通 i.MX RT 可引导映像"></a>4.3 生成已签名的普通 i.MX RT 可引导映像</h2><p>要使用 elftosb 实用程序生成一个已签名可引导的映像，需要执行以下步骤：</p><p><strong>步骤 1</strong>：创建一个 BD 文件。其内容可以如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs awk">options &#123;<br>    flags = <span class="hljs-number">0</span>x08;<br>    startAddress = <span class="hljs-number">0</span>x60000000;<br>    ivtOffset = <span class="hljs-number">0</span>x1000;<br>    initialLoadSize = <span class="hljs-number">0</span>x2000;<br>&#125;<br><br>sources &#123;<br>    elfFile = extern(<span class="hljs-number">0</span>);<br>&#125;<br><br>constants &#123;<br>    SEC_CSF_HEADER = <span class="hljs-number">20</span>;<br>    SEC_CSF_INSTALL_SRK = <span class="hljs-number">21</span>;<br>    SEC_CSF_INSTALL_CSFK = <span class="hljs-number">22</span>;<br>    SEC_CSF_INSTALL_NOCAK = <span class="hljs-number">23</span>;<br>    SEC_CSF_AUTHENTICATE_CSF = <span class="hljs-number">24</span>;<br>    SEC_CSF_INSTALL_KEY = <span class="hljs-number">25</span>;<br>    SEC_CSF_AUTHENTICATE_DATA = <span class="hljs-number">26</span>;<br>    SEC_CSF_INSTALL_SECRET_KEY = <span class="hljs-number">27</span>;<br>    SEC_CSF_DECRYPT_DATA = <span class="hljs-number">28</span>;<br>    SEC_NOP = <span class="hljs-number">29</span>;<br>    SEC_SET_MID = <span class="hljs-number">30</span>;<br>    SEC_SET_ENGINE = <span class="hljs-number">31</span>;<br>    SEC_INIT = <span class="hljs-number">32</span>;<br>    SEC_UNLOCK = <span class="hljs-number">33</span>;<br>&#125;<br><br>section (SEC_CSF_HEADER;<br>    Header_Version=<span class="hljs-string">&quot;4.2&quot;</span>,<br>    Header_HashAlgorithm=<span class="hljs-string">&quot;sha256&quot;</span>,<br>    Header_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    Header_EngineConfiguration=<span class="hljs-number">0</span>,<br>    Header_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span>,<br>    Header_SignatureFormat=<span class="hljs-string">&quot;CMS&quot;</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_SRK;<br>    InstallSRK_Table=<span class="hljs-string">&quot;keys/SRK_1_2_3_4_table.bin&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallSRK_SourceIndex=<span class="hljs-number">0</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_CSFK;<br>    InstallCSFK_File=<span class="hljs-string">&quot;crts/CSF1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallCSFK_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;x509&quot;</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_CSF)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_KEY;<br>    InstallKey_File=<span class="hljs-string">&quot;crts/IMG1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>,<br>    InstallKey_VerificationIndex=<span class="hljs-number">0</span>, <span class="hljs-regexp">//</span> Accepts integer or string<br>    InstallKey_TargetIndex=<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> Accepts integer or string<br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_DATA;<br>    AuthenticateData_VerificationIndex=<span class="hljs-number">2</span>,<br>    AuthenticateData_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    AuthenticateData_EngineConfiguration=<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>section (SEC_SET_ENGINE;<br>    SetEngine_HashAlgorithm = <span class="hljs-string">&quot;sha256&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;sha1&quot;</span>, <span class="hljs-string">&quot;Sha256&quot;</span>, <span class="hljs-string">&quot;sha512&quot;</span><br>    SetEngine_Engine = <span class="hljs-string">&quot;DCP&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;ANY&quot;</span>, <span class="hljs-string">&quot;SAHARA&quot;</span>, <span class="hljs-string">&quot;RTIC&quot;</span>, <span class="hljs-string">&quot;DCP&quot;</span>, <span class="hljs-string">&quot;CAAM&quot;</span> and <span class="hljs-string">&quot;SW&quot;</span><br>    SetEngine_EngineConfiguration = <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid engine configuration values&quot;</span><br>&#123;<br>&#125;<br><br>section (SEC_UNLOCK;<br>    Unlock_Engine = <span class="hljs-string">&quot;SNVS&quot;</span>,<br>    Unlock_features = <span class="hljs-string">&quot;ZMK WRITE&quot;</span><br>    )<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 BD 文件后，将其放入 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 2</strong>：将发行包中提供的 Flashloader.srec 复制到 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 3</strong>：将“cst”可执行文件、“crts”文件夹和“keys”文件夹从“&lt;cst_installation_dir&gt;”复制到 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 4</strong>：使用 elftosb 实用程序生成可引导映像。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure3.jpg" alt="Figure 3. Example command to generate a signed boot image"></p><p>然后，elftosb 实用程序会生成两个可引导映像。第一个是 ivt_flashloader_signed.bin。从 0 到 ivt_offset 的内存区域被填充字节（0x00s）填充。第二个是 ivt_flashloader_signed_nopadding.bin，其直接从 ivt_offset 开始。CSF section 已成功生成并附加到未签名的可引导映像。</p><h2 id="4-4-生成已加密的普通-i-mx-rt-可引导映像"><a href="#4-4-生成已加密的普通-i-mx-rt-可引导映像" class="headerlink" title="4.4 生成已加密的普通 i.MX RT 可引导映像"></a>4.4 生成已加密的普通 i.MX RT 可引导映像</h2><p>要生成加密映像，请执行以下步骤：</p><p><strong>步骤 1</strong>：创建一个 BD 文件。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">options &#123;<br>    flags = <span class="hljs-number">0</span>x0c;<br>    startAddress = <span class="hljs-number">0</span>x20000000;<br>    ivtOffset = <span class="hljs-number">0</span>x400;<br>    initialLoadSize = <span class="hljs-number">0</span>x2000;<br>&#125;<br><br>sources &#123;<br>    elfFile = extern(<span class="hljs-number">0</span>);<br>&#125;<br><br>constants &#123;<br>    SEC_CSF_HEADER = <span class="hljs-number">20</span>;<br>    SEC_CSF_INSTALL_SRK = <span class="hljs-number">21</span>;<br>    SEC_CSF_INSTALL_CSFK = <span class="hljs-number">22</span>;<br>    SEC_CSF_INSTALL_NOCAK = <span class="hljs-number">23</span>;<br>    SEC_CSF_AUTHENTICATE_CSF = <span class="hljs-number">24</span>;<br>    SEC_CSF_INSTALL_KEY = <span class="hljs-number">25</span>;<br>    SEC_CSF_AUTHENTICATE_DATA = <span class="hljs-number">26</span>;<br>    SEC_CSF_INSTALL_SECRET_KEY = <span class="hljs-number">27</span>;<br>    SEC_CSF_DECRYPT_DATA = <span class="hljs-number">28</span>;<br>    SEC_NOP = <span class="hljs-number">29</span>;<br>    SEC_SET_MID = <span class="hljs-number">30</span>;<br>    SEC_SET_ENGINE = <span class="hljs-number">31</span>;<br>    SEC_INIT = <span class="hljs-number">32</span>;<br>    SEC_UNLOCK = <span class="hljs-number">33</span>;<br>&#125;<br><br>section (SEC_CSF_HEADER;<br>    Header_Version=<span class="hljs-string">&quot;4.3&quot;</span>,<br>    Header_HashAlgorithm=<span class="hljs-string">&quot;sha256&quot;</span>,<br>    Header_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    Header_EngineConfiguration=<span class="hljs-number">0</span>,<br>    Header_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span>,<br>    Header_SignatureFormat=<span class="hljs-string">&quot;CMS&quot;</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_SRK;<br>    InstallSRK_Table=<span class="hljs-string">&quot;keys/SRK_1_2_3_4_table.bin&quot;</span>, <span class="hljs-comment">// &quot;valid file path&quot;</span><br>    InstallSRK_SourceIndex=<span class="hljs-number">0</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_CSFK;<br>    InstallCSFK_File=<span class="hljs-string">&quot;crts/CSF1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>, <span class="hljs-comment">// &quot;valid file path&quot;</span><br>    InstallCSFK_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span> <span class="hljs-comment">// &quot;x509&quot;</span><br>    )<br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_CSF)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_KEY;<br>    InstallKey_File=<span class="hljs-string">&quot;crts/IMG1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>,<br>    InstallKey_VerificationIndex=<span class="hljs-number">0</span>, <span class="hljs-comment">// Accepts integer or string</span><br>    InstallKey_TargetIndex=<span class="hljs-number">2</span>) <span class="hljs-comment">// Accepts integer or string</span><br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_DATA;<br>    AuthenticateData_VerificationIndex=<span class="hljs-number">2</span>,<br>    AuthenticateData_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    AuthenticateData_EngineConfiguration=<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_SECRET_KEY;<br>    SecretKey_Name=<span class="hljs-string">&quot;dek.bin&quot;</span>,<br>    SecretKey_Length=<span class="hljs-number">128</span>,<br>    SecretKey_VerifyIndex=<span class="hljs-number">0</span>,<br>    SecretKey_TargetIndex=<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_DECRYPT_DATA;<br>    Decrypt_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    Decrypt_EngineConfiguration=<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-comment">// &quot;valid engine configuration values&quot;</span><br>    Decrypt_VerifyIndex=<span class="hljs-number">0</span>,<br>    Decrypt_MacBytes=<span class="hljs-number">16</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤 2</strong>：将发行包中提供的 Flashloader.srec 复制到 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 3</strong>：将“cst”可执行文件、“crts”文件夹和“keys”文件夹从“&lt;cst_installation_dir&gt;”复制到 elftosb 实用程序可执行文件的同一文件夹中。</p><p><strong>步骤 4</strong>：使用 elftosb 实用程序生成加密的可引导映像。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure4.jpg" alt="Figure 4. Example command to generate an encrypted image"></p><p>然后，elftosb 实用程序会生成两个可引导映像。第一个是 ivt_flashloader_encrypt.bin。从 0 到 ivt_offset 的内存区域被填充字节（0x00s）填充。</p><p>上述示例中的 Key Blob offset 将在后面的 section 中使用。</p><p>第二个是 ivt_flashloader_encrypt_nopadding.bin，其直接从 ivt_offset 开始。CSF section 已成功生成并附加到未签名的可引导映像。</p><p><strong>步骤 5</strong>：使用 Flashloader 生成 KeyBlob section。</p><p>elftosb 实用程序生成的加密映像是不完整的，因为 KeyBlob section 必须仅在 SoC 端生成。</p><p>有两种方法可以生成 KeyBlob 块：</p><ul><li>使用 Flashloader 和 blhost 支持的 <code> generate-key-blob &lt;dek_file&gt; &lt;blob_file&gt;</code> 命令生成 KeyBlob。有关详细信息，请参阅附录。</li><li>在制造过程中生成 KeyBlob 并使用 KeyBlob option 块。有关更多信息，请参见下一章。</li></ul><h2 id="4-5-生成插件式引导映像"><a href="#4-5-生成插件式引导映像" class="headerlink" title="4.5 生成插件式引导映像"></a>4.5 生成插件式引导映像</h2><p>生成插件式引导映像的生成过程与普通引导映像的过程类似。唯一的区别是“options”块中“flags”元素中的第 4 位必须设置为 1。换句话说，插件式引导映像的有效标志值列表是 {0x10, 0x18, 0x1c}。</p><p>插件式引导映像生成的示例 BD 文件如下所示。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">options &#123;<br>    flags <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x10<span class="hljs-comment">;</span><br>    startAddress <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x60000000<span class="hljs-comment">;</span><br>    ivtOffset <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1000<span class="hljs-comment">;</span><br>    initialLoadSize <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x2000<span class="hljs-comment">;</span><br>&#125;<br><br>sources &#123;<br>    elfFile <span class="hljs-operator">=</span> extern(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br><br>section (<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-生成用于可引导映像编程的-sb-文件"><a href="#5-生成用于可引导映像编程的-sb-文件" class="headerlink" title="5 生成用于可引导映像编程的 SB 文件"></a>5 生成用于可引导映像编程的 SB 文件</h1><p>为了简化制造过程，flashloader 和可引导映像支持的所有命令都可以包装到单个 SB 文件中。即使应用程序有任何变化，MfgTool 仍然使用这个 SB 文件来制造。SB 文件可以单独更新，而无需更新 MfgTool 使用的脚本。</p><p>在本章中，将使用前一章的方法创建一个可引导映像。然后使用可引导映像生成相应的 SB 文件。首先要准备 BD 文件以为可引导映像生成 SB 文件。</p><h2 id="5-1-生成用于-flexspi-nor-映像编程的-sb-文件"><a href="#5-1-生成用于-flexspi-nor-映像编程的-sb-文件" class="headerlink" title="5.1 生成用于 FlexSPI NOR 映像编程的 SB 文件"></a>5.1 生成用于 FlexSPI NOR 映像编程的 SB 文件</h2><h3 id="5-1-1-生成普通可引导映像"><a href="#5-1-1-生成普通可引导映像" class="headerlink" title="5.1.1 生成普通可引导映像"></a>5.1.1 生成普通可引导映像</h3><p>例如，在 RT1060 中，FlexSPI NOR 存储器从地址 0x6000_0000 开始，IVT 从偏移量 0x1000 开始。按照 <a href="#4-2-%E7%94%9F%E6%88%90%E6%9C%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E6%99%AE%E9%80%9A-i-mx-rt-%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F">4.2 生成未签名的普通 i.MX RT 可引导映像</a> 和 BD 文件生成中的步骤，这里是使用 elftosb 实用程序为 FlexSPI NOR 创建可引导映像的方法。发行包中提供了所有 BD 文件。下图参考了生成签名映像的示例命令。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure5.jpg" alt="Figure 5. Example command to generate signed FlexSPI boot image"></p><p>运行上述命令后，后缀为“_nopadding.bin”的文件可通过基于此二进制文件的后续 SB 文件进入目标内存。</p><h3 id="5-1-2-生成用于明文-flexspi-nor-映像编程的-sb-文件"><a href="#5-1-2-生成用于明文-flexspi-nor-映像编程的-sb-文件" class="headerlink" title="5.1.2 生成用于明文 FlexSPI NOR 映像编程的 SB 文件"></a>5.1.2 生成用于明文 FlexSPI NOR 映像编程的 SB 文件</h3><p>通常，用于 FlexSPI NOR 引导的 BD 文件由 7 个部分组成。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>在 section 块中提供 FlexSPI NOR Configuration Option 块。</li><li>要启用 FlexSPI NOR 访问，必须在 option 块之后使用“enable”命令。</li><li>如果闪存设备没有被擦除，在将数据编程到闪存设备之前需要一个“erase”命令。擦除操作是耗时的，并且在制造过程中对于空白闪存设备（出厂设置）是不需要的。</li><li>FlexSPI NOR 引导需要 FlexSPI NOR Configuration Block（FNORCB）。要对 FlexSPI NOR Configuration Option 块生成的 FNORCB 进行编程，必须首先将一个特殊的幻数“0xF000000F”加载到 RAM 中。</li><li>要通知闪存 flashloader 对 FNORCB 进行编程，必须在加载幻数后使用“enable”命令。</li><li>完成上述操作后，flashloader 可以通过 FlexSPI 模块使用 load 命令将可引导映像二进制文件编程到 Serial NOR Flash 中。</li></ol><p>包含上述步骤的示例如下图所示。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure6.jpg" alt="Figure 6. Example BD file for FlexSPI NOR programming"></p><p>下面是使用 elftosb 实用程序、ivt_flexspi_nor_xip.bin 和 BD 文件生成 SB 文件的示例，如下图所示。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure7.jpg" alt="Figure 7. Example command to generate SB file for FlexSPI NOR programming"></p><p>在上述命令之后，将在包含 elftosb 实用程序可执行文件的同一文件夹中创建一个名为 boot_image.sb 的文件。</p><h3 id="5-1-3-生成用于-flexspi-nor-映像加密和编程的-sb-文件"><a href="#5-1-3-生成用于-flexspi-nor-映像加密和编程的-sb-文件" class="headerlink" title="5.1.3 生成用于 FlexSPI NOR 映像加密和编程的 SB 文件"></a>5.1.3 生成用于 FlexSPI NOR 映像加密和编程的 SB 文件</h3><p>通常，用于 FlexSPI NOR 映像加密和编程的 BD 文件包含 7 个步骤。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>使用 FlexSPI NOR Configuration Option 块启用 FlexSPI NOR 访问。</li><li>如果闪存设备不是空白的，请擦除它。擦除操作是耗时的，并且在制造过程中对于空白闪存设备（出厂设置）是不需要的。</li><li>使用 PRDB option 块启用映像加密。</li><li>使用幻数对 FNORCB 进行编程。</li><li>通过 FlexSPI 模块将引导映像二进制文件编程到 Serial NOR。</li><li>启用加密 XIP fuse 位。</li></ol><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure8.jpg" alt="Figure 8. Example BD file for encrypted FlexSPI NOR image generation and programming"></p><p>生成 SB 文件的步骤与上一节相同。</p><h2 id="5-2-生成用于-flexspi-nand-映像编程的-sb-文件"><a href="#5-2-生成用于-flexspi-nand-映像编程的-sb-文件" class="headerlink" title="5.2 生成用于 FlexSPI NAND 映像编程的 SB 文件"></a>5.2 生成用于 FlexSPI NAND 映像编程的 SB 文件</h2><p>对于 FlexSPI NAND 引导，IVT 偏移始终为 0x400。但是，为了减少计算每个固件区域的起始地址的工作量，Flashloader 支持将 FlexSPI NAND 引导映像以块粒度编程到相应的固件区域。因此，将使用没有“_nopadding”后缀的可引导映像。</p><h3 id="5-2-1-生成用于-flexspi-nand-映像编程的-sb-文件"><a href="#5-2-1-生成用于-flexspi-nand-映像编程的-sb-文件" class="headerlink" title="5.2.1 生成用于 FlexSPI NAND 映像编程的 SB 文件"></a>5.2.1 生成用于 FlexSPI NAND 映像编程的 SB 文件</h3><p>通常，用于 FlexSPI NAND 映像编程的 SB 文件包含 4 个步骤。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>使用 FlexSPI NAND Configuration Option 块启用 FlexSPI NAND 访问。</li><li>根据需要擦除 SPI NAND。</li><li>通过 FlexSPI 模块将引导映像二进制文件编程到 Serial NAND。</li></ol><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure9.jpg" alt="Figure 9. Example BD file for FlexSPI NAND image programming"></p><h3 id="5-2-2-生成用于已加密-flexspi-nand-映像和-keyblob-编程的-sb-文件"><a href="#5-2-2-生成用于已加密-flexspi-nand-映像和-keyblob-编程的-sb-文件" class="headerlink" title="5.2.2 生成用于已加密 FlexSPI NAND 映像和 KeyBlob 编程的 SB 文件"></a>5.2.2 生成用于已加密 FlexSPI NAND 映像和 KeyBlob 编程的 SB 文件</h3><p>通常，用于使用 KeyBlob 进行 FlexSPI NAND 映像编程的 BD 文件包含 7 个步骤。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>使用 FlexSPI NAND Configuration Option 块启用 FlexSPI NAND 访问。</li><li>根据需要擦除 SPI NAND 设备。</li><li>通过 FlexSPI 模块将引导映像二进制文件编程到 Serial NAND。</li><li>使用 KeyBlob Option 块更新 KeyBlob 信息。</li><li>将 KeyBlob 块编程到固件 0 的 SPI NAND。</li><li>将 KeyBlob 块编程到固件 1 的 SPI NAND。</li></ol><p>示例 BD 文件如下图所示。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure10.jpg" alt="Figure 10. Example BD file for encrypted FlexSPI NAND image and KeyBlob programming"></p><h2 id="5-3-生成用于-sd-映像编程的-sb-文件"><a href="#5-3-生成用于-sd-映像编程的-sb-文件" class="headerlink" title="5.3 生成用于 SD 映像编程的 SB 文件"></a>5.3 生成用于 SD 映像编程的 SB 文件</h2><p>SD 映像始终从偏移量 0x400 开始。由 elftosb 实用程序生成的带有“_nopadding.bin”的 i.MX RT 引导映像将用于编程。</p><h3 id="5-3-1-生成用于-sd-映像编程的-sb-文件的步骤"><a href="#5-3-1-生成用于-sd-映像编程的-sb-文件的步骤" class="headerlink" title="5.3.1 生成用于 SD 映像编程的 SB 文件的步骤"></a>5.3.1 生成用于 SD 映像编程的 SB 文件的步骤</h3><p>一般来说，在 BD 文件中有 6 个步骤以将可引导映像编程到 SD card 上。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 SDCard option 块。</li><li>使用 enable 命令启用 SDCard 访问。</li><li>根据需要擦除 SDCard 内存。</li><li>将引导映像二进制编程到 SDCard。</li><li>将优化的 SD 引导参数编程到 Fuse（可选，实际项目中不需要时去掉）。</li></ol><p>下图展示了一个示例。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure11.jpg" alt="Figure 11. Example BD file for SD boot image programming"></p><p>加密 SD 引导映像和 KeyBlob 编程生成 SB 文件的步骤类似于 FlexSPI NAND。有关更多详细信息，请参见下面的示例。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The source block assign file name to identifiers</span><br><span class="hljs-section">sources</span> &#123;<br>    <span class="hljs-attribute">myBootImageFile</span> = extern (<span class="hljs-number">0</span>);<br>    <span class="hljs-attribute">dekFile</span> = extern (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment"># The section block specifies the sequence of boot commands to be written to the SB file</span><br><span class="hljs-attribute">section</span> (<span class="hljs-number">0</span>) &#123;<br><br>    <span class="hljs-comment">#1. Prepare SDCard option block</span><br>    <span class="hljs-attribute">load</span> 0xd0000000 &gt; 0x100;<br>    <span class="hljs-attribute">load</span> 0x00000000 &gt; 0x104;<br><br>    <span class="hljs-comment">#2. Configure SDCard</span><br>    <span class="hljs-attribute">enable</span> sdcard 0x100;<br><br>    <span class="hljs-comment">#3. Erase blocks as needed.</span><br>    <span class="hljs-attribute">erase</span> sdcard 0x400..0x14000;<br><br>    <span class="hljs-comment">#4. Program SDCard Image</span><br>    <span class="hljs-attribute">load</span> sdcard myBootImageFile &gt; 0x400;<br><br>    <span class="hljs-comment">#5. Generate KeyBlob and program it to SD Card</span><br>    <span class="hljs-comment"># Load DEK to RAM</span><br>    <span class="hljs-attribute">load</span> dekFile &gt; 0x10100;<br>    <span class="hljs-comment"># Construct KeyBlob Option</span><br>    <span class="hljs-comment">#---------------------------------------------------------------------------</span><br>    <span class="hljs-comment"># bit [31:28] tag, fixed to 0x0b</span><br>    <span class="hljs-comment"># bit [27:24] type, 0 - Update KeyBlob context, 1 Program Keyblob to SPI NAND</span><br>    <span class="hljs-comment"># bit [23:20] keyblob option block size, must equal to 3 if type =0,</span><br>    <span class="hljs-comment">#             reserved if type = 1</span><br>    <span class="hljs-comment"># bit [19:08] Reserved</span><br>    <span class="hljs-comment"># bit [07:04] DEK size, 0-128bit 1-192bit 2-256 bit, only applicable if type=0</span><br>    <span class="hljs-comment"># bit [03:00] Firmware Index, only applicable if type = 1</span><br>    <span class="hljs-comment"># if type = 0, next words indicate the address that holds dek</span><br>    <span class="hljs-comment">#              the 3rd word</span><br>    <span class="hljs-comment">#----------------------------------------------------------------------------</span><br>    <span class="hljs-comment"># tag = 0x0b, type=0, block size=3, DEK size=128bit</span><br>    <span class="hljs-attribute">load</span> 0xb0300000 &gt; 0x10200;<br>    <span class="hljs-comment"># dek address = 0x10100</span><br>    <span class="hljs-attribute">load</span> 0x00010100 &gt; 0x10204;<br>    <span class="hljs-comment"># keyblob offset in boot image</span><br>    <span class="hljs-comment"># Note: this is only an example bd file, the value must be replaced with actual</span><br>    <span class="hljs-comment">#       value in users project</span><br>    <span class="hljs-attribute">load</span> 0x00004000 &gt; 0x10208;<br>    <span class="hljs-attribute">enable</span> sdcard 0x10200;<br><br>    <span class="hljs-comment">#6. Program KeyBlob to firmware0 region</span><br>    <span class="hljs-attribute">load</span> 0xb1000000 &gt; 0x10300;<br>    <span class="hljs-attribute">enable</span> sdcard 0x10300;<br><br>    <span class="hljs-comment">#7. Program Efuse for optimal read performance (optional)</span><br>    <span class="hljs-comment">#load fuse 0x00000000 &gt; 0x07;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-4-生成用于-emmc-映像编程的-sb-文件"><a href="#5-4-生成用于-emmc-映像编程的-sb-文件" class="headerlink" title="5.4 生成用于 eMMC 映像编程的 SB 文件"></a>5.4 生成用于 eMMC 映像编程的 SB 文件</h2><p>eMMC 映像始终从偏移量 0x400 开始。由 elftosb 实用程序生成的带有“_nopadding.bin”的 i.MX RT 引导映像将用于编程。</p><p>eMMC 引导模式有两种：普通引导和快速引导。</p><h3 id="5-4-1-普通模式"><a href="#5-4-1-普通模式" class="headerlink" title="5.4.1 普通模式"></a>5.4.1 普通模式</h3><p>BD 文件中有 6 个步骤将可引导映像编程到 eMMC 以实现普通引导模式。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 eMMC option 块。</li><li>使用 enable 命令启用 eMMC 访问。</li><li>根据需要擦除 eMMC 内存。</li><li>将引导映像二进制编程到 eMMC。</li><li>将优化的 eMMC 引导参数编程到 Fuse（可选，实际项目中不需要的话去掉）。</li></ol><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure12.jpg" alt="Figure 12. Example BD file for eMMC boot image programming for Normal boot mode"></p><h3 id="5-4-2-快速模式"><a href="#5-4-2-快速模式" class="headerlink" title="5.4.2 快速模式"></a>5.4.2 快速模式</h3><p>BD 文件中有 9 个步骤将可引导映像编程到 eMMC 以实现快速引导模式。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 eMMC option 块并使用 enable 命令启用 eMMC 访问。</li><li>根据需要擦除 eMMC 内存。</li><li>将引导映像二进制编程到 eMMC。</li><li>将优化的 eMMC 引导参数编程到 Fuse（可选，实际项目中不需要的话去掉）。</li><li>准备第二个 eMMC option 块。</li><li>使用新的 option 块重新启用 eMMC 访问。</li><li>根据需要擦除用户数据区中的数据。</li><li>加载用户数据文件到用户数据区。</li></ol><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure13.jpg" alt="Figure 13. Example BD file for eMMC boot image programming for Fast boot mode"></p><p>加密 eMMC 引导映像和 KeyBlob 编程的 BD 文件与 SD 类似。</p><h2 id="5-5-生成用于-serial-nor-x2f-eeprom-映像编程的-sb-文件"><a href="#5-5-生成用于-serial-nor-x2f-eeprom-映像编程的-sb-文件" class="headerlink" title="5.5 生成用于 Serial NOR&#x2F;EEPROM 映像编程的 SB 文件"></a>5.5 生成用于 Serial NOR&#x2F;EEPROM 映像编程的 SB 文件</h2><p>BD 文件中有 5 个步骤将可引导映像编程到 <del>SD card</del> Serial NOR&#x2F;EEPROM。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 Serial NOR&#x2F;EEPROM option 块并使用 enable 命令启用 Serial NOR&#x2F;EEPROM 访问。</li><li>根据需要擦除 Serial NOR&#x2F;EEPROM 内存。</li><li>将引导映像二进制编程到 Serial NOR&#x2F;EEPROM 设备。</li><li>根据需要通过 Serial NOR&#x2F;EEPROM 启用恢复引导。</li></ol><p>下图展示了一个示例。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure14.jpg" alt="Figure 14. Example BD file for Serial NOR/EEPROM boot image programming"></p><p>加密 <del>SPI EEPRM&#x2F;NOR</del> Serial NOR&#x2F;EEPROM 引导映像和 KeyBlob 编程的 BD 文件与 SD 类似。</p><h2 id="5-6-生成用于-semc-nor-映像编程的-sb-文件"><a href="#5-6-生成用于-semc-nor-映像编程的-sb-文件" class="headerlink" title="5.6 生成用于 SEMC NOR 映像编程的 SB 文件"></a>5.6 生成用于 SEMC NOR 映像编程的 SB 文件</h2><p>一般来说，在 BD 文件中有 5 个步骤将可引导映像编程到 <del>SD card</del> SEMC NOR。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 SEMC NOR option 块并使用 enable 命令启用 SEMC NOR 访问。</li><li>根据需要擦除 SEMC NOR 内存。</li><li>将引导映像二进制编程到 SEMC NOR 设备。</li><li>根据需要将优化的 SEMC NOR 访问参数编程到 Fuse。</li></ol><p>下图展示了一个示例 BD 文件。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure15.jpg" alt="Figure 15. Example BD file for SEMC NOR boot image programming"></p><h2 id="5-7-生成用于-semc-nand-映像编程的-sb-文件"><a href="#5-7-生成用于-semc-nand-映像编程的-sb-文件" class="headerlink" title="5.7 生成用于 SEMC NAND 映像编程的 SB 文件"></a>5.7 生成用于 SEMC NAND 映像编程的 SB 文件</h2><p>在 BD 文件中有 5 个步骤将可引导映像编程到 <del>SD card</del> SEMC NAND。</p><ol><li>在 sources 块中提供可引导映像文件路径。</li><li>准备 SEMC NAND FCB option 块并使用 enable 命令启用 SEMC NAND 访问。</li><li>根据需要擦除 SEMC NAND 内存。</li><li>将引导映像二进制编程到 SEMC NAND 设备。</li><li>根据需要将优化的 SEMC NAND 访问参数编程到 Fuse。</li></ol><p>下图展示了一个示例。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure16.jpg" alt="Figure 16. Example BD file for SEMC NAND boot image programming"></p><h2 id="5-8-生成用于-fuse-编程的-sb-文件"><a href="#5-8-生成用于-fuse-编程的-sb-文件" class="headerlink" title="5.8 生成用于 fuse 编程的 SB 文件"></a>5.8 生成用于 fuse 编程的 SB 文件</h2><p>在某些情况下，必须首先对 fuse 进行编程，以启用所选引导设备或安全级别的特定特性。例如，要启用 eMMC 的快速引导模式，启用 HAB 关闭模式，必须先对 fuse 进行编程。</p><p>elftosb 实用程序可以支持使用内置命令 <em>load fuse</em> 对 fuse 进行编程。编程 SRK table 并启用 HAB 关闭模式的示例如下所示。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The source block assign file name to identifiers</span><br><span class="hljs-section">sources</span> &#123;<br>&#125;<br><br><span class="hljs-section">constants</span> &#123;<br>&#125;<br><br><span class="hljs-attribute">section</span> (<span class="hljs-number">0</span>) &#123;<br><br>    <span class="hljs-comment"># Program SRK table</span><br>    <span class="hljs-attribute">load</span> fuse 0xD132E7F1 &gt; 0x18;<br>    <span class="hljs-attribute">load</span> fuse 0x63CD795E &gt; 0x19;<br>    <span class="hljs-attribute">load</span> fuse 0x8FF38102 &gt; 0x1A;<br>    <span class="hljs-attribute">load</span> fuse 0x22A78E77 &gt; 0x1B;<br>    <span class="hljs-attribute">load</span> fuse 0x01019c82 &gt; 0x1C;<br>    <span class="hljs-attribute">load</span> fuse 0xFC3AC699 &gt; 0x1D;<br>    <span class="hljs-attribute">load</span> fuse 0xF2C327A3 &gt; 0x1E;<br>    <span class="hljs-attribute">load</span> fuse 0xDAC9214E &gt; 0x1F;<br><br>    <span class="hljs-comment"># Program SEC_CONFIG to enable HAB closed mode</span><br>    <span class="hljs-attribute">load</span> fuse 0x00000002 &gt; 0x06;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-编程引导映像"><a href="#6-编程引导映像" class="headerlink" title="6 编程引导映像"></a>6 编程引导映像</h1><p>仅 MfgTool 支持可引导映像编程。</p><h2 id="6-1-mfgtool"><a href="#6-1-mfgtool" class="headerlink" title="6.1 MfgTool"></a>6.1 MfgTool</h2><p>MfgTool 支持 i.MX RT BootROM 和 MCUBOOT-based Flashloader。它可以用于工厂生产环境。MfgTool 可以检测连接到 PC 的 i.MX RT BootROM 设备，并调用“blhost”对连接到 i.MX RT 设备的目标存储设备上的映像进行编程。</p><p>MfgTool 配置文件模板随本文档一起提供。它适用于大多数用例，无需任何修改。</p><h3 id="6-1-1-mfgtool-目录结构"><a href="#6-1-1-mfgtool-目录结构" class="headerlink" title="6.1.1 MfgTool 目录结构"></a>6.1.1 MfgTool 目录结构</h3><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure17.jpg" alt="Figure 17. MfgTool organization"></p><ol><li>在发行包中，mfgtools-rel 文件夹和 blhost 文件夹一起出现在 tools 文件夹中。</li><li>blhost.exe 出现在 blhost&#x2F;win 文件夹中，MfgTools 可执行文件“MfgTool2.exe”出现在 mfgtools-rel 文件夹中。</li><li>Profiles 文件夹包含其支持设备的配置文件，其中包括“OS Firmware”文件夹和 player.ini 文件。</li><li>OS Firmware 文件夹中的 ucl2.xml 文件是 MfgTool 处理的主要 .xml 文件。它包含设备的制造流程。该流程包括设备的标识参数和用于标识连接到 PC 主机的设备的 blhost 命令参数以及更新映像所需的一组 blhost 命令。可以自定义 ucl2.xml 文件以适应自定义设置或制造流程。该文件夹包含供用户参考的示例 XML 文件。下面展示了一个示例的 ucl2.xml。一般来说，它定义了支持的状态和列表。<br> <img src="/images/imx-rt1060-manufacturing-users-guide/figure18.jpg" alt="Figure 18. Example UCL2.xml settings"></li><li>“OS firmware”下的“ivt_flashloader.bin”文件是为支持映像编程而发布的 Flashloader。</li><li>“OS firmware”下的“ivt_flashloader_signed.bin”文件是用户在生产阶段为安全引导解决方案生成的可引导 Flashloader 映像文件，可按照 4.3 小节所述生成。</li><li>“OS firmware”下的“boot_image.sb”文件是用户使用 elftosb 实用程序生成的包含命令序列和可引导映像的包装文件。</li><li>“OS firmware”下的“enable_hab.sb”文件是包含命令序列的包装文件，该文件对 Fuse 进行编程以启用 HAB 关闭模式，其由用户使用 elftosb 实用程序生成。</li><li>“Device”配置文件文件夹中的 play.ini 包含制造工具应用程序的可配置参数。</li><li>cfg.ini 和 UICfg.ini 文件为工具 GUI 的外观提供可自定义的参数。工具 GUI 中的 cfg.ini 用于选择列表中的“chip”、“platform”和“name”。参考下面的例子<blockquote><p>注：从 Device&#x2F;OS Firmware 文件夹中的 ucl2.xml 中的列表中选择适当的“chip”，“name”。</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[profiles]</span><br><span class="hljs-attr">chip</span> = MXRT106X<br><br><span class="hljs-section">[platform]</span><br><span class="hljs-attr">board</span> =<br><br><span class="hljs-section">[LIST]</span><br><span class="hljs-attr">name</span> = MXRT106X-DevBoot<br></code></pre></td></tr></table></figure></li><li>UlCfg.ini 用于选择 MfgTool UI 支持的实例数。有效的实例范围是 1-4。</li><li>MfgTool.log 文本文件是调试 MfgTool UI 上报告的故障的有用工具。MfgTool 记录用于调用 blhost 的整个命令行字符串，并将 blhost 在 stdout 上输出的输出响应文本收集到 MfgTool 日志文件中。故障排除时应首先考虑日志文件。</li></ol><h3 id="6-1-2-使用-mfgtool-进行映像编程前的准备"><a href="#6-1-2-使用-mfgtool-进行映像编程前的准备" class="headerlink" title="6.1.2 使用 MfgTool 进行映像编程前的准备"></a>6.1.2 使用 MfgTool 进行映像编程前的准备</h3><p>有关详细信息，请参阅 <a href="#4-%E7%94%9F%E6%88%90-i-mx-rt-%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F">4 生成 i.MX RT 可引导映像</a> 和 <a href="#5-%E7%94%9F%E6%88%90%E7%94%A8%E4%BA%8E%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F%E7%BC%96%E7%A8%8B%E7%9A%84-sb-%E6%96%87%E4%BB%B6">5 生成用于可引导映像编程的 SB 文件</a>。</p><h2 id="6-2-连接到-i-mx-rt-平台"><a href="#6-2-连接到-i-mx-rt-平台" class="headerlink" title="6.2 连接到 i.MX RT 平台"></a>6.2 连接到 i.MX RT 平台</h2><p>将 i.MX RT 平台连接到主机以与 i.MX RT BootROM 应用程序进行交互。平台以串行下载器模式连接后，可以使用 MfgTool 将可引导映像编程到目标闪存中。如果 cfg.ini 和 UlCfg.ini 文件都配置正确，MfgTool 会识别设备并建立连接。</p><p>下图展示了 MfgTool 已经连接。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure19.jpg" alt="Figure 19. MfgTool GUI with device connected"></p><h2 id="6-3-开发过程中的程序可引导映像"><a href="#6-3-开发过程中的程序可引导映像" class="headerlink" title="6.3 开发过程中的程序可引导映像"></a>6.3 开发过程中的程序可引导映像</h2><p>在开发阶段，对于大多数用例，设备可能处于 HAB 打开模式。用户可以将 cfg.ini 文件中的“name”字段配置为 &lt;Device&gt;-DevBoot，然后使用 elftosb 实用程序准备 boot_image.sb 文件。生成“boot_image.sb”后，将其放入“&lt;Device&gt;&#x2F;OS Firmware&#x2F;”文件夹。然后将设备置于串行下载器模式并将其连接到主机 PC。打开 MfgTool2.exe 并单击“Start”以触发编程序列。编程完成后，将出现下图所示的窗口。要退出 MfgTool，请点击“Stop”，然后点击“Exit”。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure20.jpg" alt="Figure 20. Successful result for programming with MfgTool for DevBoot"></p><h2 id="6-4-用于生产的程序可引导映像"><a href="#6-4-用于生产的程序可引导映像" class="headerlink" title="6.4 用于生产的程序可引导映像"></a>6.4 用于生产的程序可引导映像</h2><p>在生产阶段，对于大多数用例，设备可能处于 HAB 关闭模式。用户可以将 cfg.ini 文件中的“name”字段配置为 &lt;Device&gt;-SecureBoot，然后使用 elftosb 实用程序准备 boot_image.sb 文件、enable_hab.sb 和 ivt_flashloader_signed.bin。全部生成后，放入“&lt;Device&gt;&#x2F;OS Firmware&#x2F;”文件夹，然后将设备置于串口下载器模式并将其连接到主机 PC。打开 MfgTool2.exe 并单击“Start”以触发编程序列。编程完成后，将看到下面的窗口。要退出 MfgTool，请点击“Stop”，然后点击“Exit”。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure21.jpg" alt="Figure 21. Successful result for programming with MfgTool for Secure Boot"></p><h1 id="7-附录"><a href="#7-附录" class="headerlink" title="7 附录"></a>7 附录</h1><h2 id="7-1-插件式引导应用程序"><a href="#7-1-插件式引导应用程序" class="headerlink" title="7.1 插件式引导应用程序"></a>7.1 插件式引导应用程序</h2><p>插件式引导应用程序通常用于启用 Boot ROM 本身不支持的引导特性，例如，</p><ul><li>从 U 盘引导</li><li>从以太网引导</li><li>DDR&#x2F;SDRAM 配置</li><li>冗余引导&#x2F;可靠引导</li></ul><p>插件式引导应用的原型是：</p><p>bool (*plugin_download)(void **start, size_t *bytes, uint32_t *ivt_offset);</p><h3 id="7-1-1-插件式引导应用程序设计原则"><a href="#7-1-1-插件式引导应用程序设计原则" class="headerlink" title="7.1.1 插件式引导应用程序设计原则"></a>7.1.1 插件式引导应用程序设计原则</h3><p>Boot ROM 需要在插件式引导映像和插件式引导应用程序加载的普通引导映像之间跳转。为避免对 ROM 引导流程产生任何影响，以下是插件式引导应用程序设计的一些推荐原则。</p><ol><li>插件式引导应用程序不能使用当前保留给 ROM 使用的内存</li><li>插件式引导应用程序应使用最小的栈空间以避免插件式引导应用程序导致栈溢出的可能性</li><li>如果 WDOG 使能位在 Fuse 块中启用，那么插件式引导应用程序必须考虑 Watchdog 服务</li></ol><h3 id="7-1-2-插件式引导应用程序的引导流程"><a href="#7-1-2-插件式引导应用程序的引导流程" class="headerlink" title="7.1.2 插件式引导应用程序的引导流程"></a>7.1.2 插件式引导应用程序的引导流程</h3><p>插件式引导应用程序的引导流程如下：</p><ol><li>Boot ROM 加载 XIP 插件式引导映像，进行验证并执行，然后跳转到插件式引导应用程序</li><li>插件式引导应用程序从地址 0x60008000 中加载已签名的 Non-XIP 映像并跳转回 Boot ROM</li><li>Boot ROM 根据插件式引导应用程序输出的参数进行验证&#x2F;解密，验证成功后跳转到 non-XIP 引导映像</li></ol><h3 id="7-1-3-用于在-flexspi-nor-上引导-non-xip-引导的示例插件式引导应用程序"><a href="#7-1-3-用于在-flexspi-nor-上引导-non-xip-引导的示例插件式引导应用程序" class="headerlink" title="7.1.3 用于在 FlexSPI NOR 上引导 non-XIP 引导的示例插件式引导应用程序"></a>7.1.3 用于在 FlexSPI NOR 上引导 non-XIP 引导的示例插件式引导应用程序</h3><p>某些 i.MX RT Boot ROM 设备本身不支持 Non-XIP 引导用例。在这种情况下，可以创建一个简单的插件式引导映像来为这些引导设备启用 non-XIP 引导用法。</p><p>插件式引导的基本流程如下：</p><p>以下是 RT10xx FlexSPI NOR 引导的插件式引导应用程序示例代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOT_IMAGE_LOAD_BASE 0x60008000</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    kTag_HAB_IVT = <span class="hljs-number">0xd1</span>,<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">hab_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> tag;<br>    <span class="hljs-type">uint8_t</span> len[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">uint8_t</span> version;<br>&#125; <span class="hljs-type">hab_hdr_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">hab_ivt</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">hab_hdr_t</span> hdr;<br>    <span class="hljs-type">uint32_t</span> entry;<br>    <span class="hljs-type">uint32_t</span> reserved1;<br>    <span class="hljs-type">uint32_t</span> dcd;<br>    <span class="hljs-type">uint32_t</span> boot_data;<br>    <span class="hljs-type">uint32_t</span> self;<br>    <span class="hljs-type">uint32_t</span> csf;<br>    <span class="hljs-type">uint32_t</span> reserved2;<br>&#125; <span class="hljs-type">hab_ivt_t</span>;<br><br><span class="hljs-comment">//!@brief Boot data structure</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">boot_data</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> start;<br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-type">uint32_t</span> plugin;<br>    <span class="hljs-type">uint32_t</span> reserved;<br>&#125; <span class="hljs-type">boot_data_t</span>;<br><br><span class="hljs-comment">//!@brief Boot Image header, including both IVT and BOOT_DATA</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">boot_image_hdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">hab_ivt_t</span> ivt;<br>    <span class="hljs-type">boot_data_t</span> boot_data;<br>&#125; <span class="hljs-type">boot_image_hdr_t</span>;<br><br><span class="hljs-comment">/*!@brief Plugin Download function</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is used to copy non-xip boot image from Flash to RAM</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">plugin_download</span><span class="hljs-params">(<span class="hljs-type">void</span> **start, <span class="hljs-type">size_t</span> *bytes, <span class="hljs-type">uint32_t</span> *ivt_offset)</span><br>&#123;<br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">boot_image_hdr_t</span> *boot_hdr;<br><br>    <span class="hljs-comment">//Search IVT</span><br>    <span class="hljs-type">uint32_t</span> ivt_offset_list[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0x400</span>, <span class="hljs-number">0x1000</span>&#125;;<br><br>    <span class="hljs-type">uint32_t</span> search_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (search_index &lt; <span class="hljs-keyword">sizeof</span>(ivt_offset_list) / <span class="hljs-keyword">sizeof</span>(ivt_offset_list[<span class="hljs-number">0</span>]))<br>    &#123;<br>        boot_hdr = (<span class="hljs-type">const</span> <span class="hljs-type">boot_image_hdr_t</span> *)(ivt_offset_list[search_index] + <br>                                              BOOT_IMAGE_LOAD_BASE);<br>        <span class="hljs-keyword">if</span> (boot_hdr-&gt;ivt.hdr.tag != kTag_HAB_IVT)<br>        &#123;<br>            search_index++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        *start = (<span class="hljs-type">void</span> *)boot_hdr-&gt;boot_data.start;<br>        *bytes = boot_hdr-&gt;boot_data.length;<br>        *ivt_offset = boot_hdr-&gt;ivt.self - boot_hdr-&gt;boot_data.start;<br><br>        <span class="hljs-type">uint32_t</span> *dst = (<span class="hljs-type">uint32_t</span> *)boot_hdr-&gt;boot_data.start;<br>        <span class="hljs-type">uint32_t</span> *src = (<span class="hljs-type">uint32_t</span> *)((<span class="hljs-type">uint32_t</span>)boot_hdr - *ivt_offset);<br>        <span class="hljs-type">size_t</span> remaining_length = ((*byte + <span class="hljs-number">3</span>) &amp; ~<span class="hljs-number">0x03</span>) / <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">while</span> (remaining_length--)<br>        &#123;<br>            *dst++ = *src++;<br>        &#125;<br><br>        result = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-1-4-插件式引导应用程序加载的映像"><a href="#7-1-4-插件式引导应用程序加载的映像" class="headerlink" title="7.1.4 插件式引导应用程序加载的映像"></a>7.1.4 插件式引导应用程序加载的映像</h3><p>插件式引导应用程序加载的映像可以是 XIP 映像或 non-XIP 映像。有关详细信息，请参阅 <a href="#4-%E7%94%9F%E6%88%90-i-mx-rt-%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F">4 生成 i.MX RT 可引导映像</a>。</p><h2 id="7-2-rt1060-evk-的制造流程示例"><a href="#7-2-rt1060-evk-的制造流程示例" class="headerlink" title="7.2 RT1060-EVK 的制造流程示例"></a>7.2 RT1060-EVK 的制造流程示例</h2><h3 id="7-2-1-开发阶段中的制造过程"><a href="#7-2-1-开发阶段中的制造过程" class="headerlink" title="7.2.1 开发阶段中的制造过程"></a>7.2.1 开发阶段中的制造过程</h3><p>在开发阶段，映像通常是未签名的，用于功能测试。</p><h4 id="7-2-1-1-制造流程的模板选项"><a href="#7-2-1-1-制造流程的模板选项" class="headerlink" title="7.2.1.1 制造流程的模板选项"></a>7.2.1.1 制造流程的模板选项</h4><p>为了简化制造流程的复杂性，ucl2.xml 中提供了几个模板。</p><p>下面的代码块是用于将 SDK XIP 项目二进制文件编程到 RT1060-EVK 板中的示例。要启用 XiP 用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashXiP”</li><li>编译 SDK 项目</li><li>为项目生成二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashXiP&quot;</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>    Configure QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x60000000 0x100000&quot;</span> &gt;</span> Erase 1MBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60000000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于将 SDK XIP 项目二进制文件编程到使用其他 FLASH 设备的 RT1060-EVK 板中的示例。对于实际焊接的 FLASH 设备，用户可能需要修改 <strong>0xc0000007</strong> 配置选项。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em> 中的“External memory support”。</p><p>要启用该选项，用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashXiP_NoConfigBlock”</li><li>编译 SDK 项目</li><li>为项目生成二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashXiP_NoConfigBlock&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span><br>        Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>        Configure Serial FLASH <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x60000000 0x10000&quot;</span> &gt;</span> Erase 64KBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x3000 4 0xf000000f&quot;</span>&gt;</span><br>        Prepare Magic number for config block programming <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x3000&quot;</span>&gt;</span><br>        Write auto-generated config block to QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60001000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于在没有 FCB 和引导数据信息的情况下对 SDK XIP 项目二进制文件进行编程的示例。对于实际焊接的 FLASH 设备，用户可能需要修改配置选项中的 <strong>0xc0000007</strong>。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em> 中的“External memory support”。</p><p>要启用该选项，用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashXiP_NoConfigBlockBootData”</li><li>编译 SDK 项目</li><li>生成项目的二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><blockquote><p>注：</p><ol><li>对于本示例，应用程序起始地址必须为 0x60002000。</li><li>ivt_bootdata_0x6000_2000 中的默认映像大小配置为 4 MB。它适合大多数应用程序要求。用户可以修改此文件中的偏移量 0x24-0x27 来改变映像大小以满足实际需要。</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashXiP_NoConfigBlockBootData&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>        Configure Serial FLASH <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x60000000 0x100000&quot;</span> &gt;</span> Erase 1MBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x3000 4 0xf000000f&quot;</span>&gt;</span><br>        Prepare Magic nubmer for config block programming <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x3000&quot;</span>&gt;</span><br>        Write auto-generated config block to QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60001000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">ivt_bootdata.bin</span>\&quot;&quot; &gt;</span><br>        Program IVT and Boot data. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60002000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于对存储在 FlexSPI NOR 上的 non-XIP ITCM 映像进行编程的示例。对于实际焊接的 FLASH 设备，用户可能需要修改 <strong>0xc0000007</strong> 配置选项。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em> 中的“External memory support”。</p><p>要启用该选项，用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashXiP_ITCM_0x0000_1400”</li><li>编译 SDK 项目</li><li>生成项目的二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><blockquote><p>注：</p><ol><li>此选项的应用程序起始地址必须为 0x1400。实际引导映像从地址 0x1000 开始，IVT 从偏移量 0x100 开始，应用程序从偏移量 0x1300 开始。</li><li>ivt_bootdata_0x0000_1400 中的默认映像大小配置为 127 KB。这是因为它不能超过默认的 ITCM 大小（128 KB）。</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashNonXiP_ITCM_0x0000_1400&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>        Configure Serial FLASH <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x60000000 0x80000&quot;</span> &gt;</span> Erase 512KBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x3000 4 0xf000000f&quot;</span>&gt;</span><br>        Prepare Magic nubmer for config block programming <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x3000&quot;</span>&gt;</span><br>        Write auto-generated config block to QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60001000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">ivt_bootdata_0x0000_1400.bin</span>\&quot;&quot; &gt;</span><br>        Program IVT, Boot data. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60001300</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于对存储在 FlexSPI NOR 上的 non-XIP DTCM 映像进行编程的示例。对于实际焊接的 FLASH 设备，用户可能需要修改 <strong>0xc0000007</strong> 配置选项。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em> 中的“External memory support”。</p><p>要启用该选项，用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashXiP_DTCM_0x2000_2000”</li><li>编译 SDK 项目</li><li>生成项目的二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><blockquote><p>注：</p><ol><li>此选项的应用程序起始地址必须为 0x20002000。实际引导映像从地址 0x20000000 开始，IVT 从偏移量 0x1000 开始，应用程序从偏移量 0x2000 开始。</li><li>ivt_bootdata_0x2000_2000 中的默认映像大小配置为 128 KB。这是因为它不能超过默认的 DTCM 大小（128 KB）。</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashNonXiP_DTCM_0x2000_2000&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>        Configure Serial FLASH <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x60000000 0x80000&quot;</span> &gt;</span> Erase 512KBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x3000 4 0xf000000f&quot;</span>&gt;</span><br>        Prepare Magic nubmer for config block programming <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x3000&quot;</span>&gt;</span><br>        Write auto-generated config block to QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60001000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">ivt_bootdata_0x2000_2000.bin</span>\&quot;&quot; &gt;</span><br>        Program IVT, Boot data. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x60002000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于对存储在 FlexSPI NOR 上的 non-XIP OCRAM 映像进行编程的示例。对于实际焊接的 FLASH 设备，用户可能需要修改 <strong>0xc0000007</strong> 配置选项。有关详细信息，请参阅 <em>MCU Flashloader Reference Manual</em> 中的“External memory support”。</p><p>要启用该选项，用户需要：</p><ol><li>将 cfg.ini 中的“name”项更改为“name &#x3D; MXRT106x-DevBootSerialFlashNonXiP_OCRAM_0x2020_a000”</li><li>编译 SDK 项目</li><li>生成项目的二进制文件</li><li>将二进制文件重命名为 boot_image.bin</li><li>将其复制到与 ucl2.xml 相同的文件夹中</li></ol><blockquote><p>注：</p><ol><li>此选项的应用程序起始地址必须为 0x2020a000。实际引导映像从地址 0x20208000 开始，IVT 从偏移量 0x1000 开始，应用程序从偏移量 0x2000 开始。</li><li>ivt_bootdata_0x2020_a000 中的默认映像大小配置为 736 KB。这是因为它不能超过默认的 OCRAM 大小（768 KB - 为 ROM 使用保留的 32 KB RAM 大小）。</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBootSerialFlashNonXiP_OCRAM_0x2020_a000&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x2000 4 0xc0000007&quot;</span>&gt;</span><br>        Prepare Flash Configuration option <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x2000&quot;</span>&gt;</span><br>        Configure Serial FLASH <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- This erase size need to be updated based on the actual boot image size--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;30000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;flash-erase-region</span></span><br><span class="hljs-string"><span class="hljs-tag">     0x70000000 0x80000&quot;</span> &gt;</span> Erase 512KBytes <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;fill-memory 0x3000 4 0xf000000f&quot;</span>&gt;</span><br>        Prepare Magic nubmer for config block programming <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;configure-memory 0x9 0x3000&quot;</span>&gt;</span><br>        Write auto-generated config block to QuadSPI NOR Flash <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x70001000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">ivt_bootdata_0x2020_a000.bin</span>\&quot;&quot; &gt;</span><br>        Program IVT, Boot data. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;write-memory 0x70002000</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106x</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.bin</span>\&quot;&quot; &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是用于通用目的的示例。需要创建 SB 格式的引导映像 boot_image.sb 并将其复制到与 ucl2.mxl 相同的文件夹中。创建 SB 格式引导映像的详细信息可以在第 4 章和第 5 章中找到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-DevBoot&quot;</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Manufacturing with Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader.bin&quot;</span>&gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span> = <span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Program boot image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> &gt;</span> Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;receive-sb-file</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106X</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.sb</span>\&quot;&quot; &gt;</span> Program Boot image <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面的代码块是在生产阶段用于通用目的的示例。需要创建 SB 格式的引导映像 boot_image.sb 并将其复制到与 ucl2.mxl 相同的文件夹中。创建 SB 格式引导映像的详细信息可以在第 4 章和第 5 章中找到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LIST</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MXRT106x-SecureBoot&quot;</span> <span class="hljs-attr">desc</span>=<span class="hljs-string">&quot;Boot Signed Flashloader&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Stage 1, load and execute Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;boot&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&quot;ivt_flashloader_signed.bin&quot;</span> &gt;</span><br>        Loading Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;BootStrap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;jump&quot;</span> <span class="hljs-attr">onError</span>=<span class="hljs-string">&quot;ignore&quot;</span>&gt;</span> Jumping to Flashloader. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 2, Enable HAB closed mode using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Open&quot;</span> &gt;</span><br>        Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span> <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;receive-sb-file \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106X</span>\\<span class="hljs-attr">OS</span></span><br><span class="hljs-tag">     <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">enable_hab.sb</span>\&quot;&quot; <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Open&quot;</span> &gt;</span> Program Boot Image. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Open&quot;</span>&gt;</span> Reset. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Reset device to enable HAB Close Mode--&gt;</span><br><br><span class="hljs-comment">&lt;!-- Stage 3, Program signed image into external memory using Flashloader --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;get-property 1&quot;</span> <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Close&quot;</span>&gt;</span><br>        Get Property 1. <span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span> <span class="hljs-comment">&lt;!--Used to test if flashloader runs successfully--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;15000&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;receive-sb-file</span></span><br><span class="hljs-string"><span class="hljs-tag">     \&quot;</span><span class="hljs-attr">Profiles</span>\\<span class="hljs-attr">MXRT106X</span>\\<span class="hljs-attr">OS</span> <span class="hljs-attr">Firmware</span>\\<span class="hljs-attr">boot_image.sb</span>\&quot;&quot; <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Close&quot;</span> &gt;</span><br>        Program Boot Image.<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">CMD</span> <span class="hljs-attr">state</span>=<span class="hljs-string">&quot;Blhost&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;blhost&quot;</span> <span class="hljs-attr">body</span>=<span class="hljs-string">&quot;Update Completed!&quot;</span> <span class="hljs-attr">ifhab</span>=<span class="hljs-string">&quot;Close&quot;</span>&gt;</span>Done<span class="hljs-tag">&lt;/<span class="hljs-name">CMD</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LIST</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-2-1-2-创建-i-mx-rt-可引导映像"><a href="#7-2-1-2-创建-i-mx-rt-可引导映像" class="headerlink" title="7.2.1.2 创建 i.MX RT 可引导映像"></a>7.2.1.2 创建 i.MX RT 可引导映像</h4><h5 id="7-2-1-2-1-使用-ksdk-xip-示例创建映像"><a href="#7-2-1-2-1-使用-ksdk-xip-示例创建映像" class="headerlink" title="7.2.1.2.1 使用 KSDK XIP 示例创建映像"></a>7.2.1.2.1 使用 KSDK XIP 示例创建映像</h5><p>用户可以通过构建 KSDK XIP 项目来创建未签名的可引导映像，并将输出转换为二进制文件。需要将二进制文件重命名为 boot_image.bin 并将其复制到与 ucl2.xml 相同的文件夹中。然后用户可以更新 cfg.ini 文件以启用上一节中描述的制造流程选项。</p><h5 id="7-2-1-2-2-使用-elftosb-实用程序创建映像"><a href="#7-2-1-2-2-使用-elftosb-实用程序创建映像" class="headerlink" title="7.2.1.2.2 使用 elftosb 实用程序创建映像"></a>7.2.1.2.2 使用 elftosb 实用程序创建映像</h5><p>要为特定内存创建可引导映像，用户需要知道 i.MX RT106x SoC 的内存映射。生成可引导映像的详细信息可在第 4 章中找到。以下是使用 elftosb 实用程序为 FlexSPI NOR 创建 i.MX RT 可引导映像的步骤。</p><ol><li>创建用于生成引导映像的 BD 文件。BD 文件内容如下所示。它也可以在“&lt;sdk_package&gt;&#x2F;middleware&#x2F;mcu-boot&#x2F;bin&#x2F;Tools&#x2F;bd_file&#x2F;imxrt10xx”的发行包中找到 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">options &#123;<br>    flags <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x00<span class="hljs-comment">;</span><br>    startAddress <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x60000000<span class="hljs-comment">;</span><br>    ivtOffset <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x1000<span class="hljs-comment">;</span><br>    initialLoadSize <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x2000<span class="hljs-comment">;</span><br>&#125;<br><br>sources &#123;<br>    elfFile <span class="hljs-operator">=</span> extern(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br><br>section (<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用 elftosb 实用程序创建映像。<br>以下是示例命令：<br><br> <img src="/images/imx-rt1060-manufacturing-users-guide/figure22.jpg" alt="Figure 22. Example command to generate FlexSPI NOR boot image"><ul><li>ivt_flexspi_nor_xip.bin</li><li>ivt_flexspi_nor_xip_nopadding.bin</li></ul></li></ol><p>ivt_flexspi_nor_xip_nopadding.bin 将用于生成 SB 文件，以用于后续小节的 QSPI FLASH 编程。</p><h5 id="7-2-1-2-3-创建用于-qspi-flash-编程的-sb-文件"><a href="#7-2-1-2-3-创建用于-qspi-flash-编程的-sb-文件" class="headerlink" title="7.2.1.2.3 创建用于 QSPI FLASH 编程的 SB 文件"></a>7.2.1.2.3 创建用于 QSPI FLASH 编程的 SB 文件</h5><p>这是一个为 RT1060-EVK 板的 QSPI FLASH 编程而创建的 SB 文件示例。第 5 章提供了为可引导映像编程生成 SB 文件的详细信息。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># The source block assign file name to identifiers</span><br>sources &#123;<br>    myBinFile = <span class="hljs-keyword">extern </span>(<span class="hljs-number">0</span>);<br>&#125;<br><br>constants &#123;<br>    kAbsAddr_Start= <span class="hljs-number">0x60000000</span>;<br>    kAbsAddr_Ivt = <span class="hljs-number">0x60001000</span>;<br>    kAbsAddr_App = <span class="hljs-number">0x60002000</span>;<br>&#125;<br><br><span class="hljs-comment"># The section block specifies the sequence of boot commands to</span><br><span class="hljs-comment"># be written to the SB file</span><br>section (<span class="hljs-number">0</span>) &#123;<br><br>    <span class="hljs-comment">#1. Prepare Flash option</span><br>    <span class="hljs-comment"># 0xc0000007 is the tag for Serial NOR parameter selection</span><br>    <span class="hljs-comment"># bit [31:28] Tag fixed to 0x0C</span><br>    <span class="hljs-comment"># bit [27:24] Option size fixed to 0</span><br>    <span class="hljs-comment"># bit [23:20] Flash type option</span><br>    <span class="hljs-comment">#             0 - QuadSPI SDR NOR</span><br>    <span class="hljs-comment">#             1 - QUadSPI DDR NOR</span><br>    <span class="hljs-comment"># bit [19:16] Query pads (Pads used for query Flash Parameters)</span><br>    <span class="hljs-comment">#             0 - 1</span><br>    <span class="hljs-comment"># bit [15:12] CMD pads (Pads used for query Flash Parameters)</span><br>    <span class="hljs-comment">#             0 - 1</span><br>    <span class="hljs-comment"># bit [11: 08] Quad Mode Entry Setting</span><br>    <span class="hljs-comment">#             0 - Not Configured, apply to devices:</span><br>    <span class="hljs-comment">#                 - With Quad Mode enabled by default or</span><br>    <span class="hljs-comment">#                 - Compliant with JESD216A/B or later revision</span><br>    <span class="hljs-comment">#             1 - Set bit 6 in Status Register 1</span><br>    <span class="hljs-comment">#             2 - Set bit 1 in Status Register 2</span><br>    <span class="hljs-comment">#             3 - Set bit 7 in Status Register 2</span><br>    <span class="hljs-comment">#             4 - Set bit 1 in Status Register 2 by 0x31 command</span><br>    <span class="hljs-comment"># bit [07: 04] Misc. control field</span><br>    <span class="hljs-comment">#             3 - Data Order swapped, used for Macronix OctaFLASH devcies only</span><br>    <span class="hljs-comment">#             (except MX25UM51345G)</span><br>    <span class="hljs-comment">#             4 - Second QSPI NOR Pinmux</span><br>    <span class="hljs-comment"># bit [03: 00] Flash Frequency, device specific</span><br>    load <span class="hljs-number">0xc0000007</span> &gt; <span class="hljs-number">0x2000</span>;<br>    <span class="hljs-comment"># Configure QSPI NOR FLASH using option a address 0x2000</span><br>    enable flexspinor <span class="hljs-number">0x2000</span>;<br><br>    <span class="hljs-comment">#2 Erase flash as needed.</span><br>    <span class="hljs-comment">#(Here only 64KBytes are erased, need to be adjusted to the actual</span><br>    <span class="hljs-comment">#size of users&#x27; application)</span><br>    erase <span class="hljs-number">0x60000000</span>..<span class="hljs-number">0x60010000</span>;<br><br>    <span class="hljs-comment">#3. Program config block</span><br>    <span class="hljs-comment"># 0xf000000f is the tag to notify Flashloader to program</span><br>    <span class="hljs-comment"># FlexSPI NOR config block to the start of device</span><br>    load <span class="hljs-number">0xf000000f</span> &gt; <span class="hljs-number">0x3000</span>;<br>    <span class="hljs-comment"># Notify Flashloader to response the option at address 0x3000</span><br>    enable flexspinor <span class="hljs-number">0x3000</span>;<br><br>    <span class="hljs-comment">#4. Program image</span><br>    load myBinFile &gt; kAbsAddr_Ivt;<br>&#125;<br></code></pre></td></tr></table></figure><p>BD 文件准备好之后，接下来就是生成 boot_image.sb 文件以供 MfgTool 使用。这是示例命令：</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure23.jpg" alt="Figure 23. Example command to generate SB file for FlexSPI NOR programming"></p><p>使用上述命令后，在 elftosb 实用程序文件夹中生成了 boot_image.sb。</p><h3 id="7-2-2-使用-mfgtool-编程未签名映像到-flash"><a href="#7-2-2-使用-mfgtool-编程未签名映像到-flash" class="headerlink" title="7.2.2 使用 MfgTool 编程未签名映像到 Flash"></a>7.2.2 使用 MfgTool 编程未签名映像到 Flash</h3><p>使用以下步骤将引导映像编程到闪存设备中</p><ol><li>将 boot_image.sb 文件复制到“&lt;mfgtool_root_dir&gt;&#x2F;Profiles&#x2F;MXRT106X&#x2F;OS Firmware”文件夹。</li><li>将“[List]”下的“name”改为&lt;mfgtool_root_dir&gt;文件夹下 cfg.ini 文件中的选中选项，例如“name &#x3D; MXRT106x-DevBootSerialFlashXiP”。</li><li>通过将 SW7 设置为“1-OFF、2-OFF、3-OFF、4-ON”，将 RT1060-EVK 板置于串行下载器模式。</li><li>给 RT1060-EVK 板加电，将 USB 线插入 J9。</li><li>打开 MfgTool，它会显示为如 Figure 19 所示的检测到的设备。</li><li>点击“Start”，MfgTool 将进行制造过程。完成后，将显示成功状态，如 Figure 16 所示。单击“Stop”并关闭 MfgTool。</li><li>将 RT1060-EVK 板置于内部引导模式并通过将 SW7 设置为“1-OFF、2-OFF、3-ON、4-OFF”来选择 QSPI FLASH 作为引导设备。然后重置设备以开始运行应用程序。</li></ol><h3 id="7-2-3-生产阶段的制造过程"><a href="#7-2-3-生产阶段的制造过程" class="headerlink" title="7.2.3 生产阶段的制造过程"></a>7.2.3 生产阶段的制造过程</h3><p>在生产阶段，映像需要签名并且可能需要加密。在这种情况下，设备必须配置为 HAB 关闭模式。</p><p>假设 PKI 树已准备好供 cst 使用，请将“ca”、“crts”和“keys”文件夹以及 cst 可执行文件复制到包含 elftosb 实用程序可执行文件的文件夹中，如下所示：</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure24.jpg" alt="Figure 24. Copy required key and certificates for signed image generation"></p><h4 id="7-2-3-1-生成签名的-i-mx-rt-可引导映像"><a href="#7-2-3-1-生成签名的-i-mx-rt-可引导映像" class="headerlink" title="7.2.3.1 生成签名的 i.MX RT 可引导映像"></a>7.2.3.1 生成签名的 i.MX RT 可引导映像</h4><p>要为特定内存生成可引导映像，用户需要 i.MX RT 设备 SoC 的内存映射。<a href="#4-%E7%94%9F%E6%88%90-i-mx-rt-%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F">4 生成 i.MX RT 可引导映像</a> 提供了生成可引导映像的详细信息。以下是使用 elftosb 实用程序生成签名的 i.MX RT 可引导映像的步骤。</p><ol><li>生成用于生成引导映像的 BD 文件。BD 文件内容如下图所示。它也可以在文件夹中的发行包中找到。 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs awk">options &#123;<br>    flags = <span class="hljs-number">0</span>x08;<br>    startAddress = <span class="hljs-number">0</span>x60000000;<br>    ivtOffset = <span class="hljs-number">0</span>x1000;<br>    initialLoadSize = <span class="hljs-number">0</span>x2000;<br>    <span class="hljs-regexp">//</span>DCDFilePath = <span class="hljs-string">&quot;dcd.bin&quot;</span>;<br>    <span class="hljs-comment"># Note: This is required if the cst and elftsb are not in the same folder</span><br>    <span class="hljs-regexp">//</span>cstFolderPath = <span class="hljs-string">&quot;path/CSTFolder&quot;</span>;<br>    <span class="hljs-comment"># Note: This is required if the default entrypoint is not the Reset_Handler</span><br>    <span class="hljs-comment"># Please set the entryPointAddress to base address of Vector table</span><br>    <span class="hljs-regexp">//</span>entryPointAddress = <span class="hljs-number">0</span>x60002000;<br>&#125;<br><br>sources &#123;<br>    elfFile = extern(<span class="hljs-number">0</span>);<br>&#125;<br><br>constants &#123;<br>    SEC_CSF_HEADER = <span class="hljs-number">20</span>;<br>    SEC_CSF_INSTALL_SRK = <span class="hljs-number">21</span>;<br>    SEC_CSF_INSTALL_CSFK = <span class="hljs-number">22</span>;<br>    SEC_CSF_INSTALL_NOCAK = <span class="hljs-number">23</span>;<br>    SEC_CSF_AUTHENTICATE_CSF = <span class="hljs-number">24</span>;<br>    SEC_CSF_INSTALL_KEY = <span class="hljs-number">25</span>;<br>    SEC_CSF_AUTHENTICATE_DATA = <span class="hljs-number">26</span>;<br>    SEC_CSF_INSTALL_SECRET_KEY = <span class="hljs-number">27</span>;<br>    SEC_CSF_DECRYPT_DATA = <span class="hljs-number">28</span>;<br>    SEC_NOP = <span class="hljs-number">29</span>;<br>    SEC_SET_MID = <span class="hljs-number">30</span>;<br>    SEC_SET_ENGINE = <span class="hljs-number">31</span>;<br>    SEC_INIT = <span class="hljs-number">32</span>;<br>    SEC_UNLOCK = <span class="hljs-number">33</span>;<br>&#125;<br><br>section (SEC_CSF_HEADER;<br>    Header_Version=<span class="hljs-string">&quot;4.2&quot;</span>,<br>    Header_HashAlgorithm=<span class="hljs-string">&quot;sha256&quot;</span>,<br>    Header_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    Header_EngineConfiguration=<span class="hljs-number">0</span>,<br>    Header_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span>,<br>    Header_SignatureFormat=<span class="hljs-string">&quot;CMS&quot;</span>)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_SRK;<br>    InstallSRK_Table=<span class="hljs-string">&quot;keys/SRK_1_2_3_4_table.bin&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallSRK_SourceIndex=<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_CSFK;<br>    InstallCSFK_File=<span class="hljs-string">&quot;crts/CSF1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid file path&quot;</span><br>    InstallCSFK_CertificateFormat=<span class="hljs-string">&quot;x509&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;x509&quot;</span><br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_CSF)<br>&#123;<br>&#125;<br><br>section (SEC_CSF_INSTALL_KEY;<br>    InstallKey_File=<span class="hljs-string">&quot;crts/IMG1_1_sha256_2048_65537_v3_usr_crt.pem&quot;</span>,<br>    InstallKey_VerificationIndex=<span class="hljs-number">0</span>, <span class="hljs-regexp">//</span> Accepts integer or string<br>    InstallKey_TargetIndex=<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> Accepts integer or string<br>&#123;<br>&#125;<br><br>section (SEC_CSF_AUTHENTICATE_DATA;<br>    AuthenticateData_VerificationIndex=<span class="hljs-number">2</span>,<br>    AuthenticateData_Engine=<span class="hljs-string">&quot;DCP&quot;</span>,<br>    AuthenticateData_EngineConfiguration=<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>section (SEC_SET_ENGINE;<br>    SetEngine_HashAlgorithm = <span class="hljs-string">&quot;sha256&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;sha1&quot;</span>, <span class="hljs-string">&quot;Sha256&quot;</span>, <span class="hljs-string">&quot;sha512&quot;</span><br>    SetEngine_Engine = <span class="hljs-string">&quot;DCP&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;ANY&quot;</span>, <span class="hljs-string">&quot;SAHARA&quot;</span>, <span class="hljs-string">&quot;RTIC&quot;</span>, <span class="hljs-string">&quot;DCP&quot;</span>, <span class="hljs-string">&quot;CAAM&quot;</span> and <span class="hljs-string">&quot;SW&quot;</span><br>    SetEngine_EngineConfiguration = <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;valid engine configuration values&quot;</span><br>&#123;<br>&#125;<br><br>section (SEC_UNLOCK;<br>    Unlock_Engine = <span class="hljs-string">&quot;SNVS, OCOTP&quot;</span>, <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;SRTC&quot;</span>, <span class="hljs-string">&quot;CAAM&quot;</span>, SNVS and OCOTP<br>    Unlock_features = <span class="hljs-string">&quot;ZMK WRITE, SRK REVOKE&quot;</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用 elftosb 实用程序生成 i.MX RT 可引导映像<br>以下是示例命令：<br><br> <img src="/images/imx-rt1060-manufacturing-users-guide/figure25.jpg" alt="Figure 25. Example command to generate signed boot image"><br> 在上述命令后，会生成两个可引导映像：<ul><li>ivt_flexspi_nor_xip_signed.bin</li><li>ivt_flexspi_nor_xip_signed_nopadding.bin</li></ul></li></ol><p>ivt_flexspi_nor_xip_signed_nopadding.bin 将用于生成 SB 文件以在后续小节中进行 HyperFlash 编程。</p><h4 id="7-2-3-2-创建用于-fuse-编程的-sb-文件"><a href="#7-2-3-2-创建用于-fuse-编程的-sb-文件" class="headerlink" title="7.2.3.2 创建用于 Fuse 编程的 SB 文件"></a>7.2.3.2 创建用于 Fuse 编程的 SB 文件</h4><p>在 keys 文件夹中，有一个名为“SRK_1_2_3_4_fuse.bin”的文件。这是在引导期间用于 SRK 验证的 HASH 表。必须将其编程到 fuse 以启用安全引导模式。</p><p>下面是一个示例文件：</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure26.jpg" alt="Figure 26. Example SRK_1_2_3_4_fuse.bin file"></p><p>下面是一个示例 BD 文件，它展示了对 fuse 进行编程的过程。fuse 字段是一个 32 位长的字数据。它将由 Flashloader 以 little-endian 模式编程到 fuse 中。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># The source block assign file name to identifiers</span><br><span class="hljs-section">sources</span> &#123;<br>&#125;<br><br><span class="hljs-section">constants</span> &#123;<br>&#125;<br><br><span class="hljs-comment"># The section block specifies the sequence of boot commands to be written to the SB file</span><br><span class="hljs-comment"># Note: this is just a template, please update it to actual values in users&#x27; project</span><br><span class="hljs-attribute">section</span> (<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment"># Program SRK table</span><br>    <span class="hljs-attribute">load</span> fuse 0xD132E7F1 &gt; 0x18;<br>    <span class="hljs-attribute">load</span> fuse 0x63CD795E &gt; 0x19;<br>    <span class="hljs-attribute">load</span> fuse 0x8FF38102 &gt; 0x1A;<br>    <span class="hljs-attribute">load</span> fuse 0x22A78E77 &gt; 0x1B;<br>    <span class="hljs-attribute">load</span> fuse 0x01019c82 &gt; 0x1C;<br>    <span class="hljs-attribute">load</span> fuse 0xFC3AC699 &gt; 0x1D;<br>    <span class="hljs-attribute">load</span> fuse 0xF2C327A3 &gt; 0x1E;<br>    <span class="hljs-attribute">load</span> fuse 0xDAC9214E &gt; 0x1F;<br><br>    <span class="hljs-comment"># Program SEC_CONFIG to enable HAB closed mode</span><br>    <span class="hljs-attribute">load</span> fuse 0x00000002 &gt; 0x06;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 BD 文件中的最后一条命令用于通过将 fuse 中的 SEC_CONFIG [1] 位设置为 1 来启用 HAB 关闭模式。</p><p>BD 文件准备好后，下一步是创建用于 Fuse 编程的 SB 文件以启用 HAB 关闭模式。</p><p>示例命令如下所示：</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure27.jpg" alt="Figure 27. Example command to generate SB file for Fuse programming"></p><p>执行上图中的“enable_hab.bd -o enable_hab.sb”命令后，会生成一个名为“enable_hab.sb”的文件。MfgTool 的安全引导解决方案中需要它。</p><h4 id="7-2-3-3-创建用于-qspi-flash-映像加密和编程的-sb-文件"><a href="#7-2-3-3-创建用于-qspi-flash-映像加密和编程的-sb-文件" class="headerlink" title="7.2.3.3 创建用于 QSPI Flash 映像加密和编程的 SB 文件"></a>7.2.3.3 创建用于 QSPI Flash 映像加密和编程的 SB 文件</h4><p>跟随着第 5 章，这里是一个生成 SB 文件的示例，其用于在 QSPIFlash 上为 MIMXRT1060-EVK 板进行映像加密和编程。</p><p>请参阅 <a href="#5-1-3-%E7%94%9F%E6%88%90%E7%94%A8%E4%BA%8E-flexspi-nor-%E6%98%A0%E5%83%8F%E5%8A%A0%E5%AF%86%E5%92%8C%E7%BC%96%E7%A8%8B%E7%9A%84-sb-%E6%96%87%E4%BB%B6">5.1.3 生成用于 FlexSPI NOR 映像加密和编程的 SB 文件</a> 中的 BD 文件。</p><p>BD 文件准备好之后，接下来就是生成 SB 文件了。请参阅下面的示例命令。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure28.jpg" alt="Figure 28. Example command to generate SB file for FlexSPI NOR image encryption and programming"></p><p>执行上图中的“program_flexspinor_image_qspinor_encrypt.bd -o boot_image.sb ivt_flexspi_nor_xip_signed_nopadding.bin”命令后，在包含 elftosb 实用程序可执行文件的文件夹中将生成一个名为“boot_image.sb”的文件。</p><h4 id="7-2-3-4-创建签名的-flashloader-映像"><a href="#7-2-3-4-创建签名的-flashloader-映像" class="headerlink" title="7.2.3.4 创建签名的 Flashloader 映像"></a>7.2.3.4 创建签名的 Flashloader 映像</h4><p>用于生成已签名的 Flashloader 映像的 BD 文件与 <del>7.1.2.1 生成签名的 i.MX RT 可引导映像</del> <a href="#7-2-3-1-%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D%E7%9A%84-i-mx-rt-%E5%8F%AF%E5%BC%95%E5%AF%BC%E6%98%A0%E5%83%8F">7.2.3.1 生成签名的 i.MX RT 可引导映像</a> 中的类似。</p><p>唯一的区别是 startAddress 是 0x20000000 和 IVTOffset 是 0x400。</p><p>BD 文件准备好后，下一步是使用 elftosb 实用程序生成 i.MX 引导映像。示例命令如下：</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure29.jpg" alt="Figure 29. Example command for Signed Flashloader image generation"></p><p>在上图中的命令“imx-dtcm-signed.bd -o ivt_flashloader_signed.bin flashloader.srec”之后，会生成两个可引导映像：</p><ul><li>ivt_flashloader_signed.bin</li><li>ivt_flashloader_signed_nopadding.bin</li></ul><p>第一个是 MfgTool 安全引导所必需的。</p><h4 id="7-2-3-5-使用-mfgtool-将已签名映像编程到-flash"><a href="#7-2-3-5-使用-mfgtool-将已签名映像编程到-flash" class="headerlink" title="7.2.3.5 使用 MfgTool 将已签名映像编程到 Flash"></a>7.2.3.5 使用 MfgTool 将已签名映像编程到 Flash</h4><p>以下是将引导映像编程到闪存设备中的步骤：</p><ol><li>将 boot_image.sb 文件、ivt_flashloader_signed.bin 和 enable_hab.sb 复制到“&lt;mfgtool_root_dir&gt;&#x2F;Profiles&#x2F;MXRT106X&#x2F;OS Firmware”文件夹</li><li>在 &lt;mfgtool_root_dir&gt;文件夹的 cfg.ini 文件中，将“[List]”下的“name”改为“MXRT106x-SecureBoot”</li><li>通过将 SW7 设置为“1-OFF、2-OFF、3-OFF、4-ON”，将 RT1060-EVK 板设置为串行下载器模式</li><li>给 RT1060-EVK 板上电，将 USB 线插入 J9</li><li>打开 MfgTool，它会显示检测到的设备。</li><li>点击“Start”，MfgTool 会进行制造，完成后会显示成功状态。点击“Stop”并关闭 MfgTool</li><li>将 RT1060-EVK 板置于内部引导模式并通过将 SW7 设置为“1-OFF、2-OFF、3-ON、4-OFF”来选择 QSPI FLASH 作为引导设备。重置设备。以太网接口上方的 LED 开始闪烁，表示映像正在运行。</li></ol><h2 id="7-3-手动生成-keyblob"><a href="#7-3-手动生成-keyblob" class="headerlink" title="7.3 手动生成 KeyBlob"></a>7.3 手动生成 KeyBlob</h2><p>在某些情况下，用户可能需要手动生成 KeyBlob。Flashloader 支持 blhost 的这种用法。</p><p>当设备在已签名的 Flashloader 应用程序的 HAB 关闭模式下工作时，必须生成 KeyBlob。</p><p>假设 dek.bin 已准备就绪（由 elftosb 实用程序在加密映像生成期间生成）。以下是生成 KeyBlob 块的示例命令。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure30.jpg" alt="Figure 30. Generate KeyBlob using the Flashloader"></p><p>执行上图中的“blhost.exe -u –generate-key-blob dek.bin keyblob.bin”命令后，将生成一个“keyblob.bin”文件。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure31.jpg" alt="Figure 31. Example KeyBlob"></p><p>使用 Hex Editor 创建将 elftosb 实用程序生成的加密映像和 Flashloader 生成的 keyblob.bin 组合在一起以创建一个完整的加密引导映像也是可行的。在此示例中，引导映像中的 KeyBlob 偏移量为 0x18000。</p><p>下图是 Hex Editor 合成的加密映像示例。</p><p><img src="/images/imx-rt1060-manufacturing-users-guide/figure32.jpg" alt="Figure 32. Create complete encrypted image using Hex editor"></p><h1 id="8-修订记录"><a href="#8-修订记录" class="headerlink" title="8 修订记录"></a>8 修订记录</h1><p>Table 19 总结了自初始版本以来对本文档所做的更改。</p><table><caption style="caption-side: top">Table 19. Revision history</caption><thead>  <tr>    <th style="text-align: center">Revision number</th>    <th style="text-align: center">Date</th>    <th style="text-align: center">Substantial changes</th>  </tr></thead><tbody>  <tr>    <td style="text-align: center">0</td>    <td style="text-align: center">10/2017</td>    <td style="text-align: center">Initial release</td>  </tr>  <tr>    <td style="text-align: center">1</td>    <td style="text-align: center">05/2018</td>    <td style="text-align: center">MCU Bootloader v2.5.0 release</td>  </tr>  <tr>    <td style="text-align: center">2</td>    <td style="text-align: center">08/2018</td>    <td style="text-align: center">RT1060 updates</td>  </tr>  <tr>    <td style="text-align: center">3</td>    <td style="text-align: center">06/2020</td>    <td style="text-align: center">Updated Figure 7</td>  </tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Translation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Embedded</tag>
      
      <tag>i.MX RT1060</tag>
      
      <tag>NXP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 嵌入式项目设置</title>
    <link href="/2022/03/17/vscode-embedded-project-setup/"/>
    <url>/2022/03/17/vscode-embedded-project-setup/</url>
    
    <content type="html"><![CDATA[<p>现今，每家嵌入式芯片厂商基本上都推出了自家的 Eclipse-based IDE 以方便开发者进行快速开发，如 <a href="https://www.st.com/">ST</a> 的 <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a>、<a href="https://www.nxp.com/">NXP</a> 的 <a href="https://www.nxp.com/design/software/development-software/mcuxpresso-software-and-tools-/mcuxpresso-integrated-development-environment-ide:MCUXpresso-IDE">MCUXpresso IDE</a>。</p><p>然而，Eclipse 的编辑功能个人认为并不好用，并且这些 Eclipse-based IDE 运行得并不流畅。因此，我决定自己搭建一个开发环境来替代这些 Eclipse-based IDE。本文以 ST 方案为例，因为我的机器上正好有 <a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX</a>。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>假定已安装了如下软件：</p><ul><li><a href="https://code.visualstudio.com/">VSCode</a></li><li><a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX</a></li><li><a href="https://www.gnu.org/software/make/">GNU Make</a></li><li><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a></li><li><a href="https://www.segger.com/downloads/jlink/">J-Link</a></li></ul><blockquote><p>注：</p><p>请确保将 <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a> 添加到环境变量 <code>PATH</code> 中。</p><p>在 Windows 下，不建议将 <a href="https://www.segger.com/downloads/jlink/">J-Link</a> 添加到环境变量 <code>PATH</code> 中，因为它可能会被 JDK 的 <code>jlink</code> 命令覆盖。</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用 <a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX</a> 创建一个新项目，配置好你板子上的外设及时钟，确保启用了调试功能（根据实际选择调试方式）：</p><p><img src="https://i.postimg.cc/FH3mm8FR/debug-mode-and-configuration.png"></p><p>在 <strong>Project Manager</strong> 页下命名项目，并将 <strong>Toolchain&#x2F;IDE</strong> 改为 <strong>Makefile</strong>：</p><p><img src="https://i.postimg.cc/28qr93Pn/project-manager.png"></p><p>点击 <strong>GENERATE CODE</strong> 以生成项目。项目的目录结构应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree -aCL 2 .<br>.<br>├── .mxproject<br>├── Core<br>│   ├── Inc<br>│   └── Src<br>├── Drivers<br>│   ├── CMSIS<br>│   └── STM32H7xx_HAL_Driver<br>├── Makefile<br>├── STM32H743IITx_FLASH.ld<br>├── led-demo.ioc<br>└── startup_stm32h743xx.s<br></code></pre></td></tr></table></figure><h2 id="安装-vscode-插件"><a href="#安装-vscode-插件" class="headerlink" title="安装 VSCode 插件"></a>安装 VSCode 插件</h2><p>使用 VSCode 打开生成的项目目录（示例中为 <code>C:\workspace\led-demo</code>）。点击左侧栏中的扩展，搜索并安装以下插件：</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C&#x2F;C++</a> —— 用于 C&#x2F;C++ 的智能提示、调试和代码查阅。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-embedded-tools">Embedded Tools</a> —— 用于调试嵌入式设备时查看其寄存器及 RTOS 数据。</li></ul><p><img src="https://i.postimg.cc/J7sXP2Fd/vscode-plugin-embedded-tools.png"></p><h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2><p>在项目的根目录下创建 <code>.vscode</code> 目录，该目录用于存放工作区设置。此时，项目的目录结构应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree -aCL 1 .<br>.<br>├── .mxproject<br>├── .vscode<br>├── Core<br>├── Drivers<br>├── Makefile<br>├── STM32H743IITx_FLASH.ld<br>├── led-demo.ioc<br>└── startup_stm32h743xx.s<br></code></pre></td></tr></table></figure><h3 id="添加-cmsis-svd-文件"><a href="#添加-cmsis-svd-文件" class="headerlink" title="添加 CMSIS-SVD 文件"></a>添加 CMSIS-SVD 文件</h3><p><a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> 文件用于描述 Arm Cortex-M 芯片的详细系统信息，主要是外设的内存映射寄存器。目前没有一个用于统一存储所有 Arm Cortex-M 芯片的 CMSIS-SVD 文件的仓库。但是有一个可用的 Github 仓库，其存储了大量的 CMSIS-SVD 文件：<a href="https://github.com/posborne/cmsis-svd">https://github.com/posborne/cmsis-svd</a>，你可以按需下载。</p><p>将需要的 CMSIS-SVD 文件保存到项目的根目录下，如本示例（<code>STM32H743x.svd</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree -aCL 1 .<br>.<br>├── .mxproject<br>├── .vscode<br>├── Core<br>├── Drivers<br>├── Makefile<br>├── STM32H743IITx_FLASH.ld<br>├── STM32H743x.svd<br>├── led-demo.ioc<br>└── startup_stm32h743xx.s<br></code></pre></td></tr></table></figure><h3 id="添加-j-link-命令文件"><a href="#添加-j-link-命令文件" class="headerlink" title="添加 J-Link 命令文件"></a>添加 J-Link 命令文件</h3><p><a href="https://wiki.segger.com/J-Link_Commander">J-Link Commander</a> 可以使用 <a href="https://wiki.segger.com/J-Link_Commander#Using_J-Link_Command_Files">J-Link 命令文件</a> 以在批处理模式下执行烧写固件任务。在项目的根目录下创建文件 <code>flash.jlink</code>，并根据实际情况填写如下内容：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">r<br>h<br><span class="hljs-built_in">loadfile</span> build/led-<span class="hljs-built_in">demo</span>.hex<br>q<br></code></pre></td></tr></table></figure><h3 id="添加-gdbinit-文件"><a href="#添加-gdbinit-文件" class="headerlink" title="添加 gdbinit 文件"></a>添加 gdbinit 文件</h3><p>在项目的根目录下创建文件 <code>reset.gdb</code>，并填写如下内容：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reset</span><br></code></pre></td></tr></table></figure><p><a href="https://wiki.segger.com/J-Link_GDB_Server#reset"><code>reset</code></a> 命令用于重置并停止目标 CPU。确保在使用此命令之前选择设备以使用正确的复位策略。</p><h3 id="添加调试设置文件"><a href="#添加调试设置文件" class="headerlink" title="添加调试设置文件"></a>添加调试设置文件</h3><p>在 <code>.vscode</code> 目录下创建 <a href="https://code.visualstudio.com/docs/editor/debugging"><code>launch.json</code></a> 文件，并根据实际情况填写如下内容，该文件用于自定义工作区的运行和调试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build, Flash and Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/led-demo.elf&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/gcc-arm-none-eabi/bin/arm-none-eabi-gdb.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:2331&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;debugServerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/Program Files/SEGGER/JLink/JLinkGDBServerCL.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;debugServerArgs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-if swd -speed 4000 -endian little -device STM32H743II -x $&#123;workspaceFolder&#125;/reset.gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;svdPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/STM32H743x.svd&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build and Flash&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="添加任务设置文件"><a href="#添加任务设置文件" class="headerlink" title="添加任务设置文件"></a>添加任务设置文件</h3><p>在 <code>.vscode</code> 目录下创建 <a href="https://code.visualstudio.com/docs/editor/tasks"><code>tasks.json</code></a> 文件，并根据实际情况填写如下内容，该文件用于定义工作区的任务：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/msys64/usr/bin/make.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build and Flash&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/Program Files/SEGGER/JLink/JLink.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;-Device&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;STM32H743II&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-If&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;SWD&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-Speed&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;4000&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-AutoConnect&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;-CommandFile&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;flash.jlink&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="添加-c-x2f-c-设置文件"><a href="#添加-c-x2f-c-设置文件" class="headerlink" title="添加 C&#x2F;C++ 设置文件"></a>添加 C&#x2F;C++ 设置文件</h3><p>在 <code>.vscode</code> 目录下创建 <a href="https://code.visualstudio.com/docs/cpp/customize-default-settings-cpp"><code>c_cpp_properties.json</code></a> 文件，并根据实际情况填写如下内容，该文件用于配置工作区的 C&#x2F;C++ 插件设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Win32&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-comment">// 可以使用如下匹配进行目录递归，这将包含工作区的所有目录：</span><br>                <span class="hljs-comment">//&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br><br>                <span class="hljs-comment">// 单独列出路径可能性能更佳（猜测！）</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Core/Inc&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Drivers/STM32H7xx_HAL_Driver/Inc&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Drivers/STM32H7xx_HAL_Driver/Inc/Legacy&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Drivers/CMSIS/Include&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/Drivers/CMSIS/Device/ST/STM32H7xx/Include&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;USE_HAL_DRIVER&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;STM32H743xx&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:/gcc-arm-none-eabi/bin/arm-none-eabi-gcc.exe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++11&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gcc-arm&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="调试项目"><a href="#调试项目" class="headerlink" title="调试项目"></a>调试项目</h2><p>现在，项目的目录结构应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree -aCL 2 .<br>.<br>├── .mxproject<br>├── .vscode<br>│   ├── c_cpp_properties.json<br>│   ├── launch.json<br>│   └── tasks.json<br>├── Core<br>│   ├── Inc<br>│   └── Src<br>├── Drivers<br>│   ├── CMSIS<br>│   └── STM32H7xx_HAL_Driver<br>├── Makefile<br>├── STM32H743IITx_FLASH.ld<br>├── STM32H743x.svd<br>├── flash.jlink<br>├── led-demo.ioc<br>├── reset.gdb<br>└── startup_stm32h743xx.s<br></code></pre></td></tr></table></figure><p>点击 VSCode 左侧栏的调试，并点击调试按钮：</p><p><img src="https://i.postimg.cc/28413ZVm/debug.png"></p><p>这将会编译项目，并将固件烧写到目标设备上，然后启动调试：</p><p><img src="https://i.postimg.cc/P5TPD5wD/debugging.png"></p><p>你可以通过点击源文件的行号左侧以设置断点，也可以观察程序暂停时的变量值、寄存器及调用栈：</p><p><img src="https://i.postimg.cc/GmK9xnF5/pause-debugging.png"></p>]]></content>
    
    
    <categories>
      
      <category>VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Embedded</tag>
      
      <tag>STM32CubeMX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Fibers</title>
    <link href="/2022/03/03/windows-via-c-cpp-5th-fibers/"/>
    <url>/2022/03/03/windows-via-c-cpp-5th-fibers/</url>
    
    <content type="html"><![CDATA[<p>Microsoft 为 Windows 添加了一种由应用程序手动调度的执行单元 —— <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers">纤程（Fiber）</a>。</p><p>Windows 内核中实现了线程，线程是操作系统可见的执行单元，系统将根据 Microsoft 定义的算法调度它们。纤程是在用户模式代码中实现的，因此它们对于系统来说是不可见的，并且应用程序必须定义自己的算法来调度它们。</p><p>单个线程可以包含一个或多个纤程。就内核而言，线程是抢占调度的，并且它正在执行代码。线程一次执行一个纤程的代码，具体运行哪个纤程由应用程序定义。</p><p>使用纤程时必须先将现有的线程转换为纤程，这可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber"><code>ConvertThreadToFiber</code></a> 来完成此操作。此函数会为纤程的执行上下文分配内存，执行上下文由以下元素组成：</p><ul><li>一个用户定义的值，其初始化为传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber"><code>ConvertThreadToFiber</code></a> 的 <code>pvParam</code> 参数的值。</li><li>一个结构化异常处理链的头部。</li><li>纤程的栈的顶部和底部内存地址（当您将线程转换为纤程时，这也是线程的栈）。</li><li>各种 CPU 寄存器，包括栈指针、指令指针等。</li></ul><p>分配并初始化纤程执行上下文后，执行上下文的地址将与线程相关联，该线程已转换为纤程，并且纤程将在此线程上运行。现在，如果纤程（线程）返回或调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a>，则纤程和线程都会终止。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber"><code>ConvertThreadToFiber</code></a> 实际上返回纤程执行上下文的内存地址。用户切勿自行读取或写入执行上下文数据。</p></blockquote><p>要创建另一个纤程，线程（当前运行的纤程）应该调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiber"><code>CreateFiber</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiberex"><code>CreateFiberEx</code></a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">PVOID <span class="hljs-title">CreateFiber</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwStackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    PFIBER_START_ROUTINE pfnStartAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvParam)</span></span>;<br><br><span class="hljs-function">PVOID <span class="hljs-title">CreateFiberEx</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T dwStackCommitSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T dwStackReserveSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    PFIBER_START_ROUTINE pStartAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvParam)</span></span>;<br></code></pre></td></tr></table></figure><p>首次调度纤程时，纤程例程将接收到最初传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiber"><code>CreateFiber</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiberex"><code>CreateFiberEx</code></a> 的 <code>pvParam</code>。</p><p>与通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber"><code>ConvertThreadToFiber</code></a> 获得的纤程不同，通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiber"><code>CreateFiber</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfiberex"><code>CreateFiberEx</code></a> 获得的纤程不会马上执行，因为当前运行的纤程仍在执行，在单个线程上一次只能执行一个纤程。要使新的纤程执行，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-switchtofiber"><code>SwitchToFiber</code></a> 函数。</p><p>在内部，<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-switchtofiber"><code>SwitchToFiber</code></a> 执行以下步骤：</p><ol><li>将当前的一些 CPU 寄存器（包括指令指针寄存器和栈指针寄存器）保存在当前运行的纤程的执行上下文中。</li><li>将先前保存在即将要运行的纤程的执行上下文中的寄存器加载到 CPU 寄存器中。</li><li>将纤程的执行上下文与线程相关联，线程运行指定的纤程。</li><li>将线程的指令指针设置为已保存的指令指针。线程（纤程）在此纤程上次执行的位置上继续执行。</li></ol><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-switchtofiber"><code>SwitchToFiber</code></a> 是纤程获得 CPU 时间的唯一方法。您的代码必须在适当的时间点显式地调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-switchtofiber"><code>SwitchToFiber</code></a> 来控制纤程的调度。</p><p>要销毁一个纤程，您可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-deletefiber"><code>DeleteFiber</code></a> 函数。</p><p>在销毁所有其它纤程后，由 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertthreadtofiber"><code>ConvertThreadToFiber</code></a> 获得的纤程可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-convertfibertothread"><code>ConvertFiberToThread</code></a> 函数将自身转换回线程。</p><p>如果您需要在单个纤程上存储信息，那么您可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers#fiber-local-storage"><em>FLS（Fiber Local Storage）</em></a> 函数。</p><p>为了方便，Microsoft 还提供了几个额外的纤程函数。如果要获取当前运行的纤程的执行上下文的地址，那么您可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-getcurrentfiber"><code>GetCurrentFiber</code></a>。如果要获取当前运行的纤程的纤程数据（在创建纤程时传递的 <code>pvParam</code>），那么您可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-getfiberdata"><code>GetFiberData</code></a>。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - The Windows Thread Pool</title>
    <link href="/2022/03/03/windows-via-c-cpp-5th-the-windows-thread-pool/"/>
    <url>/2022/03/03/windows-via-c-cpp-5th-the-windows-thread-pool/</url>
    
    <content type="html"><![CDATA[<p>每个人对如何管理线程的创建和销毁都有自己不同的看法。Windows 提供了一个 <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-pools">线程池</a> 机制（围绕 IOCP 构建），使得开发者可以更容易地管理线程的创建和销毁。这个新的通用线程池不一定适用于所有情况，但它通常表现得足够好，并且可以为您节省大量的开发时间。</p><p>新的线程池函数允许您：</p><ul><li>异步地调用函数</li><li>定时地调用函数</li><li>当单个内核对象已示意时调用函数</li><li>当异步 I&#x2F;O 请求完成时调用函数</li></ul><blockquote><p>注：Microsoft 从 Windows 2000 开始就将线程池 API 引入 Windows。在 Windows Vista 中，Microsoft 重构了线程池，并且引入了一组新的线程池 API。</p></blockquote><p>当一个进程初始化时，它没有任何与线程池组件相关的开销。但是，一旦调用了线程池函数，系统就会为进程创建一些内核资源，并且其中一些资源会一直保持到进程终止为止。使用线程池的开销取决于您的使用情况，线程池将代表进程分配一些线程、内核对象和内部数据结构。</p><h2 id="异步地调用函数"><a href="#异步地调用函数" class="headerlink" title="异步地调用函数"></a>异步地调用函数</h2><p>要使用线程池异步地执行函数，首先需要定义一个与 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms686295(v=vs.85)">SimpleCallback</a> 原型匹配的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID NTAPI <span class="hljs-title">SimpleCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_CALLBACK_INSTANCE pInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvContext)</span></span>;<br></code></pre></td></tr></table></figure><p>然后，向线程池提交请求，让其中一个线程执行该函数。要向线程池提交请求，只需调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 函数。<a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 函数会将一个 <em>工作项（Work Item）</em> 添加到线程池的队列中（通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/postqueuedcompletionstatus"><code>PostQueuedCompletionStatus</code></a>）。</p><blockquote><p>注：您不需要自己调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a>。<a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 函数将自动为进程创建默认线程池，并让线程池中的一个线程调用您的回调函数。</p></blockquote><p>线程池中的线程在处理完请求后不会立即销毁，而是返回到线程池中，以便准备处理其他入队的工作项。线程池不断重用其中的线程，而不是不断创建和销毁线程，这可以显著地提高应用程序的性能，因为创建和销毁线程需要花费大量时间。线程池会根据一个内部算法和应用程序的工作负载来调整自身的一些参数（如线程数）。</p><h3 id="显式地控制工作项"><a href="#显式地控制工作项" class="headerlink" title="显式地控制工作项"></a>显式地控制工作项</h3><p>在某些情况下（如缺少内存或配额限制），对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 的调用可能会失败。当多个操作应当协同工作时，这是不可接受的。例如，一个定时器指望一个工作项取消另一个操作。当定时器被设置时，您必须确保被取消的工作项已提交并由线程池处理。但是，当定时器到期时，内存可用性或配额条件可能与创建定时器时不同，并且对 对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 的调用可能会失败。在这种情况下，您将在创建定时器的同时创建一个工作项对象，并保留它，直到您明确需要将工作项提交到线程池。</p><p>每次调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-trysubmitthreadpoolcallback"><code>TrySubmitThreadpoolCallback</code></a> 时，都会在内部代表您分配一个工作项。如果您计划提交大量工作项，那么您最好将工作项创建一次并多次提交，这样可以提高性能和减少内存消耗。您可以通过使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwork"><code>CreateThreadpoolWork</code></a> 函数来创建工作项。当您要向线程池提交请求时，可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-submitthreadpoolwork"><code>SubmitThreadpoolWork</code></a> 函数。</p><p>如果您有另一个线程想要取消已提交的工作项或挂起自身以等待工作项完成其处理，则可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpoolworkcallbacks"><code>WaitForThreadpoolWorkCallbacks</code></a> 函数。</p><p>当您不再需要工作项时，应调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwork"><code>CloseThreadpoolWork</code></a> 函数来释放它。</p><h2 id="定时地调用函数"><a href="#定时地调用函数" class="headerlink" title="定时地调用函数"></a>定时地调用函数</h2><p>有时应用程序需要在特定时间执行某些任务。Windows 提供了一个 <a href="https://docs.microsoft.com/en-us/windows/win32/sync/waitable-timer-objects">可等待定时器内核对象</a> ，该对象可以轻松地获取基于时间的通知。</p><p>许多程序员会为应用程序将执行的每个基于时间的任务创建一个可等待定时器对象，这是不必要的，并且浪费系统资源。您可以创建单个可等待定时器，将其设置为下一个预定时间，然后为下一个时间重置定时器，依此类推。然而，完成此操作的代码编写起来十分棘手。幸运的是，您可以让线程池函数为您管理此操作。</p><p>若要计划在特定时间执行工作项，首先需要使用 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms686790(v=vs.85)"><code>TimeoutCallback</code></a> 原型定义一个回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID CALLBACK <span class="hljs-title">TimeoutCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_CALLBACK_INSTANCE pInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_TIMER pTimer)</span></span>;<br></code></pre></td></tr></table></figure><p>然后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer"><code>CreateThreadpoolTimer</code></a> 函数来通知线程池何时调用您的函数。</p><p>如果要向线程池注册定时器，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpooltimer"><code>SetThreadpoolTimer</code></a> 函数。您也可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-isthreadpooltimerset"><code>IsThreadpoolTimerSet</code></a> 来确定是否设置了定时器。</p><p>最后，您可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpooltimercallbacks"><code>WaitForThreadpoolTimerCallbacks</code></a> 让线程等待定时器完成，也可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-closethreadpooltimer"><code>CloseThreadpoolTimer</code></a> 函数来释放定时器的内存。</p><h2 id="当单个内核对象已示意时调用函数"><a href="#当单个内核对象已示意时调用函数" class="headerlink" title="当单个内核对象已示意时调用函数"></a>当单个内核对象已示意时调用函数</h2><p>Microsoft 研究发现许多应用程序产生线程只是为了等待一个内核对象变为已示意状态。一旦对象已示意，线程就会将某种通知发布到另一个线程，然后循环返回，等待对象再次示意。</p><p>如果您想注册一个要在内核对象已示意时执行的工作项，首先，您编写一个与 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms687017(v=vs.85)"><code>WaitCallback</code></a> 原型匹配的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID CALLBACK <span class="hljs-title">WaitCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_CALLBACK_INSTANCE pInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID Context,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_WAIT Wait,</span></span><br><span class="hljs-params"><span class="hljs-function">    TP_WAIT_RESULT WaitResult)</span></span>;<br></code></pre></td></tr></table></figure><p>然后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolwait"><code>CreateThreadpoolWait</code></a> 来创建一个线程池等待对象。</p><p>当准备就绪时，您需要通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait"><code>SetThreadpoolWait</code></a> 函数将内核对象绑定到此线程池等待对象。</p><p>在内部，线程池有一个线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects"><code>WaitForMultipleObjects</code></a> 函数，并将已通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait"><code>SetThreadpoolWait</code></a> 函数注册的句柄集传递给它，<code>bWaitAll</code> 参数设置为 <code>FALSE</code>，以便每当任何句柄已示意时，线程都会唤醒。此外，由于 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects"><code>WaitForMultipleObjects</code></a> 不允许将同一句柄多次传递给它，因此应确保不要使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait"><code>SetThreadpoolWait</code></a> 多次注册同一句柄。</p><p>一旦线程池线程调用了您的回调函数，相应的等待项将处于非活动状态。这意味着如果您希望在同一内核对象已示意时再次调用回调函数，则需要通过再次调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait"><code>SetThreadpoolWait</code></a> 来重新注册它。</p><p>最后，您可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpoolwaitcallbacks"><code>WaitForThreadpoolWaitCallbacks</code></a> 让线程等待等待项完成，也可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolwait"><code>CloseThreadpoolWait</code></a> 函数来释放等待项的内存。</p><h2 id="当异步-i-x2f-o-请求完成时调用函数"><a href="#当异步-i-x2f-o-请求完成时调用函数" class="headerlink" title="当异步 I&#x2F;O 请求完成时调用函数"></a>当异步 I&#x2F;O 请求完成时调用函数</h2><p>当您希望将 IOCP 与线程池配合使用时，您必须告诉线程池当异步 I&#x2F;O 操作完成时要调用哪个函数。</p><p>首先，您必须编写一个与 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms684124(v=vs.85)"><code>OverlappedCompletionRoutine</code></a> 原型匹配的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID CALLBACK <span class="hljs-title">OverlappedCompletionRoutine</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_CALLBACK_INSTANCE pInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvContext,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pOverlapped,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG IoResult,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG_PTR NumberOfBytesTransferred,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTP_IO pIo)</span></span>;<br></code></pre></td></tr></table></figure><p>然后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio"><code>CreateThreadpoolIo</code></a> 创建一个线程池 I&#x2F;O 对象。</p><p>准备就绪后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-startthreadpoolio"><code>StartThreadpoolIo</code></a> 函数将 I&#x2F;O 项中嵌入的文件&#x2F;设备与线程池的内部 IOCP 相关联。</p><p>要注意的是，在每次调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a> 之前，必须先调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-startthreadpoolio"><code>StartThreadpoolIo</code></a> 。如果在发出 I&#x2F;O 请求之前未调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-startthreadpoolio"><code>StartThreadpoolIo</code></a> ，则不会调用您的 <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms684124(v=vs.85)"><code>OverlappedCompletionRoutine</code></a> 回调函数。</p><p>如果要在发出 I&#x2F;O 请求后停止调用您的回调函数，那么可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-cancelthreadpoolio"><code>CancelThreadpoolIo</code></a> 函数。</p><p>当您使用完文件&#x2F;设备后，您应调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 将其关闭，并调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-closethreadpoolio"><code>CloseThreadpoolIo</code></a> 函数将其与线程池解除关联。</p><p>您可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-waitforthreadpooliocallbacks"><code>WaitForThreadpoolIoCallbacks</code></a> 函数让另一个线程等待未完成的 I&#x2F;O 请求完成。</p><h2 id="回调终止操作"><a href="#回调终止操作" class="headerlink" title="回调终止操作"></a>回调终止操作</h2><p>线程池使回调方法能够方便地描述在回调函数返回时应执行的一些操作。您的回调函数有一个不透明的 <code>PTP_CALLBACK_INSTANCE</code> 类型的 <code>pInstance</code> 参数，该参数可以用于调用以下函数之一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID <span class="hljs-title">LeaveCriticalSectionWhenCallbackReturns</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">ReleaseMutexWhenCallbackReturns</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci, HANDLE mut)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">ReleaseSemaphoreWhenCallbackReturns</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">SetEventWhenCallbackReturns</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci, HANDLE evt)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">FreeLibraryWhenCallbackReturns</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci, HMODULE mod)</span></span>;<br></code></pre></td></tr></table></figure><p>对于这些函数，线程池将执行下表指示的终止操作：</p><table><thead><tr><th align="left">Function</th><th align="left">Termination Action</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-leavecriticalsectionwhencallbackreturns"><code>LeaveCriticalSectionWhenCallbackReturns</code></a></td><td align="left">When the callback returns, the thread pool automatically calls <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection"><code>LeaveCriticalSection</code></a>, passing the specified <code>CRITICAL_SECTION</code> structure.</td></tr><tr><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-releasemutexwhencallbackreturns"><code>ReleaseMutexWhenCallbackReturns</code></a></td><td align="left">When the callback returns, the thread pool automatically calls <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex"><code>ReleaseMutex</code></a>, passing the specified <code>HANDLE</code>.</td></tr><tr><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-releasesemaphorewhencallbackreturns"><code>ReleaseSemaphoreWhenCallbackReturns</code></a></td><td align="left">When the callback returns, the thread pool automatically calls <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore"><code>ReleaseSemaphore</code></a>, passing the specified <code>HANDLE</code>.</td></tr><tr><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-seteventwhencallbackreturns"><code>SetEventWhenCallbackReturns</code></a></td><td align="left">When the callback returns, the thread pool automatically calls <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent"><code>SetEvent</code></a>, passing the specified <code>HANDLE</code>.</td></tr><tr><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-freelibrarywhencallbackreturns"><code>FreeLibraryWhenCallbackReturns</code></a></td><td align="left">When the callback returns, the thread pool automatically calls <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><code>FreeLibrary</code></a>, passing the specified <code>HMODULE</code>.</td></tr></tbody></table><blockquote><p>注：对于给定的回调实例，线程池线程只应用一个终止效果。调用的最后一个函数将覆盖前一个函数。</p></blockquote><p>除了这些终止函数之外，还有两个额外的函数适用于回调实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">CallbackMayRunLong</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">DisassociateCurrentThreadFromCallback</span><span class="hljs-params">(PTP_CALLBACK_INSTANCE pci)</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Synchronous and Asynchronous Device I/O</title>
    <link href="/2022/02/28/windows-via-c-cpp-5th-synchronous-and-asynchronous-device-io/"/>
    <url>/2022/02/28/windows-via-c-cpp-5th-synchronous-and-asynchronous-device-io/</url>
    
    <content type="html"><![CDATA[<p>在 Microsoft Windows 应用程序中，线程是用于分割工作的最佳工具。每个线程被分配给一个处理器，这允许多处理器计算机同时执行多个操作，从而提高吞吐量。当线程发出同步设备 I&#x2F;O 请求时，该线程将暂时挂起，直到设备完成 I&#x2F;O 请求。这种挂起会降低线程的性能，因为线程无法执行有用的工作（如启动另一个客户端的处理请求）。简而言之，您希望始终保持线程执行有用的工作，并避免它们被阻塞。</p><p>为了使线程保持忙碌，您需要让线程就它们将执行的操作相互通信。微软花了数年时间在这一领域进行研究和测试，并开发了一种经过微调的机制来创建这种通信。这种机制称为 <em>IOCP（I&#x2F;O Completion Port）</em> ，其可以帮助您创建高性能、可伸缩的应用程序。使用 IOCP，您可以通过向设备读取和写入数据但不等待设备的响应来使应用程序的线程达到惊人的吞吐量。</p><h2 id="打开与关闭设备"><a href="#打开与关闭设备" class="headerlink" title="打开与关闭设备"></a>打开与关闭设备</h2><p>Windows 的优势之一是它支持数量庞大的设备。本文将设备定义为允许通信的任何东西。下表列出了一些设备及其最常见的用途：</p><table><thead><tr><th align="left">Device</th><th align="left">Most Common Use</th></tr></thead><tbody><tr><td align="left">File</td><td align="left">Persistent storage of arbitrary data</td></tr><tr><td align="left">Directory</td><td align="left">Attribute and file compression settings</td></tr><tr><td align="left">Logical disk drive</td><td align="left">Drive formatting</td></tr><tr><td align="left">Physical disk drive</td><td align="left">Partition table access</td></tr><tr><td align="left">Serial port</td><td align="left">Data transmission over a phone line</td></tr><tr><td align="left">Parallel port</td><td align="left">Data transmission to a printer</td></tr><tr><td align="left">Mailslot</td><td align="left">One-to-many transmission of data, usually over a network to a machine running Windows</td></tr><tr><td align="left">Named pipe</td><td align="left">One-to-one transmission of data, usually over a network to a machine running Windows</td></tr><tr><td align="left">Anonymous pipe</td><td align="left">One-to-one transmission of data on a single machine (never over the network)</td></tr><tr><td align="left">Socket</td><td align="left">Datagram or stream transmission of data, usually over a network to any machine supporting sockets (The machine need not be running Windows.)</td></tr><tr><td align="left">Console</td><td align="left">A text window screen buffer</td></tr></tbody></table><p>线程可以与这些设备进行通信，而无需等待设备响应。Windows 试图尽可能地向软件开发人员隐藏设备差异。也就是说，打开设备后，无论您使用什么设备进行通信，允许您向设备读取和写入数据的 Windows 函数都是相同的。尽管有少数函数可以无视设备差异地用于读取和写入数据，但设备之间肯定是存在差异的。要执行任何类型的 I&#x2F;O，您必须首先打开所需的设备并获取其句柄。获取设备句柄的方式取决于特定设备。下表列出了各种设备以及打开它们时应调用的函数：</p><table><thead><tr><th align="left">Device</th><th align="left">Function Used to Open the Device</th></tr></thead><tbody><tr><td align="left">File</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is pathname or UNC pathname).</td></tr><tr><td align="left">Directory</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is directory name or UNC directory name). Windows allows you to open a directory if you specify the <code>FILE_FLAG_BACKUP_SEMANTICS</code> flag in the call to <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a>. Opening the directory allows you to change the directory’s attributes (to normal, hidden, and so on) and its time stamp.</td></tr><tr><td align="left">Logical disk drive</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;\\.\x:&quot;</code>). Windows allows you to open a logical drive if you specify a string in the form of <code>&quot;\\.\x:&quot;</code> where <code>x</code> is a drive letter. For example, to open drive A, you specify <code>&quot;\\.\A:&quot;</code>. Opening a drive allows you to format the drive or determine the media size of the drive.</td></tr><tr><td align="left">Physical disk drive</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;\\.\PHYSICALDRIVEx&quot;</code>). Windows allows you to open a physical drive if you specify a string in the form of <code>&quot;\\.\PHYSICALDRIVEx&quot;</code> where <code>x</code> is a physical drive number. For example, to read or write to physical sectors on the user’s first physical hard disk, you specify <code>&quot;\\.\PHYSICALDRIVE0&quot;</code>. Opening a physical drive allows you to access the hard drive’s partition tables directly. Opening the physical drive is potentially dangerous; an incorrect write to the drive could make the disk’s contents inaccessible by the operating system’s file system.</td></tr><tr><td align="left">Serial port</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;COMx&quot;</code>).</td></tr><tr><td align="left">Parallel port</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;LPTx&quot;</code>).</td></tr><tr><td align="left">Mailslot server</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createmailslotw"><code>CreateMailslot</code></a> (<code>pszName</code> is <code>&quot;\\.\mailslot\mailslotname&quot;</code>).</td></tr><tr><td align="left">Mailslot client</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;\\servername\mailslot\mailslotname&quot;</code>).</td></tr><tr><td align="left">Named pipe server</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createnamedpipew"><code>CreateNamedPipe</code></a> (<code>pszName</code> is <code>&quot;\\.\pipe\pipename&quot;</code>).</td></tr><tr><td align="left">Named pipe client</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> (<code>pszName</code> is <code>&quot;\\servername\pipe\pipename&quot;</code>).</td></tr><tr><td align="left">Anonymous pipe</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe"><code>CreatePipe</code></a> client and server.</td></tr><tr><td align="left">Socket</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket"><code>socket</code></a>, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept"><code>accept</code></a>, or <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-acceptex"><code>AcceptEx</code></a>.</td></tr><tr><td align="left">Console</td><td align="left"><a href="https://docs.microsoft.com/en-us/windows/console/createconsolescreenbuffer"><code>CreateConsoleScreenBuffer</code></a> or <a href="https://docs.microsoft.com/en-us/windows/console/getstdhandle"><code>GetStdHandle</code></a>.</td></tr></tbody></table><p>这些函数都返回一个标识设备的句柄。可以将返回的句柄传递给各种函数以与设备进行通信。</p><p>使用完设备后，必须将其关闭。对于大多数设备，您可以通过调用常见的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 函数来执行此操作。然而，如果设备是 socket，则必须改为调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket"><code>closesocket</code></a>。</p><h2 id="使用文件设备"><a href="#使用文件设备" class="headerlink" title="使用文件设备"></a>使用文件设备</h2><h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><p>处理文件时，通常需要获取文件的大小。最简单的方法是调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfilesizeex"><code>GetFileSizeEx</code></a>。另一个用于获取文件大小的非常有用的函数是 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizew"><code>GetCompressedFileSize</code></a>。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizew"><code>GetCompressedFileSize</code></a> 返回文件的物理大小，而 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfilesizeex"><code>GetFileSizeEx</code></a> 返回文件的逻辑大小。</p><h3 id="定位文件指针"><a href="#定位文件指针" class="headerlink" title="定位文件指针"></a>定位文件指针</h3><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> 会导致系统创建一个文件内核对象来管理对该文件的操作。文件内核对象的内部是一个文件指针。文件指针指示下一次执行同步读取或写入时的偏移量。最初，文件指针设置为 0，因此如果在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> 后立即调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a>，您将从偏移量 0 开始读取文件。如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BYTE pb[<span class="hljs-number">10</span>];<br>DWORD dwNumBytes;<br>HANDLE hFile = <span class="hljs-built_in">CreateFile</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyFile.dat&quot;</span>), ...); <span class="hljs-comment">// Pointer set to 0</span><br><span class="hljs-built_in">ReadFile</span>(hFile, pb, <span class="hljs-number">10</span>, &amp;dwNumBytes, <span class="hljs-literal">NULL</span>);         <span class="hljs-comment">// Reads bytes 0 - 9</span><br><span class="hljs-built_in">ReadFile</span>(hFile, pb, <span class="hljs-number">10</span>, &amp;dwNumBytes, <span class="hljs-literal">NULL</span>);         <span class="hljs-comment">// Reads bytes 10 - 19</span><br></code></pre></td></tr></table></figure><p>由于每个文件内核对象都有自己的文件指针，因此打开同一文件两次会得到略有不同的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BYTE pb[<span class="hljs-number">10</span>];<br>DWORD dwNumBytes;<br>HANDLE hFile1 = <span class="hljs-built_in">CreateFile</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyFile.dat&quot;</span>), ...); <span class="hljs-comment">// Pointer set to 0</span><br>HANDLE hFile2 = <span class="hljs-built_in">CreateFile</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MyFile.dat&quot;</span>), ...); <span class="hljs-comment">// Pointer set to 0</span><br><span class="hljs-built_in">ReadFile</span>(hFile1, pb, <span class="hljs-number">10</span>, &amp;dwNumBytes, <span class="hljs-literal">NULL</span>);         <span class="hljs-comment">// Reads bytes 0 - 9</span><br><span class="hljs-built_in">ReadFile</span>(hFile2, pb, <span class="hljs-number">10</span>, &amp;dwNumBytes, <span class="hljs-literal">NULL</span>);         <span class="hljs-comment">// Reads bytes 0 - 9</span><br></code></pre></td></tr></table></figure><p>如果需要随机访问文件，那么您需要更改与文件内核对象关联的文件指针。可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"><code>SetFilePointerEx</code></a> 来执行此操作。以下是关于 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"><code>SetFilePointerEx</code></a> 的一些细节：</p><ul><li>将文件的指针设置在文件当前大小之外是合法的。这样做实际上不会增加磁盘上文件的大小，除非您在此位置进行写入或调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setendoffile"><code>SetEndOfFile</code></a>。</li><li>将 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"><code>SetFilePointerEx</code></a> 与使用 <code>FILE_FLAG_NO_BUFFERING</code> 打开的文件一起使用时，文件指针只能定位在扇区对齐的（Sector-aligned）边界上。</li><li>Windows 不提供 <code>GetFilePointerEx</code> 函数，但您可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"><code>SetFilePointerEx</code></a> 将指针移动 <code>0</code> 个字节以实现同样的效果。</li></ul><h3 id="设置文件的末尾"><a href="#设置文件的末尾" class="headerlink" title="设置文件的末尾"></a>设置文件的末尾</h3><p>通常，系统负责在文件关闭时设置文件的未尾。但是，有时您可能希望强制文件变小或变大。这种情况下，您可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setendoffile"><code>SetEndOfFile</code></a>。</p><p>此函数将文件的大小截断或扩展为文件对象的文件指针指示的大小。例如，要强制文件的长度为 1024 字节，则可以使用如下方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hFile = <span class="hljs-built_in">CreateFile</span>(...);<br>LARGE_INTEGER liDistanceToMove;<br>liDistanceToMove.QuadPart = <span class="hljs-number">1024</span>;<br><span class="hljs-built_in">SetFilePointerEx</span>(hFile, liDistanceToMove, <span class="hljs-literal">NULL</span>, FILE_BEGIN);<br><span class="hljs-built_in">SetEndOfFile</span>(hFile);<br><span class="hljs-built_in">CloseHandle</span>(hFile);<br></code></pre></td></tr></table></figure><h2 id="执行同步设备-i-x2f-o"><a href="#执行同步设备-i-x2f-o" class="headerlink" title="执行同步设备 I&#x2F;O"></a>执行同步设备 I&#x2F;O</h2><p>读取和写入设备的最简单且最常用的函数是 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a>。</p><h3 id="将数据刷新到设备"><a href="#将数据刷新到设备" class="headerlink" title="将数据刷新到设备"></a>将数据刷新到设备</h3><p>在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> 函数时，您可以传递相当多的标志来更改系统缓存文件数据的方式。其他一些设备（如 Serial Port、Mailslot 和 Pipe）也会缓存数据。如果要强制系统将缓存的数据写入设备，可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-flushfilebuffers"><code>FlushFileBuffers</code></a>。</p><h3 id="同步-i-x2f-o-取消"><a href="#同步-i-x2f-o-取消" class="headerlink" title="同步 I&#x2F;O 取消"></a>同步 I&#x2F;O 取消</h3><p>执行同步 I&#x2F;O 的函数易于使用，但它们会在发出 I&#x2F;O 的线程上阻塞，直到请求完成。如果在 GUI 应用程序的 UI 线程上执行同步 I&#x2F;O，则可能会因此长时间阻塞，此时 UI 将会冻住。</p><p>在 Windows Vista 中，Microsoft 增加了一些特性来缓解这个问题。例如，如果 CUI 应用程序由于同步 I&#x2F;O 而挂起，则用户可以按下 <code>Ctrl + C</code> 以重新获得控制权并继续使用控制台。用户不再需要终止控制台进程。此外，新的文件打开&#x2F;保存对话框允许用户在打开文件花费过长时间时按“取消”按钮。</p><p>如果要构建一个响应式应用程序，那么您应该尝试尽可能多地执行异步 I&#x2F;O 操作。这通常允许您在应用程序中使用很少的线程，从而节省资源（如线程内核对象和栈）。此外，这通常很容易为用户提供在异步启动操作时取消操作的功能。</p><p>遗憾的是，某些 Windows API（如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a>）无法提供异步调用的方法。尽管其中一些方法会在等待时间过长时超时，但最好是调用 API 来强制线程中止等待并取消同步 I&#x2F;O 操作。在 Windows Vista 中，<a href="https://docs.microsoft.com/en-us/windows/win32/fileio/cancelsynchronousio-func"><code>CancelSynchronousIo</code></a> 函数允许您取消给定线程的正在挂起的同步 I&#x2F;O 请求。</p><blockquote><p>注：I&#x2F;O 请求的取消取决于相应系统层的驱动程序的实现。驱动程序可能会不支持取消，在这种情况下，<a href="https://docs.microsoft.com/en-us/windows/win32/fileio/cancelsynchronousio-func"><code>CancelSynchronousIo</code></a> 始终会返回 <code>TRUE</code>，因为此函数已找到标记为已取消的请求。</p></blockquote><h2 id="异步设备-i-x2f-o-基础"><a href="#异步设备-i-x2f-o-基础" class="headerlink" title="异步设备 I&#x2F;O 基础"></a>异步设备 I&#x2F;O 基础</h2><p>与计算机执行的大多数其他操作相比，设备 I&#x2F;O 是最慢且最不可预测的操作之一。使用异步设备 I&#x2F;O 能够更好地利用资源，从而创建更高效的应用程序。</p><p>考虑向设备发出异步 I&#x2F;O 请求的线程，此 I&#x2F;O 请求传递到设备驱动程序，驱动程序负责实际执行 I&#x2F;O。当设备驱动程序等待设备响应时，应用程序的线程在等待 I&#x2F;O 请求完成时不会挂起。相反，此线程继续执行其他有用的任务。在某个时候，设备驱动程序处理完排队的 I&#x2F;O 请求，并且必须通知应用程序数据已发送、已接收或发生错误。对异步 I&#x2F;O 请求进行排队是设计高性能、可伸缩应用程序的本质。</p><p>要异步访问设备，必须首先调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFile</code></a> 并在 <code>dwFlagsAndAttributes</code> 参数中指定 <code>FILE_FLAG_OVERLAPPED</code> 标志来打开设备，此标志通知系统您打算异步访问设备。</p><p>然后可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a> 函数将 I&#x2F;O 请求排队到设备驱动程序。</p><h3 id="异步设备-i-x2f-o-注意事项"><a href="#异步设备-i-x2f-o-注意事项" class="headerlink" title="异步设备 I&#x2F;O 注意事项"></a>异步设备 I&#x2F;O 注意事项</h3><p>在执行异步 I&#x2F;O 时，设备驱动程序不一定以 FIFO（First-In First-Out）方式处理排队的 I&#x2F;O 请求。比如，一个线程执行如下代码，可能会发生先写后读的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OVERLAPPED o1 = &#123; <span class="hljs-number">0</span> &#125;;<br>OVERLAPPED o2 = &#123; <span class="hljs-number">0</span> &#125;;<br>BYTE bBuffer[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">ReadFile</span> (hFile, bBuffer, <span class="hljs-number">100</span>, <span class="hljs-literal">NULL</span>, &amp;o1);<br><span class="hljs-built_in">WriteFile</span>(hFile, bBuffer, <span class="hljs-number">100</span>, <span class="hljs-literal">NULL</span>, &amp;o2);<br></code></pre></td></tr></table></figure><p>设备驱动程序通常会按乱序执行 I&#x2F;O 请求（如果这样做有助于提高性能）。例如，为了减少磁头移动和寻道时间，文件系统驱动程序可能会扫描排队的 I&#x2F;O 请求列表，以查找与硬盘驱动器物理位置上靠近的请求。</p><p>当尝试将异步 I&#x2F;O 请求排队时，设备驱动程序可能会选择同步地处理请求。当您正在读取文件并且系统检查到所需的数据已在系统的缓存中时，可能会发生这种情况。如果数据可用，那么您的 I&#x2F;O 请求不会排队到设备驱动程序。相反，系统会将数据从缓存复制到缓冲区，并且 I&#x2F;O 操作完成。</p><p>要注意，在 I&#x2F;O 请求完成之前，不得移动或销毁用于发出异步 I&#x2F;O 请求的数据缓冲区和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构。因为将 I&#x2F;O 请求排队到设备驱动程序时，只是向驱动程序传递数据缓冲区的地址和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的地址，并没有拷贝副本。</p><h3 id="取消排队的设备-i-x2f-o-请求"><a href="#取消排队的设备-i-x2f-o-请求" class="headerlink" title="取消排队的设备 I&#x2F;O 请求"></a>取消排队的设备 I&#x2F;O 请求</h3><p>有时，您可能希望在设备驱动程序处理排队的设备 I&#x2F;O 请求之前取消该请求。Windows 提供了几种方法来执行此操作：</p><ul><li>可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/cancelio"><code>CancelIo</code></a> 来取消由指定句柄的调用线程排队的所有 I&#x2F;O 请求（除非该句柄已与 IOCP 关联）。</li><li>可以通过关闭设备本身的句柄来取消所有排队的 I&#x2F;O 请求（不管请求是由哪个线程排队的）。</li><li>当线程终止时，系统会自动取消该线程发出的所有 I&#x2F;O 请求，但对已与 IOCP 关联的句柄发出的请求除外。</li><li>如果需要取消在给定文件句柄上提交的单个特定 I&#x2F;O 请求，可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/cancelioex-func"><code>CancelIoEx</code></a>。</li></ul><h2 id="接收已完成的-i-x2f-o-请求通知"><a href="#接收已完成的-i-x2f-o-请求通知" class="headerlink" title="接收已完成的 I&#x2F;O 请求通知"></a>接收已完成的 I&#x2F;O 请求通知</h2><p>Windows 提供了四种不同的方法用于接收 I&#x2F;O 完成通知，如下表：</p><table><thead><tr><th align="left">Technique</th><th align="left">Summary</th></tr></thead><tbody><tr><td align="left">Signaling a device kernel object</td><td align="left">Not useful for performing multiple simultaneous I&#x2F;O requests against a single device. Allows one thread to issue an I&#x2F;O request and another thread to process it.</td></tr><tr><td align="left">Signaling an event kernel object</td><td align="left">Allows multiple simultaneous I&#x2F;O requests against a single device. Allows one thread to issue an I&#x2F;O request and another thread to process it.</td></tr><tr><td align="left">Using alertable I&#x2F;O</td><td align="left">Allows multiple simultaneous I&#x2F;O requests against a single device. The thread that issued an I&#x2F;O request must also process it.</td></tr><tr><td align="left">Using I&#x2F;O completion ports</td><td align="left">Allows multiple simultaneous I&#x2F;O requests against a single device. Allows one thread to issue an I&#x2F;O request and another thread to process it. This technique is highly scalable and has the most flexibility.</td></tr></tbody></table><h3 id="示意设备内核对象"><a href="#示意设备内核对象" class="headerlink" title="示意设备内核对象"></a>示意设备内核对象</h3><p>一旦线程发出异步 I&#x2F;O 请求，线程就会继续执行，从而执行有用的工作。最终，线程需要与 I&#x2F;O 操作的完成同步。</p><p>在 Windows 中，设备内核对象可用于线程同步，因此该对象可以处于已示意状态或未示意状态。<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a> 函数在排队 I&#x2F;O 请求之前将设备内核对象设置为未示意状态。当设备驱动程序完成请求时，驱动程序会将设备内核对象设置为已示意状态。</p><p>线程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects"><code>WaitForMultipleObjects</code></a> 来确定异步 I&#x2F;O 请求是否已完成。下面是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hFile = <span class="hljs-built_in">CreateFile</span>(..., FILE_FLAG_OVERLAPPED, ...);<br>BYTE bBuffer[<span class="hljs-number">100</span>];<br>OVERLAPPED o = &#123; <span class="hljs-number">0</span> &#125;;<br>o.Offset = <span class="hljs-number">345</span>;<br><br>BOOL bReadDone = <span class="hljs-built_in">ReadFile</span>(hFile, bBuffer, <span class="hljs-number">100</span>, <span class="hljs-literal">NULL</span>, &amp;o);<br>DWORD dwError = <span class="hljs-built_in">GetLastError</span>();<br><br><span class="hljs-keyword">if</span> (!bReadDone &amp;&amp; (dwError == ERROR_IO_PENDING)) &#123;<br>    <span class="hljs-comment">// The I/O is being performed asynchronously; wait for it to complete</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(hFile, INFINITE);<br>    bReadDone = TRUE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (bReadDone) &#123;<br>    <span class="hljs-comment">// o.Internal contains the I/O error</span><br>    <span class="hljs-comment">// o.InternalHigh contains the number of bytes transferred</span><br>    <span class="hljs-comment">// bBuffer contains the read data</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// An error occurred; see dwError</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示意事件内核对象"><a href="#示意事件内核对象" class="headerlink" title="示意事件内核对象"></a>示意事件内核对象</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的 <code>hEvent</code> 成员可以用于标识一个事件内核对象，该事件对象必须通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventw"><code>CreateEvent</code></a> 来创建。当异步 I&#x2F;O 请求完成后，设备驱动程序将检查 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的 <code>hEvent</code> 成员是否为 <code>NULL</code>。若 <code>hEvent</code> 不为 <code>NULL</code>，则驱动程序将通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent"><code>SetEvent</code></a> 来发出事件信号。</p><p>如果要同时执行多个异步设备 I&#x2F;O 请求，那么必须为每个请求创建一个单独的事件对象，在每个请求的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构中初始化 <code>hEvent</code> 成员，然后调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a>。当需要与 I&#x2F;O 请求的完成同步时，只需调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects"><code>WaitForMultipleObjects</code></a>，并传入与未完成的 I&#x2F;O 请求的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构关联的事件句柄。使用此方案，可以简单可靠地同时执行多个异步设备 I&#x2F;O 操作，并使用相同的设备对象。下面是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hFile = <span class="hljs-built_in">CreateFile</span>(..., FILE_FLAG_OVERLAPPED, ...);<br><br>BYTE bReadBuffer[<span class="hljs-number">10</span>];<br>OVERLAPPED oRead = &#123; <span class="hljs-number">0</span> &#125;;<br>oRead.Offset = <span class="hljs-number">0</span>;<br>oRead.hEvent = <span class="hljs-built_in">CreateEvent</span>(...);<br><span class="hljs-built_in">ReadFile</span>(hFile, bReadBuffer, <span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>, &amp;oRead);<br><br>BYTE bWriteBuffer[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;;<br>OVERLAPPED oWrite = &#123; <span class="hljs-number">0</span> &#125;;<br>oWrite.Offset = <span class="hljs-number">10</span>;<br>oWrite.hEvent = <span class="hljs-built_in">CreateEvent</span>(...);<br><span class="hljs-built_in">WriteFile</span>(hFile, bWriteBuffer, _countof(bWriteBuffer), <span class="hljs-literal">NULL</span>, &amp;oWrite);<br>...<br><br>HANDLE h[<span class="hljs-number">2</span>];<br>h[<span class="hljs-number">0</span>] = oRead.hEvent;<br>h[<span class="hljs-number">1</span>] = oWrite.hEvent;<br>DWORD dw = <span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h, FALSE, INFINITE);<br><span class="hljs-keyword">switch</span> (dw – WAIT_OBJECT_0) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// Read completed</span><br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// Write completed</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可警示-i-x2f-o"><a href="#可警示-i-x2f-o" class="headerlink" title="可警示 I&#x2F;O"></a>可警示 I&#x2F;O</h3><p>每当创建线程时，系统也会创建一个与该线程关联的队列，称为 APC（Asynchronous Procedure Call）队列。当发出 I&#x2F;O 请求时，您可以告诉设备驱动程序将一个条目追加到调用线程的 APC 队列。要将已完成的 I&#x2F;O 通知排队到线程的 APC 队列，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex"><code>ReadFileEx</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefileex"><code>WriteFileEx</code></a> 函数。</p><p>当您使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex"><code>ReadFileEx</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefileex"><code>WriteFileEx</code></a> 发出异步 I&#x2F;O 请求时，这些函数会将 <em>完成例程（Completion Routine）</em> 的地址传递给设备驱动程序。当设备驱动程序完成 I&#x2F;O 请求后，它会在发出线程的 APC 队列中追加一个条目。此条目包含完成例程的地址和用于启动 I&#x2F;O 请求的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的地址。</p><blockquote><p>注：当可警示 I&#x2F;O 完成时，设备驱动程序不会尝试向事件对象发出信号。</p></blockquote><p>当线程处于可警示状态时，系统将检查其 APC 队列，对于队列中的每个条目，系统都会调用完成例程，并向其传递 I&#x2F;O 错误码、传输的字节数以及 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的地址。</p><p>现在，让我们看一下系统如何处理异步 I&#x2F;O 请求。下面的代码将三种不同的异步操作排队：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hFile = <span class="hljs-built_in">CreateFile</span>(..., FILE_FLAG_OVERLAPPED, ...);<br><br><span class="hljs-built_in">ReadFileEx</span>(hFile, ...);  <span class="hljs-comment">// Perform first ReadFileEx</span><br><span class="hljs-built_in">WriteFileEx</span>(hFile, ...); <span class="hljs-comment">// Perform first WriteFileEx</span><br><span class="hljs-built_in">ReadFileEx</span>(hFile, ...);  <span class="hljs-comment">// Perform second ReadFileEx</span><br><br><span class="hljs-built_in">SomeFunc</span>();<br></code></pre></td></tr></table></figure><p>如果对 <code>SomeFunc</code> 的调用需要一些时间来执行，那么系统可能在 <code>SomeFunc</code> 返回之前完成这三个操作。虽然线程正在执行 <code>SomeFunc</code> 函数，但设备驱动程序会将已完成的 I&#x2F;O 条目追加到线程的 APC 队列中。APC 队列可能如下所示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">first</span> WriteFileEx completed<br><span class="hljs-keyword">second</span> ReadFileEx completed<br><span class="hljs-keyword">first</span> ReadFileEx completed<br></code></pre></td></tr></table></figure><p>APC 队列由系统内部维护。系统可以按任何顺序执行排队的 I&#x2F;O 请求，您最后发出的 I&#x2F;O 请求可能最先完成。线程的 APC 队列中的每个条目都包含回调函数的地址和传递给该函数的值。</p><p>当 I&#x2F;O 请求完成时，它们只是简单地排队到线程的 APC 队列，回调例程不会立即调用，因为线程可能正忙于执行其他操作，并且无法中断。要处理线程的 APC 队列中的条目，线程必须将自身置于可警示状态。</p><p>Windows 提供了六个函数，可以将线程置于可警示状态：</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex"><code>SleepEx</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex"><code>WaitForSingleObjectEx</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex"><code>WaitForMultipleObjectsEx</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait"><code>SignalObjectAndWait</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatusex"><code>GetQueuedCompletionStatusEx</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex"><code>MsgWaitForMultipleObjectsEx</code></a></li></ul><p>当您调用这些函数并将线程置于可警示状态时，系统首先会检查线程的 APC 队列。若队列中至少有一个条目，则系统不会使线程睡眠。相反，系统会从 APC 队列中提取条目，并使线程调用回调例程，直到队列没有条目为止。</p><p>在线程的 APC 队列中没有条目时，调用这些函数会使线程挂起。当线程挂起时，如果线程正在等待的内核对象发出信号，或者如果线程队列中出现 APC 条目，那么线程将会唤醒。由于线程处于可警示状态，因此一旦出现 APC 条目，系统就会唤醒线程并清空队列（通过调用回调例程）。然后，这些函数立即返回给调用者 —— 线程不会返回睡眠状态。</p><h4 id="可警示-i-x2f-o-的优缺点"><a href="#可警示-i-x2f-o-的优缺点" class="headerlink" title="可警示 I&#x2F;O 的优缺点"></a>可警示 I&#x2F;O 的优缺点</h4><p>使用可警示 I&#x2F;O 方式来执行设备 I&#x2F;O 有两个可怕的问题：</p><ul><li>回调函数。可警示 I&#x2F;O 要求您创建回调函数，这使得编写代码变得更加困难。因为回调函数通常没有足够的上下文信息，因此您最终会在全局变量中放置大量信息。幸运的是，这些全局变量不需要同步，因为调用六个可警示函数之一的线程与执行回调函数的线程相同。</li><li>线程问题。可警示 I&#x2F;O 真正的大问题是：发出 I&#x2F;O 请求的线程也必须处理完成通知。如果一个线程发出多个请求，则该线程必须响应每个请求的完成通知。由于没有负载平衡，因此应用程序无法很好地伸缩。</li></ul><p>Windows 提供了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc"><code>QueueUserAPC</code></a> 函数，允许您手动将条目排队到线程的 APC 队列。您可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc"><code>QueueUserAPC</code></a> 执行极其高效的线程间通信，甚至可以跨进程边界执行。但不幸的是，您只能传递单个值。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc"><code>QueueUserAPC</code></a> 还可用于强制线程退出等待状态。假设您有一个调用了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex"><code>WaitForSingleObjectEx</code></a> 的线程，其等待内核对象发出信号。在线程等待时，用户希望终止应用程序。您希望线程可以干净地销毁自己，这时候可以利用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc"><code>QueueUserAPC</code></a> 来唤醒线程然后让其销毁自己。以下是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The APC callback function has nothing to do</span><br><span class="hljs-function">VOID WINAPI <span class="hljs-title">APCFunc</span><span class="hljs-params">(ULONG_PTR dwParam)</span> </span>&#123;<br>    <span class="hljs-comment">// Nothing to do in here</span><br>&#125;<br><br><span class="hljs-function">UINT WINAPI <span class="hljs-title">ThreadFunc</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    HANDLE hEvent = (HANDLE) pvParam; <span class="hljs-comment">// Handle is passed to this thread</span><br><br>    <span class="hljs-comment">// Wait in an alertable state so that we can be forced to exit cleanly</span><br>    DWORD dw = <span class="hljs-built_in">WaitForSingleObjectEx</span>(hEvent, INFINITE, TRUE);<br>    <span class="hljs-keyword">if</span> (dw == WAIT_OBJECT_0) &#123;<br>        <span class="hljs-comment">// Object became signaled</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (dw == WAIT_IO_COMPLETION) &#123;<br>        <span class="hljs-comment">// QueueUserAPC forced us out of a wait state</span><br>        <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Thread dies cleanly</span><br>    &#125;<br><br>    ...<br><br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE hEvent = <span class="hljs-built_in">CreateEvent</span>(...);<br>    HANDLE hThread = (HANDLE) _beginthreadex(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ThreadFunc, (PVOID) hEvent, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    ...<br><br>    <span class="hljs-comment">// Force the secondary thread to exit cleanly</span><br>    <span class="hljs-built_in">QueueUserAPC</span>(APCFunc, hThread, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br>    <span class="hljs-built_in">CloseHandle</span>(hThread);<br>    <span class="hljs-built_in">CloseHandle</span>(hEvent);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="iocp"><a href="#iocp" class="headerlink" title="IOCP"></a>IOCP</h3><p>Windows 被设计为一个安全、可靠的操作系统，运行为数千名用户提供服务的应用程序。从历史上看，您已经能够通过遵循以下两个模型之一来构建服务应用程序：</p><ul><li>串行模型 —— 单个线程等待客户端发出请求。当请求传入时，线程将唤醒并处理客户端的请求。</li><li>并发模型 —— 单个线程等待客户端请求，然后创建一个新线程来处理该请求。当新线程处理客户端的请求时，原始线程将循环返回并等待另一个客户端请求。处理客户端请求的线程在完成处理时终止。</li></ul><p>串行模型的问题在于它不能很好地处理多个同时的请求。如果两个客户端同时发出请求，则一次只能处理一个请求，第二个请求必须等待第一个请求完成处理。使用串行模型设计的服务无法利用多处理器计算机。</p><p>由于串行模型的限制，并发模型非常受欢迎。在并发模型中，为每个客户端请求创建一个线程来处理。优点是等待传入请求的线程几乎没有什么工作要做。大多数情况下，此线程处于睡眠状态。当客户端请求传入时，此线程将唤醒，并创建一个新线程来处理该请求，然后等待另一个客户端请求。由于每个客户端请求都有自己的线程，因此服务器应用程序可以很好地伸缩，并且可以轻松地利用多处理器计算机。</p><p>Windows 团队注意到并发模型应用程序性能并没有达到预期的水平。处理大量同时发生的客户端请求意味着会有大量线程在系统中同时运行。由于所有这些线程都是可运行的，Windows 内核将会花费大量时间在线程间的上下文切换上。为了使 Windows 成为一个优秀的服务器环境，Microsoft 设计了 IOCP 内核对象来解决这个问题。</p><h4 id="创建-iocp"><a href="#创建-iocp" class="headerlink" title="创建 IOCP"></a>创建 IOCP</h4><p><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">IOCP</a> 背后的理论是：并发运行的线程数必须有一个上限，即 500 个并发请求不能允许存在 500 个可运行线程。如果一台机器有两个 CPU，那么有两个以上的可运行线程实际上是没有意义的。一旦可运行线程数超过可用的 CPU，系统就必须花时间来执行线程上下文切换，这会浪费宝贵的 CPU 周期，这就是并发模型的潜在缺陷。</p><p>并发模型的另一个缺陷是为每个请求创建一个新线程。与创建进程相比，创建线程的开销很小，但这种开销也是不可忽略的。如果在应用程序初始化时创建一个线程池并且使其中的线程一直存在，则可以提高服务应用程序的性能。IOCP 被设计为与线程池一起配合使用。</p><p>IOCP 可能是最复杂的内核对象。若要创建 IOCP，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-createiocompletionport"><code>CreateIoCompletionPort</code></a>。</p><p>此函数执行了两个任务：创建一个 IOCP；将设备与 IOCP 相关联。为了简化这个函数，可以使用如下两个函数来独立地完成单个任务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateNewCompletionPort</span><span class="hljs-params">(DWORD dwNumberOfConcurrentThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">CreateIoCompletionPort</span>(INVALID_HANDLE_VALUE, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, dwNumberOfConcurrentThreads));<br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">AssociateDeviceWithCompletionPort</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hCompletionPort, HANDLE hDevice, DWORD dwCompletionKey)</span> </span>&#123;<br><br>    HANDLE h = <span class="hljs-built_in">CreateIoCompletionPort</span>(hDevice, hCompletionPort, dwCompletionKey, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span>(h == hCompletionPort);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 IOCP 时，内核实际上会创建五种不同的数据结构，如下图所示：</p><p><img src="/images/the-internal-workings-of-an-iocp.svg" alt="The internal workings of an I/O completion port"></p><p>第一个数据结构是一个设备列表（Device List），指示与 IOCP 关联的一个或多个设备。每次将设备关联到 IOCP 时，系统都会将传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-createiocompletionport"><code>CreateIoCompletionPort</code></a> 函数的设备句柄和完成键等信息追加到 IOCP 的设备列表。</p><p>第二个数据结构是一个 I&#x2F;O 完成队列（I&#x2F;O Completion Queue）。当设备的异步 I&#x2F;O 请求完成时，系统将检查该设备是否与 IOCP 关联，如果是，系统就会将已完成的 I&#x2F;O 请求条目追加到 IOCP 的 I&#x2F;O 完成队列的末尾。此队列中的每个条目都指示已传输的字节数、设备与 IOCP 关联时设置的完成键、指向 I&#x2F;O 请求的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><code>OVERLAPPED</code></a> 结构的指针以及错误码。</p><h4 id="围绕-iocp-进行架构设计"><a href="#围绕-iocp-进行架构设计" class="headerlink" title="围绕 IOCP 进行架构设计"></a>围绕 IOCP 进行架构设计</h4><p>当服务应用程序初始化时，它应通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-createiocompletionport"><code>CreateIoCompletionPort</code></a> 函数来创建 IOCP。然后，它应创建一个线程池来处理客户端请求。</p><p>线程池中的所有线程都应执行相同的函数。通常，线程函数执行某种初始化，然后进入一个循环，当服务进程指示要停止时，该循环应终止。在循环内部，线程应该调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 函数以将自身置于睡眠状态并等待设备 I&#x2F;O 请求完成。 </p><p>与 IOCP 关联的第三个数据结构是一个等待线程队列（Waiting Thread Queue）。当线程池中的线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 时，调用线程的 ID 将入队到此等待线程队列中，从而使 IOCP 内核对象始终知道哪些线程当前正在等待处理已完成的 I&#x2F;O 请求。当一个条目出现在 IOCP 的 I&#x2F;O 完成队列中时，IOCP 将唤醒等待线程队列中的一个线程。</p><p>确定 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 返回的原因有些困难。下面的代码演示了执行此操作的正确方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD dwNumBytes;<br>ULONG_PTR CompletionKey;<br>OVERLAPPED* pOverlapped;<br><br><span class="hljs-comment">// hIOCP is initialized somewhere else in the program</span><br>BOOL bOk = <span class="hljs-built_in">GetQueuedCompletionStatus</span>(hIOCP, &amp;dwNumBytes, &amp;CompletionKey, &amp;pOverlapped, <span class="hljs-number">1000</span>);<br>DWORD dwError = <span class="hljs-built_in">GetLastError</span>();<br><br><span class="hljs-keyword">if</span> (bOk) &#123;<br>    <span class="hljs-comment">// Process a successfully completed I/O request</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (pOverlapped != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// Process a failed completed I/O request</span><br>        <span class="hljs-comment">// dwError contains the reason for failure</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (dwError == WAIT_TIMEOUT) &#123;<br>            <span class="hljs-comment">// Time-out while waiting for completed I/O entry</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Bad call to GetQueuedCompletionStatus</span><br>            <span class="hljs-comment">// dwError contains the reason for the bad call</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条目将以先进先出的方式从 I&#x2F;O 完成队列中删除。但是，调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 的线程将以后进先出的方式唤醒。这样做的原因是为了提高性能。因为如果 I&#x2F;O 请求完成的速度比线程处理 I&#x2F;O 完成条目的速度要慢时，单个线程就足以处理这些 I&#x2F;O 完成条目，系统只需保持同一个线程一直唤醒，而其它线程可以继续睡眠。系统甚至可以将这些未调度线程的内存资源交换到磁盘，并从处理器缓存中刷新。</p><p>在 Windows Vista 中，如果希望不断地提交大量 I&#x2F;O 请求，而不是增加等待 IOCP 的线程数（这将导致上下文切换的开销增加），那么可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatusex"><code>GetQueuedCompletionStatusEx</code></a> 函数同时检索多个 I&#x2F;O 请求的结果。</p><blockquote><p>注：</p><p>当您向与 IOCP 关联的设备发出异步 I&#x2F;O 请求时，Windows 会将结果排队到 IOCP。即使异步请求是同步执行的，也是如此，这时可能会略微地降低性能，因为必须将完成的请求信息放在 IOCP 中，并且线程必须从 IOCP 中提取它。</p><p>若要略微地提高性能，可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfilecompletionnotificationmodes"><code>SetFileCompletionNotificationModes</code></a> 函数来告诉 Windows 不要将同步执行的异步请求排队到与设备关联的 IOCP。</p><p>非常注重性能的程序员可能还需要考虑使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileiooverlappedrange"><code>SetFileIoOverlappedRange</code></a> 函数。</p></blockquote><h4 id="iocp-如何管理线程池"><a href="#iocp-如何管理线程池" class="headerlink" title="IOCP 如何管理线程池"></a>IOCP 如何管理线程池</h4><p>在创建 IOCP 时，需要指定最大并发值。当已完成的 I&#x2F;O 条目入队时，IOCP 需要唤醒正在等待的线程。然而，IOCP 唤醒的线程数不会超过最大并发值。因此，假设您指定了最大并发值为二，那么当四个 I&#x2F;O 请求完成并且有四个线程正在等待对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 的调用时，IOCP 也只允许两个线程唤醒。</p><p>您应该会注意到上述假设中，四个线程中有两个似乎是多余的，它们可能永远不会被唤醒。</p><p>然而 IOCP 是非常智能的。当 IOCP 唤醒线程时，它会将线程的 ID 放置到释放线程列表（Released Thread List）。这允许 IOCP 记住它唤醒了哪些线程，并监视这些线程的执行。如果已释放的线程调用了任何将线程置于等待状态的函数，则 IOCP 会检测到这一点，并通过将线程的 ID 从释放线程列表移动到暂停线程列表（Paused Thread List）来更新其内部数据结构。</p><p>IOCP 的目标是在释放线程列表中保持最大并发值所允许的条目数。如果一个已释放的线程因任何原因进入等待状态，则释放线程列表将收缩，并且 IOCP 将释放另一个等待线程。如果一个已暂停的线程被唤醒，那么它将离开暂停线程列表并重新进入释放线程列表。这意味着释放线程列表中现在可以包含多于最大并发值所允许的条目数。</p><blockquote><p>注：</p><p>一旦线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a>，该线程就会被“分配”到指定的 IOCP。系统假定所有已分配的线程都代表该 IOCP 执行工作。仅当正在运行的已分配线程数小于 IOCP 的最大并发值时，IOCP 才会从线程池中唤醒线程。</p><p>可以通过以下三种方式之一打破 线程&#x2F;IOCP 分配：</p><ul><li>线程退出。</li><li>线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a>，并传递其他 IOCP 的句柄。</li><li>销毁线程当前分配到的 IOCP。</li></ul></blockquote><h4 id="线程池中的线程数"><a href="#线程池中的线程数" class="headerlink" title="线程池中的线程数"></a>线程池中的线程数</h4><p>考虑两个问题。首先，当服务应用程序初始化时，您希望创建一组最少的线程，这样就不必定期创建和销毁线程。请记住，创建和销毁线程会消耗 CPU 时间，因此最好尽可能减少此过程。其次，您希望设置最大线程数，因为创建太多线程会浪费系统资源（如 RAM）。</p><p>您可能希望尝试不同数量的线程。大多数服务（包括 Microsoft Internet Information Services）使用启发式（Heuristic）算法来管理线程池。您可以创建以下变量来管理线程池：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LONG g_nThreadsMin;  <span class="hljs-comment">// Minimum number of threads in pool</span><br>LONG g_nThreadsMax;  <span class="hljs-comment">// Maximum number of threads in pool</span><br>LONG g_nThreadsCrnt; <span class="hljs-comment">// Current number of threads in pool</span><br>LONG g_nThreadsBusy; <span class="hljs-comment">// Number of busy threads in pool</span><br></code></pre></td></tr></table></figure><p>当应用程序初始化时，您可以创建 <code>g_nThreadsMin</code> 数量的线程，所有这些线程都执行相同的线程池函数。以下伪代码展示了此线程函数的大概轮廓：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ThreadPoolFunc</span><span class="hljs-params">(PVOID pv)</span> </span>&#123;<br>    <span class="hljs-comment">// Thread is entering pool</span><br>    <span class="hljs-built_in">InterlockedIncrement</span>(&amp;g_nThreadsCrnt);<br>    <span class="hljs-built_in">InterlockedIncrement</span>(&amp;g_nThreadsBusy);<br><br>    <span class="hljs-keyword">for</span> (BOOL bStayInPool = TRUE; bStayInPool;) &#123;<br>        <span class="hljs-comment">// Thread stops executing and waits for something to do</span><br>        <span class="hljs-built_in">InterlockedDecrement</span>(&amp;m_nThreadsBusy);<br>        BOOL bOk = <span class="hljs-built_in">GetQueuedCompletionStatus</span>(...);<br>        DWORD dwIOError = <span class="hljs-built_in">GetLastError</span>();<br><br>        <span class="hljs-comment">// Thread has something to do, so it&#x27;s busy</span><br>        <span class="hljs-type">int</span> nThreadsBusy = <span class="hljs-built_in">InterlockedIncrement</span>(&amp;m_nThreadsBusy);<br><br>        <span class="hljs-comment">// Should we add another thread to the pool?</span><br>        <span class="hljs-keyword">if</span> (nThreadsBusy == m_nThreadsCrnt) &#123; <span class="hljs-comment">// All threads are busy</span><br>            <span class="hljs-keyword">if</span> (nThreadsBusy &lt; m_nThreadsMax) &#123; <span class="hljs-comment">// The pool isn&#x27;t full</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetCPUUsage</span>() &lt; <span class="hljs-number">75</span>) &#123; <span class="hljs-comment">// CPU usage is below 75%</span><br>                    <span class="hljs-comment">// Add thread to pool</span><br>                    <span class="hljs-built_in">CloseHandle</span>(<span class="hljs-built_in">chBEGINTHREADEX</span>(...));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!bOk &amp;&amp; (dwIOError == WAIT_TIMEOUT)) &#123; <span class="hljs-comment">// Thread timed out</span><br>            <span class="hljs-comment">// There isn&#x27;t much for the server to do, and this thread</span><br>            <span class="hljs-comment">// can die even if it still has outstanding I/O requests</span><br>            bStayInPool = FALSE;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bOk || (po != <span class="hljs-literal">NULL</span>)) &#123;<br>            <span class="hljs-comment">// Thread woke to process something; process it</span><br>            ...<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetCPUUsage</span>() &gt; <span class="hljs-number">90</span>) &#123; <span class="hljs-comment">// CPU usage is above 90%</span><br>                <span class="hljs-keyword">if</span> (g_nThreadsCrnt &gt; g_nThreadsMin)) &#123; <span class="hljs-comment">// Pool above min</span><br>                    bStayInPool = FALSE; <span class="hljs-comment">// Remove thread from pool</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Thread is leaving pool</span><br>    <span class="hljs-built_in">InterlockedDecrement</span>(&amp;g_nThreadsBusy);<br>    <span class="hljs-built_in">InterlockedDecrement</span>(&amp;g_nThreadsCurrent);<br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模拟已完成的-i-x2f-o-请求"><a href="#模拟已完成的-i-x2f-o-请求" class="headerlink" title="模拟已完成的 I&#x2F;O 请求"></a>模拟已完成的 I&#x2F;O 请求</h4><p>IOCP 不一定要与设备 I&#x2F;O 一起使用，它还可以用于线程间通信。在 <a href="#%E5%8F%AF%E8%AD%A6%E7%A4%BA-i-o-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">可警示 I&#x2F;O 的优缺点</a> 中提到的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc"><code>QueueUserAPC</code></a> 函数允许一个线程将 APC 条目发布到另一个线程。IOCP 也具有类似的函数 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/postqueuedcompletionstatus"><code>PostQueuedCompletionStatus</code></a>。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/postqueuedcompletionstatus"><code>PostQueuedCompletionStatus</code></a> 函数非常有用，它为您提供了一种与线程池中的所有线程进行通信的方法。例如，当用户终止服务应用程序时，您希望所有线程都干净地退出。但是，如果线程正在等待 IOCP，并且没有 I&#x2F;O 请求传入，那么线程将无法唤醒。通过为线程池中的每个线程调用一次 <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/postqueuedcompletionstatus"><code>PostQueuedCompletionStatus</code></a>，可以使这些线程唤醒，被唤醒的线程应当检查从 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 返回的值以获知服务应用程序是否正在终止，并相应地清理和退出。</p><p>在 Windows Vista 中，当您调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 关闭 IOCP 时，所有因调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 而正在等待的线程都将唤醒，<a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 函数将返回 <code>FALSE</code>。这些线程随后调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><code>GetLastError</code></a> 将返回 <code>ERROR_INVALID_HANDLE</code>。可以利用这个信息来干净地销毁线程。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Thread Synchronization with Kernel Objects</title>
    <link href="/2022/02/23/windows-via-c-cpp-5th-thread-synchronization-with-kernel-objects/"/>
    <url>/2022/02/23/windows-via-c-cpp-5th-thread-synchronization-with-kernel-objects/</url>
    
    <content type="html"><![CDATA[<p>用户模式同步的优点在于它非常的快，如果需要强调线程的性能，那么应该首先考虑使用用户模式线程同步机制。尽管用户模式线程同步机制提供了出色的性能，但它们都有一些局限性（如互锁的函数族仅对单个值进行操作）。实际上，内核对象机制比用户模式机制更通用，唯一的不足是性能不如用户模式机制。使用内核对象机制时，调用线程必须从用户模式切换到内核模式，这种切换开销很大（在 x86 平台上，一个空系统调用大约需要 200 个 CPU 周期）。</p><p>几乎可以将所有的内核对象用于同步。对于线程同步而言，这些内核对象都处于 <em>已示意（Signaled）</em> 或 <em>未示意（Nonsignaled）</em> 状态。状态的切换由 Microsoft 为每个对象创建的规则确定。例如，进程内核对象始终以未示意状态创建。当进程终止时，操作系统会自动地使进程内核对象处于已示意状态。一旦进程内核对象已示意，它就会永远保持这种状态（其状态永远不会变回未示意）。如果希望检查一个进程是否仍在运行，那么仅仅需要调用一个函数以请求操作系统检查进程对应的进程内核对象是否已示意即可。</p><p>以下内核对象均可处于已示意或未示意状态：</p><ul><li>进程（Process）</li><li>线程（Thread）</li><li>作业（Job）</li><li>文件和控制台标准输入&#x2F;输出&#x2F;错误流（File and console standard input&#x2F;output&#x2F;error streams）</li><li>事件（Event）</li><li>可等待定时器（Waitable timer）</li><li>信号量（Semaphore）</li><li>互斥量（Mutex）</li></ul><p>线程可以将自身置于等待状态，以等待某个内核对象变为已示意。当线程正在等待的对象未示意时，线程是不可调度的；一旦等待的对象已示意，线程就会观察到这一变化从而变为可调度的，并且很快恢复执行。</p><h2 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h2><p><em>等待函数（Wait Functions）</em> 使线程自愿地将自己置于等待状态，直到特定的内核对象变为已示意。如果在调用等待函数时内核对象已示意，那么线程不会进入等待状态。</p><p>最常用的等待函数是 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a>。如下是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD dw = <span class="hljs-built_in">WaitForSingleObject</span>(hProcess, <span class="hljs-number">5000</span>);<br><span class="hljs-keyword">switch</span> (dw) &#123;<br><span class="hljs-keyword">case</span> WAIT_OBJECT_0:<br>    <span class="hljs-comment">// The process terminated.</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_TIMEOUT:<br>    <span class="hljs-comment">// The process did not terminate within 5000 milliseconds.</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_FAILED:<br>    <span class="hljs-comment">// Bad call to function (invalid handle?)</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> 与 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 类似，但它允许调用线程同时检查多个内核对象的示意状态。如下是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE h[<span class="hljs-number">3</span>];<br>h[<span class="hljs-number">0</span>] = hProcess1;<br>h[<span class="hljs-number">1</span>] = hProcess2;<br>h[<span class="hljs-number">2</span>] = hProcess3;<br>DWORD dw = <span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">3</span>, h, FALSE, <span class="hljs-number">5000</span>);<br><span class="hljs-keyword">switch</span> (dw) &#123;<br><span class="hljs-keyword">case</span> WAIT_FAILED:<br>    <span class="hljs-comment">// Bad call to function (invalid handle?)</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_TIMEOUT:<br>    <span class="hljs-comment">// None of the objects became signaled within 5000 milliseconds.</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_OBJECT_0 + <span class="hljs-number">0</span>:<br>    <span class="hljs-comment">// The process identified by h[0] (hProcess1) terminated.</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_OBJECT_0 + <span class="hljs-number">1</span>:<br>    <span class="hljs-comment">// The process identified by h[1] (hProcess2) terminated.</span><br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> WAIT_OBJECT_0 + <span class="hljs-number">2</span>:<br>    <span class="hljs-comment">// The process identified by h[2] (hProcess3) terminated.</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成功等待的副作用"><a href="#成功等待的副作用" class="headerlink" title="成功等待的副作用"></a>成功等待的副作用</h3><p>对于某些内核对象，成功地调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> 实际上会改变对象的状态。</p><p>当使一个对象的状态改变时，称之为 <em>成功等待的副作用（Successful Wait Side Effect）</em> 。例如，假设一个线程正在等待一个自动重置事件对象。当事件对象变为已示意时，等待函数会检测到这一点，并可以将 <code>WAIT_OBJECT_0</code> 返回给调用线程。然而，在函数返回之前，事件会被设置为未示意状态，这就是成功等待的副作用。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> 以原子方式执行其所有操作（这防止了死锁的情况）。当线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> 时，该函数可以测试所有对象的示意状态，并将所需的所有副作用作为单个操作执行。例如，两个线程以完全相同的方式调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE h[<span class="hljs-number">2</span>];<br>h[<span class="hljs-number">0</span>] = hAutoResetEvent1; <span class="hljs-comment">// Initially nonsignaled</span><br>h[<span class="hljs-number">1</span>] = hAutoResetEvent2; <span class="hljs-comment">// Initially nonsignaled</span><br><span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h, TRUE, INFINITE);<br></code></pre></td></tr></table></figure><p>当调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> 时，两个事件对象都是未示意的，这将强制两个线程都进入等待状态。随后 <code>hAutoResetEvent1</code> 对象变为已示意。两个线程都观察到该事件已示意，但两者都不会唤醒，因为 <code>hAutoResetEvent2</code> 对象仍为未示意。由于两个线程都尚未成功等待，因此在 <code>hAutoResetEvent1</code> 对象上不会发生任何副作用。</p><p>接着，<code>hAutoResetEvent2</code> 对象变为已示意。此时，两个线程中的一个会检测到它正在等待的两个对象都已示意，该线程等待成功，两个事件对象都会被设置为非示意状态，并且该线程变为可调度的；另一个线程将继续等待，直到它看到两个事件对象都已示意为止（尽管它最初检测到 <code>hAutoResetEvent1</code> 已示意，但现在它将观察到该对象是未示意的）。</p><blockquote><p>注：Microsoft 官方表示在多个线程等待单个内核对象的场景下，当对象变成已示意时通过一个公平的算法来选择要唤醒的线程。</p></blockquote><h2 id="事件内核对象"><a href="#事件内核对象" class="headerlink" title="事件内核对象"></a>事件内核对象</h2><p>在所有内核对象中，事件是最原始的。它们包含一个使用计数、一个指示事件是自动重置（Auto-reset）事件还是手动重置（Manual-reset）事件的布尔值，以及一个指示事件是已示意的还是未示意的的布尔值。</p><p>事件表示一个操作已完成。有两种不同类型的事件对象：手动重置事件和自动重置事件。当手动重置事件已示意时，等待该事件的所有线程将变为可调度的；当自动重置事件已示意时，等待该事件的所有线程中只有一个线程变为可调度的。</p><p>使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventw"><code>CreateEvent</code></a> 函数可以创建一个事件内核对象。Windows Vista 提供了一个新的函数 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventexw"><code>CreateEventEx</code></a> 用于创建事件。</p><p>其他进程中的线程可以通过使用相同的事件对象名字来调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventw"><code>CreateEvent</code></a> 以访问同一个对象。或者，也可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openeventw"><code>OpenEvent</code></a> 来实现类似的效果。</p><p>与往常一样，当不再需要事件内核对象时，应调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 函数。</p><p>创建事件后，可以直接控制其状态。调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent"><code>SetEvent</code></a> 会将事件更改为已示意状态；而调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent"><code>ResetEvent</code></a> 则会将事件更改为未示意状态。</p><p>Microsoft 为自动重置事件定义了成功等待的副作用规则：当线程成功等待对象时，自动重置事件将自动重置为未示意状态。Microsoft 没有为手动重置事件定义成功等待的副作用。</p><p>当多个线程等待同一个事件对象时，若该事件对象是一个手动重置事件，则所有等待线程会被唤醒；若该事件对象是一个自动重置事件，则只有其中一个等待线程会被唤醒。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-pulseevent"><code>PulseEvent</code></a> 使事件变为已示意然后立即变为非示意，就像在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent"><code>SetEvent</code></a> 后立即调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-resetevent"><code>ResetEvent</code></a> 一样。此函数并不可靠，因此很少会使用它，保留它仅是为了向后兼容。</p><h2 id="可等待定时器内核对象"><a href="#可等待定时器内核对象" class="headerlink" title="可等待定时器内核对象"></a>可等待定时器内核对象</h2><p>可等待定时器是在特定时间或定期间隔发出信号的内核对象，最常用于在特定时间执行某些操作。</p><p>要创建可等待定时器，只需简单地调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw"><code>CreateWaitableTimer</code></a>。</p><p>进程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw"><code>OpenWaitableTimer</code></a> 来获取其现有的可等待定时器的进程相关句柄。</p><p>与事件一样，可等待定时器分为手动重置定时器和自动重置定时器。当手动重置定时器已示意时，所有等待定时器的线程将变为可调度的；当自动重置定时器已示意时，只有一个等待线程变为可调度的。</p><p>可等待定时器对象始终以未示意状态创建。必须调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer"><code>SetWaitableTimer</code></a> 函数以告诉定时器何时应变为已示意的。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer"><code>CancelWaitableTimer</code></a> 函数用于将指定的可等待定时器设置为非活动状态。</p><h3 id="让可等待定时器对-apc-条目进行排队"><a href="#让可等待定时器对-apc-条目进行排队" class="headerlink" title="让可等待定时器对 APC 条目进行排队"></a>让可等待定时器对 APC 条目进行排队</h3><p>Microsoft 允许定时器将一个 APC（Asynchronous Procedure Call）排队到一个线程，该线程在定时器已示意时调用了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer"><code>SetWaitableTimer</code></a>。</p><p>当且仅当调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer"><code>SetWaitableTimer</code></a> 的线程处于 <em>可警示（Alertable）</em> 状态时，定时器 APC 例程才会在定时器响起时由调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer"><code>SetWaitableTimer</code></a> 的同一个线程调用。换句话说，该线程必须在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex"><code>SleepEx</code></a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex"><code>WaitForSingleObjectEx</code></a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex"><code>WaitForMultipleObjectsEx</code></a>、<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex"><code>MsgWaitForMultipleObjectsEx</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait"><code>SignalObjectAndWait</code></a> 中等待。如果线程未在这些函数之一中等待，那么系统不会将定时器 APC 例程入队。这可以防止线程的 APC 队列因定时器 APC 通知而过载，从而浪费系统内的大量内存。</p><p>如果线程在定时器响起时处于可警示的等待状态，那么系统会使线程调用回调例程。只有在处理完所有 APC 条目后，才会从可警示函数中返回。因此，必须确保定时器 APC 例程函数在定时器再次发出信号之前完成执行，以便 APC 条目的入队速度不会快于其处理速度。</p><p>以下代码展示了使用定时器和 APC 的正确方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create a timer. (It doesn&#x27;t matter whether it&#x27;s manual-reset or auto-reset.)</span><br>    HANDLE hTimer = <span class="hljs-built_in">CreateWaitableTimer</span>(<span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Set timer to go off in 5 seconds.</span><br>    LARGE_INTEGER li = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">SetWaitableTimer</span>(hTimer, &amp;li, <span class="hljs-number">5000</span>, TimerAPCRoutine, <span class="hljs-literal">NULL</span>, FALSE);<br><br>    <span class="hljs-comment">// Wait in an alertable state for the timer to go off.</span><br>    <span class="hljs-built_in">SleepEx</span>(INFINITE, TRUE);<br><br>    <span class="hljs-built_in">CloseHandle</span>(hTimer);<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意的是，线程不应该等待定时器的句柄，也不应该警示地等待定时器，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hTimer = <span class="hljs-built_in">CreateWaitableTimer</span>(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">SetWaitableTimer</span>(hTimer, ..., TimerAPCRoutine,...);<br><span class="hljs-built_in">WaitForSingleObjectEx</span>(hTimer, INFINITE, TRUE);<br></code></pre></td></tr></table></figure><p>您不应该编写这样的代码，因为对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex"><code>WaitForSingleObjectEx</code></a> 的调用实际上等待了定时器两次：警示地等待和等待内核对象句柄。当定时器变为已示意时，等待成功，线程唤醒，这会使线程退出可警示状态，并且不会调用 APC 例程。</p><h2 id="信号量内核对象"><a href="#信号量内核对象" class="headerlink" title="信号量内核对象"></a>信号量内核对象</h2><p>信号量内核对象用于资源计数。除了使用计数外，其还包含两个额外的带符号的 32 位值：最大资源计数和当前资源计数。最大资源计数标识信号量可以控制的最大资源数，当前资源计数指示当前可用的这些资源的数量。</p><p>信号量的规则如下：</p><ul><li>若当前资源计数大于 0，则信号量为已示意。</li><li>若当前资源计数为 0，则信号量为未示意。</li><li>系统绝不允许当前资源计数为负数。</li><li>当前资源计数不能大于最大资源计数。</li></ul><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createsemaphorew"><code>CreateSemaphore</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createsemaphoreexw"><code>CreateSemaphoreEx</code></a> 函数用于创建一个信号量内核对象。<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew"><code>OpenSemaphore</code></a> 函数用于获取一个现存的信号量的进程相关句柄。</p><p>线程通过调用等待函数来获取对资源的访问权限。等待函数会检查信号量的当前资源计数：</p><ul><li>如果其值大于 0（信号量已示意），那么计数器将递减 1，并且调用线程保持可调度状态。</li><li>如果其值为 0（信号量未示意），那么系统会将调用线程置于等待状态。当其它线程递增信号量的当前资源计数时，系统会选择等待该信号量的其中一个线程并允许其变为可调度。相应地，系统会递减当前资源计数。</li></ul><blockquote><p>注：这些对信号量的测试和设置操作是以原子方式执行的，即当从信号量请求资源时，操作系统会检查该资源是否可用，并在不让其他线程干扰的情况下递减可用资源的计数。只有在资源计数递减后，系统才会允许另一个线程请求访问资源。</p></blockquote><p>线程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore"><code>ReleaseSemaphore</code></a> 来递增信号量的当前资源计数。</p><h2 id="互斥量内核对象"><a href="#互斥量内核对象" class="headerlink" title="互斥量内核对象"></a>互斥量内核对象</h2><p>互斥量内核对象确保线程对单个资源具有互斥访问权限。互斥量对象包含使用计数、线程 ID 和递归计数器。互斥量的行为与临界区段相同，但是互斥量是内核对象，而临界区段是用户模式同步对象。这意味着互斥量比临界区段慢，但也意味着不同进程中的线程可以访问单个互斥量，并且线程可以在等待访问资源时指定超时值。</p><p>线程 ID 用于标识系统中当前拥有互斥量的线程，递归计数器指示此线程拥有互斥量的次数。</p><p>互斥量的规则如下：</p><ul><li>若线程 ID 为 0（无效的线程 ID），则互斥量不归任何线程所有并且互斥量为已示意的。</li><li>若线程 ID 为非零值，则对应的线程拥有互斥量并且互斥量为未示意的。</li><li>与所有其他内核对象不同，互斥量在操作系统中具有允许它们违反正常规则的特殊代码。</li></ul><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexw"><code>CreateMutex</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createmutexexw"><code>CreateMutexEx</code></a> 函数用于创建一个互斥量。<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-openmutexw"><code>OpenMutex</code></a> 函数用于获取一个现存的互斥量的进程相关句柄。</p><p>线程通过调用等待函数来获取对共享资源的访问权限。等待函数会检查互斥量的线程 ID：</p><ul><li>如果线程 ID 为 0（互斥量已示意），那么线程 ID 设置为调用线程的 ID，递归计数器设置为 1，并且调用线程保持可调度状态。</li><li>如果线程 ID 不为 0（互斥量未示意），那么调用线程将进入等待状态。当互斥量的线程 ID 设置回 0 时，系统会选择等待该互斥量的其中一个线程，并且将线程 ID 设置为该线程的 ID，将递归计数器设置为 1，允许该线程变为可调度。</li></ul><blockquote><p>注：这些对互斥量内核对象的检查和更改是以原子方式执行的。</p></blockquote><p>互斥量在正常的内核对象已示意&#x2F;未示意规则下有一个特殊的例外。假设一个线程尝试等待一个未示意的互斥量对象。在这种情况下，该线程通常处于一个等待状态。然而，系统会检查尝试获取互斥量的线程是否具有与互斥量对象中记录的线程 ID 相同的线程 ID。如果线程 ID 匹配，那么即使互斥量是未示意的，系统也会允许该线程保持可调度状态。</p><p>线程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasemutex"><code>ReleaseMutex</code></a> 来递减互斥量的递归计数器。当互斥量的递归计数器递减为 0 时，其线程 ID 也会被设置为 0，并且该互斥量会变为已示意的。</p><h3 id="遗弃问题"><a href="#遗弃问题" class="headerlink" title="遗弃问题"></a>遗弃问题</h3><p>与其他内核对象不同，互斥量对象具有“线程所有权”的概念。其他内核对象不会记住哪个线程成功地等待了它，只有互斥量会跟踪这一点。如果拥有互斥量的线程在释放互斥量之前终止，那么系统会认为该互斥量是被遗弃的。</p><p>由于系统跟踪所有互斥量内核对象和线程内核对象，因此它确切地知道互斥量何时被放弃。当互斥量被遗弃时，系统会自动将互斥量对象的线程 ID 重置为 0，并将其递归计数器重置为 0。然后，系统会检查当前是否有任何线程正在等待该互斥量。若是，则系统会“公平地”选择一个等待线程。</p><h3 id="互斥量-vs-临界区段"><a href="#互斥量-vs-临界区段" class="headerlink" title="互斥量 vs 临界区段"></a>互斥量 vs 临界区段</h3><table><thead><tr><th align="left">Characteristic</th><th align="left">Mutex</th><th align="left">Critical Section</th></tr></thead><tbody><tr><td align="left">Performance</td><td align="left">Slow</td><td align="left">Fast</td></tr><tr><td align="left">Can be used across process boundaries</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Declaration</td><td align="left"><code>HANDLE hmtx;</code></td><td align="left"><code>CRITICAL_SECTION cs;</code></td></tr><tr><td align="left">Initialization</td><td align="left"><code>hmtx = CreateMutex (NULL, FALSE, NULL);</code></td><td align="left"><code>InitializeCriticalSection(&amp;cs);</code></td></tr><tr><td align="left">Cleanup</td><td align="left"><code>CloseHandle(hmtx);</code></td><td align="left"><code>DeleteCriticalSection(&amp;cs);</code></td></tr><tr><td align="left">Infinite wait</td><td align="left"><code>WaitForSingleObject (hmtx, INFINITE);</code></td><td align="left"><code>EnterCriticalSection(&amp;cs);</code></td></tr><tr><td align="left">0 wait</td><td align="left"><code>WaitForSingleObject (hmtx, 0);</code></td><td align="left"><code>TryEnterCriticalSection(&amp;cs);</code></td></tr><tr><td align="left">Arbitrary wait</td><td align="left"><code>WaitForSingleObject (hmtx, dwMilliseconds);</code></td><td align="left">Not possible</td></tr><tr><td align="left">Release</td><td align="left"><code>ReleaseMutex(hmtx);</code></td><td align="left"><code>LeaveCriticalSection(&amp;cs);</code></td></tr><tr><td align="left">Can be waited on with other kernel objects</td><td align="left">Yes (use <code>WaitForMultipleObjects</code> or similar function)</td><td align="left">No</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Thread Synchronization in User Mode</title>
    <link href="/2022/02/18/windows-via-c-cpp-5th-thread-synchronization-in-user-mode/"/>
    <url>/2022/02/18/windows-via-c-cpp-5th-thread-synchronization-in-user-mode/</url>
    
    <content type="html"><![CDATA[<p>线程需要如下两种情况下进行同步：</p><ul><li>当有多个线程访问共享资源而不使资源被破坏时。</li><li>当一个线程需要通知一个或多个其他线程特定任务已完成时。</li></ul><h2 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h2><p>线程同步的很大一部分与原子访问（Atomic Access）相关，即线程访问一个资源并保证没有其他线程同时访问同一资源的能力。</p><p>Windows 提供了<a href="https://docs.microsoft.com/en-us/windows/win32/sync/synchronization-functions#interlocked-functions">互锁（Interlocked）函数族</a>，这些函数允许以原子操作方式对一个值进行操作，如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchangeadd"><code>InterlockedExchangeAdd</code></a> 函数。</p><p>互锁函数执行速度是非常快的，通常执行只需要很少的（通常小于 50 个）CPU 周期，并且不会从用户模式切换到内核模式（通常需要超过 1000 个 CPU 周期）。</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchange"><code>InterlockedExchange</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchangepointer"><code>InterlockedExchangePointer</code></a> 以原子方式将第一个指针参数所指向位置的当前值替换为第二个参数的值，并返回第一个指针参数所指向位置的原始值。<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchange"><code>InterlockedExchange</code></a> 在实现自旋锁（Spinlock）时非常有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Global variable indicating whether a shared resource is in use or not</span><br>BOOL g_fResourceInUse = FALSE; ...<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Wait to access the resource.</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">InterlockedExchange</span>(&amp;g_fResourceInUse, TRUE) == TRUE)<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Access the resource.</span><br>    ...<br><br>    <span class="hljs-comment">// We no longer need to access the resource.</span><br>    <span class="hljs-built_in">InterlockedExchange</span>(&amp;g_fResourceInUse, FALSE);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 循环反复旋转，将 <code>g_fResourceInUse</code> 中的值更改为 <code>TRUE</code>，并检查其原先的值是否为 <code>TRUE</code>。如果该值为 <code>FALSE</code>，则表示资源不是“使用中”，但调用线程只是将其设置为“使用中”并退出循环；如果该值为 <code>TRUE</code>，则表示资源正由另一个线程“使用中”，并且 <code>while</code> 循环继续旋转。</p><p>如果另一个线程执行类似的代码，它将在其 <code>while</code> 循环中旋转，直到 <code>g_fResourceInUse</code> 变回 <code>FALSE</code>。函数末尾调用了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-interlockedexchange"><code>InterlockedExchange</code></a> 以将 <code>g_fResourceInUse</code> 设置回 <code>FALSE</code>。</p><p>使用此技术时必须格外小心，因为自旋锁会浪费 CPU 时间。CPU 必须不断比较两个值，直到一个值因另一个线程“神奇地”更改。此代码还假定使用自旋锁的所有线程都在同一优先级运行。</p><p>此外，还应确保锁变量和锁保护的数据在不同的缓存行中维护。如果锁变量和数据共享同一缓存行，则使用该资源的 CPU 将与任何尝试访问该资源的 CPU 争用，这会损害性能。</p><p>应避免在单 CPU 的机器上使用自旋锁。如果一个线程正在旋转，那么它会浪费宝贵的 CPU 时间，还妨碍了其他线程更改该值。在前面展示的 <code>while</code> 循环中使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 可在一定程度上改善这种情况。如果您使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a>，那么您可能希望睡眠一个随机的时间，并且每次访问资源的请求被拒绝时，您可能希望进一步增加睡眠时间。这可以防止线程简单地浪费 CPU 时间。根据具体情况，最好是完全删除对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 的调用；或者将其替换为对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 的调用。</p><p>自旋锁假定始终能在短时间内访问受保护的资源，这使得它比旋转然后切换到内核模式并等待更有效。许多开发者会旋转一定次数（如 4000 次），如果仍然拒绝访问资源，那么就将线程切换到内核模式并等待（不消耗 CPU 时间），直到资源变为可用。</p><p>自旋锁在多 CPU 的机器上很有用，因为一个线程可以在一个 CPU 上旋转，而另一个线程在另一个 CPU 上运行。即便如此，也必须小心地使用自旋锁。</p><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>如果要构建在多处理器计算机上运行的高性能应用程序，那么必须了解 CPU 缓存行（Cache Lines）。当 CPU 从内存中读取一个字节时，它不仅会获取单个字节，还会提取足够的字节来填充缓存行。缓存行由 32 个字节（对于较旧的 CPU）、64 个字节甚至 128 个字节（取决于 CPU）组成，并且它们始终分别地在 32 字节、64 字节或 128 字节边界上对齐。缓存行的存在是为了提高性能。通常，应用程序会操作一组相邻的字节。如果这些字节在缓存中，则 CPU 不必访问内存总线。</p><p>但是，在多处理器环境中，缓存行会使得内存更新变得更加困难，如以下示例所示：</p><ol><li>CPU1 读取一个字节，导致该字节及其相邻字节被读入 CPU1 的缓存行。</li><li>CPU2 读取相同的字节，这导致步骤 1 中的相同字节被读入 CPU2 的缓存行。</li><li>CPU1 更改内存中的字节，导致该字节被写入到 CPU1 的缓存行。但该信息尚未被写入到 RAM。</li><li>CPU2 再次读取相同的字节。由于此字节已位于 CPU2 的缓存行中，因此它不必访问内存。但是 CPU2 不会在内存中看到该字节的新值。</li></ol><p>这种情况将是灾难性的。当然，芯片设计人员很清楚这个问题，并在设计 CPU 时处理这个问题。具体而言，当 CPU 更改缓存行中的字节时，计算机中的其他 CPU 会意识到这一点，并且其缓存行将失效。因此，在刚刚展示的示例中，当 CPU1 更改字节的值时，CPU2 的缓存将失效。在步骤 4 中，CPU1 必须将其缓存刷新到 RAM，而 CPU2 必须再次访问内存以重新填充其缓存行。缓存行可以帮助提高性能，但它们也可能对多处理器计算机造成不利影响。</p><p>这一切意味着，您应该将应用程序的数据分组到缓存行中（大小块和缓存行边界）。目的是确保不同的 CPU 访问由至少一个缓存行边界分隔的不同的内存地址。此外，您应该将只读数据（或不经常读取的数据）与读写数据分开。并且，您应该将大概率会同时访问的数据片段组合在一起。</p><p>下面是一个设计不佳的数据结构示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CUSTINFO</span> &#123;<br>    DWORD dwCustomerID;       <span class="hljs-comment">// Mostly read-only</span><br>    <span class="hljs-type">int</span> nBalanceDue;          <span class="hljs-comment">// Read-write</span><br>    <span class="hljs-type">wchar_t</span> szName[<span class="hljs-number">100</span>];      <span class="hljs-comment">// Mostly read-only</span><br>    FILETIME ftLastOrderDate; <span class="hljs-comment">// Read-write</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>确定 CPU 的缓存行大小的最简单方法是调用 Win32 的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation"><code>GetLogicalProcessorInformation</code></a> 函数。此函数返回 <code>SYSTEM_LOGICAL_PROCESSOR_INFORMATION</code> 结构的数组。您可以检查结构的 <code>Cache</code> 字段，该字段引用了一个 <code>CACHE_DESCRIPTOR</code> 结构，其中包含指示 CPU 缓存行大小的 <code>LineSize</code> 字段。获得此信息后，可以使用 C&#x2F;C++ 编译器的 <a href="https://docs.microsoft.com/en-us/cpp/cpp/align-cpp"><code>__declspec(align(#))</code></a> 指令来控制字段对齐。以下是此数据结构的改进版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CACHE_ALIGN 64</span><br><br><span class="hljs-comment">// Force each structure to be in a different cache line.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__declspec</span>(<span class="hljs-built_in">align</span>(CACHE_ALIGN)) CUSTINFO &#123;<br>    DWORD dwCustomerID;  <span class="hljs-comment">// Mostly read-only</span><br>    <span class="hljs-type">wchar_t</span> szName[<span class="hljs-number">100</span>]; <span class="hljs-comment">// Mostly read-only</span><br><br>    <span class="hljs-comment">// Force the following members to be in a different cache line.</span><br>    __declspec(<span class="hljs-built_in">align</span>(CACHE_ALIGN))<br>    <span class="hljs-type">int</span> nBalanceDue;          <span class="hljs-comment">// Read-write</span><br>    FILETIME ftLastOrderDate; <span class="hljs-comment">// Read-write</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注：最好始终由单个线程访问数据（函数参数和局部变量是确保这一点的最简单方法），或者始终由单个 CPU 访问数据（使用线程亲和性）。这样的话，可以完全避免缓存行问题。</p></blockquote><h2 id="高级线程同步"><a href="#高级线程同步" class="headerlink" title="高级线程同步"></a>高级线程同步</h2><p>当线程想要访问共享资源或收到某些“特殊事件”的通知时，该线程必须调用操作系统函数，并向其传递参数以指示线程正在等待什么。如果操作系统检测到资源可用或发生了特殊事件，则该函数将返回，并且线程保持可调度状态。如果资源不可用或特殊事件尚未发生，系统会将线程置于等待状态，从而使线程不可调度，这可以防止线程浪费任何 CPU 时间。当线程正在等待时，系统将为线程充当代理。系统会记住线程想要什么，并在资源变为可用时（线程的执行与特殊事件同步）自动地使线程退出等待状态。</p><p>事实上，大多数线程几乎总是处于等待状态。当系统检测到所有线程处于等待状态几分钟后，系统的电源管理就会开始起效。</p><h3 id="要避免的技术"><a href="#要避免的技术" class="headerlink" title="要避免的技术"></a>要避免的技术</h3><p>如果没有同步对象并且操作系统没有监视特殊事件的能力，线程将被迫使用如下的技术将自己与特殊事件同步。然而，如果操作系统具有对线程同步的内置支持，则切勿使用此技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> BOOL g_fFinishedCalculation = FALSE;<br><br><span class="hljs-type">int</span> WINAPI _tWinMain(...) &#123;<br>    <span class="hljs-built_in">CreateThread</span>(..., RecalcFunc, ...);<br>    ...<br>    <span class="hljs-comment">// Wait for the recalculation to complete.</span><br>    <span class="hljs-keyword">while</span> (!g_fFinishedCalculation)<br>        ;<br>    ...<br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">RecalcFunc</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    <span class="hljs-comment">// Perform the recalculation.</span><br>    ...<br>    g_fFinishedCalculation = TRUE;<br><br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在此技术中，一个线程通过连续轮询由多个线程共享或可访问的变量的状态，将自身与另一个线程中任务的完成同步。</p><blockquote><p>注：此处需要使用 <code>volatile</code> 类型限定符。这告诉编译器，变量可以被应用程序本身之外的东西（如操作系统、硬件或并发执行的线程）修改。</p></blockquote><h2 id="临界区段"><a href="#临界区段" class="headerlink" title="临界区段"></a>临界区段</h2><p>一个 <em>临界区段（Critical Section）</em> 是代码的一个小部分，其需要对某些共享资源进行独占访问。这是一种让数行代码“原子”操作资源的方法。“原子”意味着在一个线程离开临界区段之前，其他线程不能进入该临界区段。</p><p>以下是一段有问题的代码，演示了不使用临界区段会发生什么情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> COUNT = <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> g_nSum = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">FirstThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    g_nSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; n &lt;= COUNT; n++) &#123;<br>        g_nSum += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span>(g_nSum);<br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SecondThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    g_nSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; n &lt;= COUNT; n++) &#123;<br>        g_nSum += n;<br>    &#125;<br>    <span class="hljs-keyword">return</span>(g_nSum);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于两个线程都访问共享变量（<code>g_nSum</code>），因此如果两个线程同时执行（可能在不同的 CPU 上），则每个线程都会在另一个线程的后面修改 <code>g_nSum</code>，从而导致不可预知的结果。</p><p>现在使用临界区段更正代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> COUNT = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_nSum = <span class="hljs-number">0</span>;<br>CRITICAL_SECTION g_cs;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">FirstThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    <span class="hljs-built_in">EnterCriticalSection</span>(&amp;g_cs);<br>    g_nSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; n &lt;= COUNT; n++) &#123;<br>        g_nSum += n;<br>    &#125;<br>    <span class="hljs-built_in">LeaveCriticalSection</span>(&amp;g_cs);<br>    <span class="hljs-keyword">return</span>(g_nSum);<br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">SecondThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    <span class="hljs-built_in">EnterCriticalSection</span>(&amp;g_cs);<br>    g_nSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; n &lt;= COUNT; n++) &#123;<br>        g_nSum += n;<br>    &#125;<br>    <span class="hljs-built_in">LeaveCriticalSection</span>(&amp;g_cs);<br>    <span class="hljs-keyword">return</span>(g_nSum);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先分配了一个 <code>CRITICAL_SECTION</code> 数据结构 <code>g_cs</code>，然后将任何涉及共享资源（<code>g_nSum</code>）的代码包装在对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection"><code>EnterCriticalSection</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection"><code>LeaveCriticalSection</code></a> 的调用中。请注意，在对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection"><code>EnterCriticalSection</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection"><code>LeaveCriticalSection</code></a> 的所有调用中都传递了 <code>g_cs</code> 的地址。</p><h3 id="临界区段与自旋锁"><a href="#临界区段与自旋锁" class="headerlink" title="临界区段与自旋锁"></a>临界区段与自旋锁</h3><p>当一个线程尝试进入另一个线程拥有的临界区段时，调用线程将立即进入等待状态。这意味着线程必须从用户模式切换到内核模式（大约 1000 个 CPU 周期），这种切换非常昂贵。在多处理器计算机上，当前拥有资源的线程可能会在其他处理器上执行，并可能很快放弃对资源的控制。拥有该资源的线程可能会在其他线程完成到内核模式的切换之前释放资源。这种情况情况下会浪费大量 CPU 时间。</p><p>为了提高临界区段的性能，Microsoft 已将自旋锁合并到其中。因此，当调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection"><code>EnterCriticalSection</code></a> 时，它会使用自旋锁循环，尝试多次获取资源。仅当所有尝试都失败时，线程才会切换到内核模式以进入等待状态。</p><p>要将自旋锁与临界区段一起使用，您应该调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount"><code>InitializeCriticalSectionAndSpinCount</code></a> 函数来初始化临界区段。</p><h3 id="临界区段与错误处理"><a href="#临界区段与错误处理" class="headerlink" title="临界区段与错误处理"></a>临界区段与错误处理</h3><p>对 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection"><code>InitializeCriticalSection</code></a> 函数的调用可能会失败（可能性很小）。微软在最初设计该函数时并没有真正考虑过这一点，这就是为什么该函数被原型化为返回 <code>VOID</code> 的原因。该函数可能会失败，因为它会分配一个内存块，以便系统可以具有一些内部调试信息。如果此内存分配失败，则会引发 <code>STATUS_NO_MEMORY</code> 异常。您可以使用结构化异常处理将其捕获到代码中。</p><h2 id="srwlock"><a href="#srwlock" class="headerlink" title="SRWLock"></a>SRWLock</h2><p>SRWLock（Slim Reader-Writer Lock）与简单的临界区段具有相同的用途：保护单个资源免受不同线程的访问。但是，与临界区段不同，SRWLock 允许您区分只想读取资源值的线程（读者）和尝试更新资源值的其他线程（写者）。所有读者应该可以同时访问共享资源，因为只读取资源的值不会有数据损坏的风险。当写者想要更新资源时，就需要同步，此时访问应该是独占的（不允许任何其他线程访问资源）。</p><p>要使用 SRWLock，首先需要分配一个 <code>SRWLOCK</code> 结构并使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializesrwlock"><code>InitializeSRWLock</code></a> 函数初始化它。</p><p>初始化 SRWLock 后，写者可以尝试通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-acquiresrwlockexclusive"><code>AcquireSRWLockExclusive</code></a> 来获取对资源的独占访问权限。更新资源后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesrwlockexclusive"><code>ReleaseSRWLockExclusive</code></a> 来释放锁。</p><p>对于读者，则使用以下两个函数来获取资源访问的权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID <span class="hljs-title">AcquireSRWLockShared</span><span class="hljs-params">(PSRWLOCK SRWLock)</span></span>;<br><span class="hljs-function">VOID <span class="hljs-title">ReleaseSRWLockShared</span><span class="hljs-params">(PSRWLOCK SRWLock)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>在一些需要同步的情景中，线程必须以原子方式释放资源上的锁并阻塞，直到满足某个条件为止。使用 <em>条件变量（Condition Variables）</em> 可以简化这些场景所需的代码，这可以通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablecs"><code>SleepConditionVariableCS</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablesrw"><code>SleepConditionVariableSRW</code></a> 函数来实现。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Thread Scheduling, Priorities, and Affinities</title>
    <link href="/2022/02/17/windows-via-c-cpp-5th-thread-scheduling-priorities-and-affinities/"/>
    <url>/2022/02/17/windows-via-c-cpp-5th-thread-scheduling-priorities-and-affinities/</url>
    
    <content type="html"><![CDATA[<p>抢占式操作系统必须使用某种算法来确定线程应该何时调度以及运行多长时间。每个线程都有一个在线程内核对象中维护的上下文结构。此上下文结构反映线程上次执行时线程的 CPU 寄存器的状态。每隔 20 ms 左右，Windows 会查看当前存在的所有线程内核对象，选择一个可调度的线程内核对象，并使用上次保存在线程上下文中的值加载 CPU 的寄存器。此操作称为 <em>上下文切换（Context Switch）</em> 。</p><h2 id="挂起或恢复线程"><a href="#挂起或恢复线程" class="headerlink" title="挂起或恢复线程"></a>挂起或恢复线程</h2><p>线程内核对象内部有一个值，该值指示线程的挂起计数。调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 时，将创建线程内核对象并将其挂起计数初始化为 <code>1</code>。这可以防止将线程即刻调度到 CPU，因为初始化线程需要一些时间，不希望系统在线程完全准备就绪之前开始执行线程。</p><p>线程完全初始化后，<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 将检查是否传递了 <code>CREATE_SUSPENDED</code> 标志。若是，则函数返回，新线程将保持挂起状态；若否，则函数会将线程的挂起计数递减为 <code>0</code>。</p><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><code>ResumeThread</code></a> 可使线程恢复运行，调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><code>SuspendThread</code></a> 则可使线程挂起。线程可以被挂起多次，但也必须被恢复同样的次数才能使其可调度。</p><h2 id="挂起或恢复进程"><a href="#挂起或恢复进程" class="headerlink" title="挂起或恢复进程"></a>挂起或恢复进程</h2><p>对于 Windows 来说，不存在挂起或恢复进程的概念，因为进程永远不会调度到 CPU。可以通过挂起进程中的所有线程来达到类似的效果。</p><h2 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h2><p>线程可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 函数来告诉系统它不希望在一定时间内被调度。此函数使线程挂起，直到经过指定的时间。使用此函数时需要注意如下事项：</p><ul><li>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 允许线程自愿地放弃其剩余的时间片。</li><li>系统使线程在指定时间内不可调度，但不保证线程在指定时间后会被及时调度。</li><li>可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 并传递 <code>INFINITE</code> 给参数，以告诉系统永远不要调度线程。</li><li>可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 并传递 <code>0</code> 给参数，以告诉系统线程自愿地放弃其剩余的时间片，系统可以调度其他线程。如果没有更多具有相同优先级或更高优先级的可调度线程，那么系统可以重新调度该线程。</li></ul><h2 id="切换到另一线程"><a href="#切换到另一线程" class="headerlink" title="切换到另一线程"></a>切换到另一线程</h2><p>系统提供了一个名为 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 的函数，该函数允许另一个可调度线程运行。</p><p>调用此函数时，系统将检查是否存在饥饿线程。若否，则 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 会立即返回；若是，则 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 将调度该线程。允许饥饿线程运行一个时间片，然后系统调度器将照常运行。</p><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 类似于调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><code>Sleep</code></a> 并传递 <code>0</code>。不同之处在于，<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread"><code>SwitchToThread</code></a> 允许执行优先级较低的线程。</p><h3 id="在超线程-cpu-上切换到另一线程"><a href="#在超线程-cpu-上切换到另一线程" class="headerlink" title="在超线程 CPU 上切换到另一线程"></a>在超线程 CPU 上切换到另一线程</h3><p>超线程（Hyper-Threaded）CPU 具有多个“逻辑（logical）”CPU，每个都可以运行一个线程。每个线程都有自己的架构状态（寄存器组），但所有线程共享主执行资源（如 CPU cache）。当一个线程暂停（缓存未命中、分支错误预测、等待上一条指令的结果等）时，CPU 会自动执行另一个线程，这是在没有操作系统干预的情况下发生的。</p><p>在超线程 CPU 上执行旋转循环（spin loops）时，需要强制当前线程暂停以便其他线程可以访问芯片的资源。x86 架构支持 PAUSE 汇编语言指令。PAUSE 指令可确保避免内存顺序冲突，从而提高性能。在 x86 上，PAUSE 指令等效于 REP NOP 指令，这使得它与不支持超线程的早期的 IA-32 CPU 兼容。PAUSE 会导致有限延迟（在某些 CPU 上为 0）。在 Win32 API 中，x86 PAUSE 指令是通过调用 WinNT.h 中定义的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-yieldprocessor"><code>YieldProcessor</code></a> 宏发出的。</p><h2 id="线程的执行时间"><a href="#线程的执行时间" class="headerlink" title="线程的执行时间"></a>线程的执行时间</h2><p>有时希望计算线程执行特定任务所需的时间。许多人所做的是编写类似于以下内容的代码，利用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount64"><code>GetTickCount64</code></a> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Get the current time (start time).</span><br>ULONGLONG qwStartTime = <span class="hljs-built_in">GetTickCount64</span>();<br><br><span class="hljs-comment">// Perform complex algorithm here.</span><br><br><span class="hljs-comment">// Subtract start time from current time to get duration.</span><br>ULONGLONG qwElapsedTime = <span class="hljs-built_in">GetTickCount64</span>() - qwStartTime;<br></code></pre></td></tr></table></figure><p>此代码做出一个简单的假设：它不会被中断。但是，在抢占式操作系统中永远不会知道线程何时会被调度。可以利用操作系统提供的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes"><code>GetThreadTimes</code></a> 函数来准确地实现这个任务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">__int64 <span class="hljs-title">FileTimeToQuadWord</span><span class="hljs-params">(PFILETIME pft)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">Int64ShllMod32</span>(pft-&gt;dwHighDateTime, <span class="hljs-number">32</span>) | pft-&gt;dwLowDateTime);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerformLongOperation</span><span class="hljs-params">()</span> </span>&#123;<br>    FILETIME ftKernelTimeStart, ftKernelTimeEnd;<br>    FILETIME ftUserTimeStart, ftUserTimeEnd;<br>    FILETIME ftDummy;<br>    __int64 qwKernelTimeElapsed, qwUserTimeElapsed, qwTotalTimeElapsed;<br><br>    <span class="hljs-comment">// Get starting times.</span><br>    <span class="hljs-built_in">GetThreadTimes</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ftDummy, &amp;ftDummy, &amp;ftKernelTimeStart, &amp;ftUserTimeStart);<br><br>    <span class="hljs-comment">// Perform complex algorithm here.</span><br><br>    <span class="hljs-comment">// Get ending times.</span><br>    <span class="hljs-built_in">GetThreadTimes</span>(<span class="hljs-built_in">GetCurrentThread</span>(), &amp;ftDummy, &amp;ftDummy, &amp;ftKernelTimeEnd, &amp;ftUserTimeEnd);<br><br>    <span class="hljs-comment">// Get the elapsed kernel and user times by converting the start and end times from FILETIMEs to quad words,</span><br>    <span class="hljs-comment">// and then subtract the start times from the end times.</span><br>    qwKernelTimeElapsed = <span class="hljs-built_in">FileTimeToQuadWord</span>(&amp;ftKernelTimeEnd) - <span class="hljs-built_in">FileTimeToQuadWord</span>(&amp;ftKernelTimeStart);<br>    qwUserTimeElapsed = <span class="hljs-built_in">FileTimeToQuadWord</span>(&amp;ftUserTimeEnd) - <span class="hljs-built_in">FileTimeToQuadWord</span>(&amp;ftUserTimeStart);<br><br>    <span class="hljs-comment">// Get total time duration by adding the kernel and user times.</span><br>    qwTotalTimeElapsed = qwKernelTimeElapsed + qwUserTimeElapsed;<br>    <br>    <span class="hljs-comment">// The total elapsed time is in qwTotalTimeElapsed.</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes"><code>GetProcessTimes</code></a> 返回应用于指定进程中所有线程（甚至是已终止的线程）的时间。</p><p>对于高分辨率的分析，Windows 提供了以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">QueryPerformanceFrequency</span><span class="hljs-params">(LARGE_INTEGER* pliFrequency)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">QueryPerformanceCounter</span><span class="hljs-params">(LARGE_INTEGER* pliCount)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="CONTEXT"></a>CONTEXT</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context"><code>CONTEXT</code></a> 结构允许系统记住线程的状态，以便线程可以在下次运行时从中断的位置继续。</p><p>Windows 允许查看线程内核对象的内部，并获取其当前的 CPU 寄存器组。为此，只需调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext"><code>GetThreadContext</code></a> 函数。</p><p>应该在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext"><code>GetThreadContext</code></a> 之前调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><code>SuspendThread</code></a>。否则，可能线程可能会被调度，并且线程的上下文可能与返回的内容不同。线程实际上有两个上下文：用户模式和内核模式。<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext"><code>GetThreadContext</code></a> 只能返回线程的用户模式上下文。如果调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><code>SuspendThread</code></a> 来停止某个线程，但该线程当前正以内核模式执行，那么即使 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><code>SuspendThread</code></a> 实际上尚未挂起该线程，其用户模式上下文也是稳定的。</p><p>Windows 允许更改 <code>CONTEXT</code> 结构中的成员，然后通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext"><code>SetThreadContext</code></a> 将新的寄存器值放回线程内核对象中。同样地，要更改上下文的线程应先挂起，否则结果将不可预测。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程都分配有一个优先级编号，范围从 0（最低）到 31（最高）。系统会根据优先级从高到低地检查可调度线程，这意味着相对较低优先级的线程可能永远不会被调度，如系统中一直存在优先级为 31 的可调度线程，则优先级为 30 的可调度线程永远不会被调度，这种情况称为饥饿（Starvation）。在多处理器机器上发生饥饿的可能性会低得多，因为在这种机器上，优先级为 31 的可调度线程和优先级为 30 的可调度线程可能同时运行，系统会始终尝试使 CPU 保持繁忙状态，仅当没有可调度线程时，CPU 才会空闲。</p><p>优先级较高的线程始终会抢占优先级较低的线程，而不管较低优先级的线程正在执行什么。例如，如果优先级为 5 的线程正在运行，并且系统确定了优先级为 6 的线程已准备好运行，则系统会立即挂起优先级较低的线程（即使它处于其时间片的中间），并将 CPU 分配给优先级较高的线程（获得一个完整的时间片）。</p><p>当系统启动时，它会创建一个名为 <em>零页线程（Zero Page Thread）</em> 的特殊线程。此线程优先级为 0，并且是整个系统中唯一以优先级 0 运行的线程。在没有其他线程需要执行工作时，零页线程负责将系统中所有空闲 RAM 页清零。</p><h2 id="优先级的抽象视图"><a href="#优先级的抽象视图" class="headerlink" title="优先级的抽象视图"></a>优先级的抽象视图</h2><p>Windows API 在系统的调度器上公开了一个抽象层，这个抽象层会根据正在运行的系统的版本来“解释”请求的参数。</p><p>在设计应用程序时，应考虑可能与应用程序一起运行的其他应用程序。然后，应该根据应用程序中线程的响应速度选择优先级类别。</p><p>Windows 支持六种优先级类别：空闲（Idle）、低于正常（Below Normal）、正常（Normal）、高于正常（Above Normal）、高（High）和实时（Real-time）。正常是最常见的优先级类别，99% 的应用程序都应该使用它：</p><table><thead><tr><th align="left">Priority Class</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Real-time</td><td align="left">The threads in this process must respond immediately to events to execute time-critical tasks. Threads in this process also preempt operating system components. Use this priority class with extreme caution.</td></tr><tr><td align="left">High</td><td align="left">The threads in this process must respond immediately to events to execute time-critical tasks. The Task Manager runs at this class so that a user can kill runaway processes.</td></tr><tr><td align="left">Above normal</td><td align="left">The threads in this process run between the normal and high-priority classes.</td></tr><tr><td align="left">Normal</td><td align="left">The threads in this process have no special scheduling needs.</td></tr><tr><td align="left">Below normal</td><td align="left">The threads in this process run between the normal and idle priority classes.</td></tr><tr><td align="left">Idle</td><td align="left">The threads in this process run when the system is otherwise idle. This process is typically used by screen savers or background utility and statistics-gathering software.</td></tr></tbody></table><p>空闲优先级类别非常适合在系统几乎不执行任何操作时运行的应用程序。只有在绝对必要时，才应使用高优先级类别。如果可能，应避免使用实时优先级类别。实时优先级可能会干扰操作系统任务，因为大多数操作系统线程以较低的优先级执行。</p><blockquote><p>注：进程不能运行在实时优先级类别，除非用户具有“提高计划优先级（Increase Scheduling Priority）”权限。默认情况下，任何指定为管理员或超级用户的用户都具有此权限。</p></blockquote><p>选择优先级类别后，应该停止考虑应用程序与其他应用程序的关连，而只需专注于应用程序中的线程即可。</p><p>Windows 支持七个相对线程优先级：空闲（Idle）、最低（Lowest）、低于正常（Below Normal）、正常（Normal）、高于正常（Above Normal）、最高（Highest）和时间关键（Time-critical）。这些优先级相对于进程的优先级类别。同样，大多数线程使用正常的线程优先级：</p><table><thead><tr><th align="left">Relative Thread Priority</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Time-critical</td><td align="left">Thread runs at 31 for the real-time priority class and at 15 for all other priority classes.</td></tr><tr><td align="left">Highest</td><td align="left">Thread runs two levels above normal.</td></tr><tr><td align="left">Above normal</td><td align="left">Thread runs one level above normal.</td></tr><tr><td align="left">Normal</td><td align="left">Thread runs normally for the process’ priority class.</td></tr><tr><td align="left">Below normal</td><td align="left">Thread runs one level below normal.</td></tr><tr><td align="left">Lowest</td><td align="left">Thread runs two levels below normal.</td></tr><tr><td align="left">Idle</td><td align="left">Thread runs at 16 for the real-time priority class and at 1 for all other priority classes.</td></tr></tbody></table><p>进程优先级类别与相对线程优先级共同决定线程的优先级。应用开发者不应该使用具体数值来为线程赋予优先级，而应该通过设置进程优先级类别和相对线程优先级来让系统决定如何映射到优先级级别：</p><table><thead>  <tr>    <th rowspan="2" style="text-align:center">Relative Thread Priority</th>    <th colspan="6" style="text-align:center">Process Priority Class</th>  </tr>  <tr>    <th style="text-align:center">Idle</th>    <th style="text-align:center">Below Normal</th>    <th style="text-align:center">Normal</th>    <th style="text-align:center">Above Normal</th>    <th style="text-align:center">High</th>    <th style="text-align:center">Real-Time</th>  </tr></thead><tbody>  <tr>    <td>Time-critical</td>    <td style="text-align:center">15</td>    <td style="text-align:center">15</td>    <td style="text-align:center">15</td>    <td style="text-align:center">15</td>    <td style="text-align:center">15</td>    <td style="text-align:center">31</td>  </tr>  <tr>    <td>Highest</td>    <td style="text-align:center">6</td>    <td style="text-align:center">8</td>    <td style="text-align:center">10</td>    <td style="text-align:center">12</td>    <td style="text-align:center">15</td>    <td style="text-align:center">26</td>  </tr>  <tr>    <td>Above normal</td>    <td style="text-align:center">5</td>    <td style="text-align:center">7</td>    <td style="text-align:center">9</td>    <td style="text-align:center">11</td>    <td style="text-align:center">14</td>    <td style="text-align:center">25</td>  </tr>  <tr>    <td>Normal</td>    <td style="text-align:center">4</td>    <td style="text-align:center">6</td>    <td style="text-align:center">8</td>    <td style="text-align:center">10</td>    <td style="text-align:center">13</td>    <td style="text-align:center">24</td>  </tr>  <tr>    <td>Below normal</td>    <td style="text-align:center">3</td>    <td style="text-align:center">5</td>    <td style="text-align:center">7</td>    <td style="text-align:center">9</td>    <td style="text-align:center">12</td>    <td style="text-align:center">23</td>  </tr>  <tr>    <td>Lowest</td>    <td style="text-align:center">2</td>    <td style="text-align:center">4</td>    <td style="text-align:center">6</td>    <td style="text-align:center">8</td>    <td style="text-align:center">11</td>    <td style="text-align:center">22</td>  </tr>  <tr>    <td>Idle</td>    <td style="text-align:center">1</td>    <td style="text-align:center">1</td>    <td style="text-align:center">1</td>    <td style="text-align:center">1</td>    <td style="text-align:center">1</td>    <td style="text-align:center">16</td>  </tr></tbody></table><blockquote><p>注：上表的映射值在不同版本的 Windows 上可能存在差异。该表没有展示线程映射到优先级 0 的任何方式，这是因为 0 优先级是为零页线程保留的，并且系统不允许任何其他线程的优先级为 0。此外，无法获得以下优先级别：17、18、19、20、21、27、28、29 或 30，这些是为在内核模式下运行的设备驱动程序准备的。</p></blockquote><h2 id="编程优先级"><a href="#编程优先级" class="headerlink" title="编程优先级"></a>编程优先级</h2><p>当调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 时，可以在 <code>fdwCreate</code> 参数中传递所需的优先级类别：</p><table><thead><tr><th align="left">Priority Class</th><th align="left">Symbolic Identifiers</th></tr></thead><tbody><tr><td align="left">Real-time</td><td align="left"><code>REALTIME_PRIORITY_CLASS</code></td></tr><tr><td align="left">High</td><td align="left"><code>HIGH_PRIORITY_CLASS</code></td></tr><tr><td align="left">Above normal</td><td align="left"><code>ABOVE_NORMAL_PRIORITY_CLASS</code></td></tr><tr><td align="left">Normal</td><td align="left"><code>NORMAL_PRIORITY_CLASS</code></td></tr><tr><td align="left">Below normal</td><td align="left"><code>BELOW_NORMAL_PRIORITY_CLASS</code></td></tr><tr><td align="left">Idle</td><td align="left"><code>IDLE_PRIORITY_CLASS</code></td></tr></tbody></table><p>通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass"><code>SetPriorityClass</code></a> 可以更改指定进程的优先级类别。通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getpriorityclass"><code>GetPriorityClass</code></a> 可以检索指定进程的优先级类别。</p><p>使用命令行 Shell 调用程序时，程序的起始优先级为正常。使用 <code>START</code> 命令调用程序时可以指定一个起始优先级，如 <code>START /LOW CALC.EXE</code>。</p><p>首次创建线程时，其相对线程优先级始终设置为正常。使用以下函数可以设置和获取线程的相对优先级：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">SetThreadPriority</span><span class="hljs-params">(HANDLE hThread, <span class="hljs-type">int</span> nPriority)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetThreadPriority</span><span class="hljs-params">(HANDLE hThread)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="动态提升线程优先级"><a href="#动态提升线程优先级" class="headerlink" title="动态提升线程优先级"></a>动态提升线程优先级</h3><p>系统通过将线程的相对优先级与线程的进程的优先级类别相结合来确定线程的优先级，这称为线程的基本优先级（Base Priority Level）。有时，系统会提升线程的优先级，这通常是为了响应某些 I&#x2F;O 事件（如窗口消息或磁盘读取）。</p><p>例如，在高优先级类别进程中有一个正常线程优先级的线程，其基本优先级为 13。如果用户按下某个键，则系统会将 <code>WM_KEYDOWN</code> 消息放到线程的队列中。由于消息已出现在线程的队列中，因此线程是可调度的。此外，键盘设备驱动程序可以告诉系统暂时提高线程的级别，因此，线程可能会提升 2，并且当前优先级为 15。</p><p>线程会被调度一个时间片（优先级为 15）。一旦该时间片到期，系统就会将线程的优先级从 15 降至 14，以进行下一个时间片。线程的第三个时间片会以优先级 13 执行。线程的其他时间片都将在优先级 13（线程的基本优先级）下执行。</p><blockquote><p>注：线程的当前优先级永远不会低于线程的基本优先级。</p></blockquote><p>系统仅提升基本优先级介于 1 和 15 之间的线程。实际上，这就是为什么此范围被称为动态优先级范围的原因。此外，系统永远不会将线程提升到实时范围（高于 15）。由于实时范围内的线程大多数执行操作系统功能，因此对强制实施上限可防止应用程序干扰操作系统。此外，系统从不动态提升实时范围（16 到 31）中的线程。</p><p>系统的动态提升可能会对线程的性能产生影响，因此 Microsoft 添加了以下两个函数，以允许禁用系统对线程优先级的动态提升：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">SetProcessPriorityBoost</span><span class="hljs-params">(HANDLE hProcess, BOOL bDisablePriorityBoost)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">SetThreadPriorityBoost</span><span class="hljs-params">(HANDLE hThread, BOOL bDisablePriorityBoost)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocesspriorityboost"><code>SetProcessPriorityBoost</code></a> 告诉系统为进程内的所有线程启用或禁用优先级提升；<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriorityboost"><code>SetThreadPriorityBoost</code></a> 允许为单个线程启用或禁用优先级提升。这两个函数具有对应项，允许您确定是启用还是禁用优先级提升：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetProcessPriorityBoost</span><span class="hljs-params">(HANDLE hProcess, PBOOL pbDisablePriorityBoost)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">GetThreadPriorityBoost</span><span class="hljs-params">(HANDLE hThread, PBOOL pbDisablePriorityBoost)</span></span>;<br></code></pre></td></tr></table></figure><p>另一种情况也会导致系统动态提升线程的优先级。比如，一个优先级为 4 的线程已准备好运行，但无法运行，因为优先级为 8 的线程是可持续调度的。在这种情况下，优先级 4 线程渴望 CPU 时间。当系统检测到某个线程在大约三到四秒内 CPU 时间不足时，它会动态地将饥饿线程的优先级提升为 15，并允许该线程运行两倍的时间量。当两倍时间量到期时，该线程会马上回到其基本优先级。</p><h3 id="为前台进程调整调度器"><a href="#为前台进程调整调度器" class="headerlink" title="为前台进程调整调度器"></a>为前台进程调整调度器</h3><p>当用户使用进程的窗口时，该进程称为前台进程（Foreground Process），所有其他进程都是后台进程（Background Process）。用户肯定更希望他或她使用的进程比后台进程的行为响应更快。为了提高前台进程的响应能力，Windows 调整了前台进程中线程的调度算法。系统为前台进程线程提供的时间量比它们通常接收的时间量大。仅当前台进程属于正常优先级类别时，才会执行此调整。如果它属于任何其他优先级，则不执行任何调整。</p><h3 id="安排-i-x2f-o-请求优先级"><a href="#安排-i-x2f-o-请求优先级" class="headerlink" title="安排 I&#x2F;O 请求优先级"></a>安排 I&#x2F;O 请求优先级</h3><p>设置线程优先级会影响线程如何调度 CPU 资源。然而，线程还会执行 I&#x2F;O 请求以从磁盘文件中读取和写入数据。如果低优先级线程获得 CPU 时间，它可以在很短的时间内简单地将数百或数千个 I&#x2F;O 请求入队。由于 I&#x2F;O 请求通常需要时间来处理，因此低优先级线程可能会通过挂起高优先级线程来显著影响系统的响应能力，从而阻止它们完成工作。因此，您可以看到计算机在执行长时间运行的低优先级服务（如磁盘碎片整理程序、病毒扫描程序、内容索引器等）时响应速度变慢。</p><p>从 Windows Vista 开始，线程可以在发出 I&#x2F;O 请求时指定优先级。可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority"><code>SetThreadPriority</code></a> 并传递 <code>THREAD_MODE_BACKGROUND_BEGIN</code> 来告诉 Windows，该线程应该发出低优先级的 I&#x2F;O 请求。请注意，这也会降低线程的 CPU 调度优先级。可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority"><code>SetThreadPriority</code></a> 并传递 <code>THREAD_ MODE_BACKGROUND_END</code> 将线程返回到发出正常优先级 I&#x2F;O 请求（以及正常的 CPU 调度优先级）。</p><p>如果希望进程中的所有线程发出低优先级 I&#x2F;O 请求并具有低 CPU 调度，则可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass"><code>SetPriorityClass</code></a> 并传递 <code>PROCESS_MODE_BACKGROUND_BEGIN</code>。</p><p>在更精细的粒度下，正常优先级线程可以对特定文件执行后台优先级 I&#x2F;O，如以下代码片段所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FILE_IO_PRIORITY_HINT_INFO phi;<br>phi.PriorityHint = IoPriorityHintLow;<br><span class="hljs-built_in">SetFileInformationByHandle</span>(hFile, FileIoPriorityHintInfo, &amp;phi, <span class="hljs-built_in">sizeof</span>(PriorityHint));<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle"><code>SetFileInformationByHandle</code></a> 设置的优先级会覆盖 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass"><code>SetPriorityClass</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority"><code>SetThreadPriority</code></a> 设置的优先级。</p><h2 id="亲和性"><a href="#亲和性" class="headerlink" title="亲和性"></a>亲和性</h2><p>默认情况下，Windows Vista 在将线程分配给处理器时使用 <em>软亲和性（Soft Affinity）</em> 。这意味着，如果所有其他因素相同，它将尝试在线程上次运行的那个处理器上运行线程。让线程保留在单个处理器上有助于重用仍在处理器内存缓存中的数据。</p><p>有一种称为 <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA（Non-Uniform Memory Access）</a> 的计算机架构，其中机器由多个板组成。每个板都有独自的 CPU 和独自的内存库。当 CPU 访问其自身板上的内存时，NUMA 系统的性能最佳。如果 CPU 需要接触另一块板上的内存，则会对性能造成巨大影响。在这种场景下，希望同一进程的线程都能在同一板上的 CPU 上运行。为了适应这种计算机架构，Windows Vista 允许设置进程和线程亲和性，即可以控制哪些 CPU 可以运行哪些线程，这称为 <em>硬亲和性（Hard Affinity）</em>。</p><p>系统在启动时会确定计算机中有多少 CPU 可用，应用程序可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo"><code>GetSystemInfo</code></a> 来查询计算机上的 CPU 数量。默认情况下，可以将任何线程调度到这些 CPU 中的任何一个。要将单个进程中的线程限制在可用 CPU 的子集上运行，可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessaffinitymask"><code>SetProcessAffinityMask</code></a>。</p><blockquote><p>注：子进程会继承进程亲和性。此外，还可以使用作业内核对象来设置一组进程的亲和性。</p></blockquote><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getprocessaffinitymask"><code>GetProcessAffinityMask</code></a> 会返回进程的亲和性掩码。</p><p>可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask"><code>SetThreadAffinityMask</code></a> 为单个线程设置亲和性掩码。</p><p>有时，将线程强制到特定的 CPU 并不是一个好主意。要为线程设置理想的 CPU，请调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadidealprocessor"><code>SetThreadIdealProcessor</code></a>。</p><p>还可以在可执行文件的标头中设置处理器亲和性，可以使用类似于如下代码来利用 ImageHlp.h 中声明的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Load the EXE into memory.</span><br>PLOADED_IMAGE pLoadedImage = <span class="hljs-built_in">ImageLoad</span>(szExeName, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// Get the current load configuration information for the EXE.</span><br>IMAGE_LOAD_CONFIG_DIRECTORY ilcd;<br><span class="hljs-built_in">GetImageConfigInformation</span>(pLoadedImage, &amp;ilcd);<br><br><span class="hljs-comment">// Change the processor affinity mask.</span><br>ilcd.ProcessAffinityMask = <span class="hljs-number">0x00000003</span>; <span class="hljs-comment">// I desire CPUs 0 and 1</span><br><br><span class="hljs-comment">// Save the new load configuration information.</span><br><span class="hljs-built_in">SetImageConfigInformation</span>(pLoadedImage, &amp;ilcd);<br><br><span class="hljs-comment">// Unload the EXE from memory</span><br><span class="hljs-built_in">ImageUnload</span>(pLoadedImage);<br></code></pre></td></tr></table></figure><p>当 Windows Vista 在 x86 计算机上启动时，可以限制系统将使用的 CPU 数量。在引导周期中，系统会检查 BCD（Boot Configuration Data），该数据存储用于替换旧的 boot.ini 文本文件，并提供计算机硬件和固件的更高级别的抽象。</p><p>BCD 的编程化配置是通过 WMI（Windows Management Instrumentation）完成的，也可以通过图形用户界面访问一些最常见的参数。要限制 Windows 使用的 CPU 数量，您需要在 <strong>控制面板（Control Panel） &gt; 管理工具（Administrative Tools） &gt; 系统配置（System Configuration） &gt; 引导（Boot） &gt; 高级选项（Advanced） &gt; 处理器个数（Number Of Processors）</strong> 中填写所需的数目。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Thread Basics</title>
    <link href="/2022/02/14/windows-via-c-cpp-5th-thread-basics/"/>
    <url>/2022/02/14/windows-via-c-cpp-5th-thread-basics/</url>
    
    <content type="html"><![CDATA[<p>线程（Thread）描述了进程（Process）中的执行路径，由两部分组成：</p><ul><li>一个被操作系统用来管理线程的<a href="https://dsyx.github.io/2022/02/07/windows-via-c-cpp-5th-kernel-objects/">内核对象</a>。这个内核对象也是系统用来存放关于线程的统计信息的地方。</li><li>一个用来维护线程执行代码时所需的所有函数参数和局部变量的线程栈（Thread Stack）。</li></ul><p><a href="https://dsyx.github.io/2022/02/09/windows-via-c-cpp-5th-processes/">进程</a>是惰性的，它从不执行任何操作，仅仅是线程的容器。线程总是在某个进程的上下文（context）中创建，并在该进程中度过它们的整个生命周期。这实际上意味着线程在其进程的地址空间内执行代码并操作数据，因此如果有两个或多个线程在单个进程的上下文中运行，则这些线程共享单个地址空间。线程可以执行相同的代码并操作相同的数据。线程还可以共享内核对象句柄，因为<a href="https://dsyx.github.io/2022/02/07/windows-via-c-cpp-5th-kernel-objects/#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E5%8F%A5%E6%9F%84%E8%A1%A8">句柄表</a>存在于每个进程，而不是每个线程。</p><blockquote><p>注：创建进程时，系统会自动创建其第一个线程，称为<em>主线程（Primary Thread）</em>。</p></blockquote><p>进程所使用的系统资源比线程多得多，其原因是地址空间。为进程创建虚拟地址空间需要大量的系统资源。系统中会进行大量记录保存，这需要大量的内存。此外，由于 <code>.exe</code> 和 <code>.dll</code> 文件被加载到地址空间中，因此还需要文件资源。实际上，线程只有一个内核对象和一个栈，几乎不涉及记录保存，因此只需要很少的内存。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>每个线程都必须有一个入口点（entry-point）函数以开始执行，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ThreadFunc</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    DWORD dwResult = <span class="hljs-number">0</span>;<br>    ...<br>    <span class="hljs-keyword">return</span>(dwResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>线程函数可以执行任何所需的任务。当线程函数返回时，线程停止运行，其栈内存被释放，线程内核对象（Thread Kernel Object）的使用计数递减。</p><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 函数可以创建一个新的线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateThread</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psa,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD cbStackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTHREAD_START_ROUTINE pfnStartAddr,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvParam,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwCreateFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    PDWORD pdwThreadID)</span></span>;<br></code></pre></td></tr></table></figure><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 时，系统会创建一个线程内核对象。线程内核对象不是线程本身，而是操作系统用于管理线程的小型数据结构。这与进程和进程内核对象相互关联的方式相同。系统从进程的地址空间中分配内存以供线程的栈使用。新线程在与创建线程的线程在相同的进程上下文中运行。因此，新线程可以访问进程的所有内核对象句柄、进程中的所有内存以及同一进程中所有其他线程的栈。这使得单个进程中的多个线程非常容易相互通信。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 函数是创建线程的 Windows 函数。但是，如果您正在编写 C&#x2F;C++ 代码，则永远不应调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a>。相反，您应该使用 Microsoft C++ 运行时库函数 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex"><code>_beginthreadex</code></a>。</p></blockquote><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>线程可以通过四种方式终止：</p><ul><li>从线程函数返回。（强烈建议这样做）</li><li>线程通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 函数来终止自身。（避免使用此方法）</li><li>同一进程或另一个进程中的线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 函数。（避免使用此方法）</li><li>包含线程的进程终止。（避免使用此方法）</li></ul><p>当线程终止时，将发生以下操作：</p><ul><li>线程拥有的所有 User 对象句柄都将被释放。在 Windows 中，大多数对象都归包含创建对象的线程的进程所有。但是，线程拥有两种 User 对象：窗口（window）和钩子（hook）。当线程终止时，系统会自动销毁任何窗口，并卸载由线程创建或安装的任何钩子。仅当进程终止时，才会销毁其他对象。</li><li>线程的退代码从 <code>STILL_ACTIVE</code> 更改为传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 或 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 的退出码。</li><li>线程内核对象的状态变为已示意（signaled）。</li><li>如果该线程是进程中的最后一个活动线程，那么系统也会认为该进程已终止。</li><li>线程内核对象的使用计数减少 1。</li></ul><p>可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodethread"><code>GetExitCodeThread</code></a> 来检查指定的线程是否已终止以及终止时的退出码。</p><h3 id="从线程函数返回"><a href="#从线程函数返回" class="headerlink" title="从线程函数返回"></a>从线程函数返回</h3><p>应将线程设计为仅在从线程函数返回时终止，这是保证正确清理所有线程资源的唯一方法。</p><p>从线程函数返回可确保以下内容：</p><ul><li>在线程函数中创建的所有 C++ 对象都将通过其析构函数正确销毁。</li><li>系统将正确释放线程栈使用的内存。</li><li>系统会将线程的退出码（保留在线程内核对象中）设置为线程函数的返回值。</li><li>系统将递减线程内核对象的使用计数。</li></ul><h3 id="线程通过调用-exitthread-函数来终止自身"><a href="#线程通过调用-exitthread-函数来终止自身" class="headerlink" title="线程通过调用 ExitThread 函数来终止自身"></a>线程通过调用 ExitThread 函数来终止自身</h3><p>可以通过让线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 来强制线程终止。此函数终止线程，并使操作系统清理线程使用的所有操作系统资源。但是，您的 C&#x2F;C++ 资源（如 C++ 类对象）可能不会被销毁，参考<a href="https://dsyx.github.io/2022/02/09/windows-via-c-cpp-5th-processes/#%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8-exitprocess-%E5%87%BD%E6%95%B0">进程中的一个线程调用 ExitProcess 函数</a>。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 函数是终止线程的 Windows 函数。如果您正在编写 C&#x2F;C++ 代码，则永远不应调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a>。相反，您应该使用 Microsoft C++ 运行时库函数 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/endthread-endthreadex"><code>_endthreadex</code></a>。</p></blockquote><h3 id="同一进程或另一个进程中的线程调用-terminatethread-函数"><a href="#同一进程或另一个进程中的线程调用-terminatethread-函数" class="headerlink" title="同一进程或另一个进程中的线程调用 TerminateThread 函数"></a>同一进程或另一个进程中的线程调用 TerminateThread 函数</h3><p>与 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 不同，<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 可以终止任何线程。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 函数是异步的。因此，如果需要确定线程已终止，那么可能需要调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 或类似的函数。</p></blockquote><p>设计良好的应用程序不应该使用此函数，因为被终止的线程不会收到它正在被终止的通知。线程无法正确地进行清理，并且无法防止自身被终止。</p><blockquote><p>注：当线程通过返回或调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 而终止时，线程的栈将被销毁。但是，如果使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a>，则在拥有该线程的进程终止之前，系统不会销毁线程的栈。微软特意如此地实现了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a>。如果其他仍在执行的线程要引用被强制终止的线程的栈上的值，则这些其他线程将引发访问冲突。通过将已终止线程的栈保留在内存中，其他线程可以继续正常执行。</p><p>此外，DLL 通常会在线程终止时收到通知。但是，如果使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 强行终止线程，则 DLL 不会收到此通知，这可能会阻止正确的清理。</p></blockquote><h3 id="包含线程的进程终止"><a href="#包含线程的进程终止" class="headerlink" title="包含线程的进程终止"></a>包含线程的进程终止</h3><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a> 函数也会终止线程。当整个进程终止时，进程使用的所有资源都将被清理。这两个函数会导致进程中的剩余线程被强制终止，就好像为每个剩余线程调用了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 一样。因此，如果应用程序中有多个线程同时运行，则应该显式地处理每个线程在主线程返回之前如何停止。</p><h2 id="线程的一些内部细节"><a href="#线程的一些内部细节" class="headerlink" title="线程的一些内部细节"></a>线程的一些内部细节</h2><p><img src="/images/how-a-thread-is-created-and-initialized.svg" alt="How a thread is created and initialized"></p><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 会导致系统创建一个线程内核对象。此对象的初始使用计数为 <code>2</code>（在线程停止运行并且从 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 返回的句柄被关闭之前，不会销毁线程内核对象）。线程内核对象的其他属性也被初始化：挂起计数设置为 <code>1</code>、退出码设置为 <code>STILL_ACTIVE</code>、对象设置为非示意（nonsignaled）状态。</p><p>创建内核对象后，系统将为线程栈分配内存（此内存是从进程的地址空间分配的，因为线程没有自己的地址空间）。然后，系统将两个值写入新线程栈的上端（线程栈始终从高内存地址向低内存地址增进）。首先写入栈的值是传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 的 <code>pvParam</code> 参数的值，紧接着是 <code>pfnStartAddr</code> 的值。</p><p>每个线程都有自己的一组 CPU 寄存器，称为线程的<em>上下文</em>。上下文反映了线程上次执行时线程的 CPU 寄存器的状态。线程的 CPU 寄存器组保存在 <code>CONTEXT</code> 结构（在 WinNT.h 头文件中定义）中。<code>CONTEXT</code> 结构本身包含在线程内核对象中。</p><p>IP（Instruction Pointer）寄存器和 SP（Stack Pointer）寄存器是线程上下文中两个最重要的寄存器。线程始终在进程的上下文中运行，因此这两个地址标识的都是所属进程的地址空间中的内存。初始化线程内核对象时，<code>CONTEXT</code> 结构的 SP 寄存器将设置为 <code>pfnStartAddr</code> 在线程栈上所处位置的地址。IP 寄存器设置为名为 <code>RtlUserThreadStart</code> 的未记录函数的地址，该函数由 NTDLL.dll 模块导出，通常执行如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">VOID <span class="hljs-title">RtlUserThreadStart</span><span class="hljs-params">(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)</span> </span>&#123;<br>    __try &#123;<br>        <span class="hljs-built_in">ExitThread</span>((pfnStartAddr)(pvParam));<br>    &#125;<br><br>    __except(<span class="hljs-built_in">UnhandledExceptionFilter</span>(<span class="hljs-built_in">GetExceptionInformation</span>())) &#123;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-built_in">GetExceptionCode</span>());<br>    &#125;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> We never get here.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>线程完全初始化后，系统将检查调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 时是否传递了 <code>CREATE_SUSPENDED</code> 标志。如果未传递此标志，系统会将线程的挂起计数递减为 <code>0</code>，并且线程可以调度到处理器。然后，系统使用上次保存在线程上下文中的值加载实际的 CPU 寄存器。之后，线程可以执行代码并操作其进程地址空间中的数据。</p><p>由于新线程的 IP 设置为 <code>RtlUserThreadStart</code>，因此该函数实际上是线程开始执行的位置。<code>RtlUserThreadStart</code> 的原型使人认为该函数接收两个参数，且暗示该函数是从另一个函数调用的，但事实并非如此。新线程只是刚刚出现并在此处开始执行。<code>RtlUserThreadStart</code> 可以访问这两个参数，它们是有效的，因为操作系统将值显式写入线程的栈上（这是参数传递给函数的通常方式）。需要注意的是，某些 CPU 架构使用 CPU 寄存器而不是栈来传递参数，对于这些架构，系统会在允许线程执行 <code>RtlUserThreadStart</code> 函数之前，正确地初始化合适的寄存器。</p><p>当新线程执行 <code>RtlUserThreadStart</code> 函数时，会发生以下事情：</p><ul><li>围绕线程函数设置了 SEH（Structured Exception Handling）框架，以便在线程执行时引发的任何异常都由系统进行一些默认处理。</li><li>系统调用线程函数，并将传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 函数的 <code>pvParam</code> 参数传递给它。</li><li>当线程函数返回时，<code>RtlUserThreadStart</code> 会调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a>，并将线程函数的返回值传递给它。线程内核对象的使用计数递减，线程停止执行。</li><li>如果线程引发未处理的异常，则由 <code>RtlUserThreadStart</code> 函数设置的 SEH 框架将处理该异常。通常这意味着向用户显示一个消息框，并且当用户关闭该消息框时，<code>RtlUserThreadStart</code> 将调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 以终止整个进程，而不仅仅是有问题的线程。</li></ul><h2 id="c-x2f-c-运行时库注意事项"><a href="#c-x2f-c-运行时库注意事项" class="headerlink" title="C&#x2F;C++ 运行时库注意事项"></a>C&#x2F;C++ 运行时库注意事项</h2><p>有四个 native C&#x2F;C++ 运行时库和两个 managed world of Microsoft .NET 随 Visual Studio 一起提供。请注意，这些库都支持多线程开发：不再有专门设计用于仅面向单线程开发的 C&#x2F;C++ 库。</p><table><thead><tr><th align="left">Library Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">LibCMt.lib</td><td align="left">Statically linked release version of the library.</td></tr><tr><td align="left">LibCMtD.lib</td><td align="left">Statically linked debug version of the library.</td></tr><tr><td align="left">MSVCRt.lib</td><td align="left">Import library for dynamically linking the release version of the MSVCR80.dll library. (This is the default library when you create a new project.)</td></tr><tr><td align="left">MSVCRtD.lib</td><td align="left">Import library for dynamically linking the debug version of the MSVCR80D.dll library.</td></tr><tr><td align="left">MSVCMRt.lib</td><td align="left">Import library used for mixed managed&#x2F;native code.</td></tr><tr><td align="left">MSVCURt.lib</td><td align="left">Import library compiled as 100-percent pure MSIL code.</td></tr></tbody></table><p>通过项目的 <strong>属性（Properties） &gt; C&#x2F;C++ &gt; 代码生成（Code Generation） &gt; 运行时库（Runtime Library）</strong> 可以配置项目所链接到的 C&#x2F;C++ 运行时库。</p><p>由于标准 C 运行时库是在 1970 年左右发明的，该库的发明者没有考虑将 C 运行时库与多线程应用程序配合使用的问题。如果需要创建线程并且希望使用 C&#x2F;C++ 运行时库，那么应该使用 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex"><code>_beginthread</code></a> 而不是 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a>。因为 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a> 没有为 C&#x2F;C++ 运行时库执行一些保障线程安全的处理。</p><blockquote><p>参考：<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads">Microsoft Documentation - Windows&#x2F;Apps&#x2F;Win32&#x2F;Desktop Technologies&#x2F;System Services&#x2F;Processes and Threads</a>。</p></blockquote><h2 id="获取自身的标识"><a href="#获取自身的标识" class="headerlink" title="获取自身的标识"></a>获取自身的标识</h2><p>当线程执行时，它们经常希望调用更改其执行环境的 Windows 函数。例如，线程可能想要更改其优先级（Priority）或其进程的优先级。由于线程更改其（或其进程）环境是很常见的，因此 Windows 提供了一些函数，使线程可以简单地引用其进程内核对象或自己的线程内核对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">GetCurrentProcess</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">HANDLE <span class="hljs-title">GetCurrentThread</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这两个函数都将返回调用线程的进程&#x2F;线程内核对象的伪句柄（Pseudo Handle）。这些函数不会在调用进程的句柄表中创建新句柄。此外，调用这些函数不会影响进程&#x2F;线程内核对象的使用计数。如果调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 并传递伪句柄，那么 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 会简单地返回 <code>FALSE</code>。</p><p>当调用需要进程或线程句柄的 Windows 函数时，可以传递伪句柄。例如，线程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes"><code>GetProcessTimes</code></a> 来查询其进程的时间使用情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;<br><span class="hljs-built_in">GetProcessTimes</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;ftCreationTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime);<br></code></pre></td></tr></table></figure><p>一些 Windows 函数允许通过进程&#x2F;线程的唯一系统范围（Unique Systemwide）ID 来标识特定进程或线程。以下函数允许线程查询其进程的唯一 ID 或其自己的唯一 ID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">GetCurrentProcessId</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">DWORD <span class="hljs-title">GetCurrentThreadId</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="将伪句柄转换为实句柄"><a href="#将伪句柄转换为实句柄" class="headerlink" title="将伪句柄转换为实句柄"></a>将伪句柄转换为实句柄</h3><p>有时可能需要获取线程的实句柄（Real Handle），而不是伪句柄。“实”的意思是明确地标识唯一线程的句柄。比如如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ParentThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    HANDLE hThreadParent = <span class="hljs-built_in">GetCurrentThread</span>();<br>    <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ChildThread, (PVOID) hThreadParent, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// Function continues...</span><br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ChildThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    HANDLE hThreadParent = (HANDLE) pvParam;<br>    FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;<br>    <span class="hljs-built_in">GetThreadTimes</span>(hThreadParent, &amp;ftCreationTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime);<br>    <span class="hljs-comment">// Function continues...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>预期的想法是让父线程将标识父线程的线程句柄传递给子线程。然而父线程传递的是伪句柄，而不是实句柄。当子线程开始执行时，它会将伪句柄传递给 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes"><code>GetThreadTimes</code></a> 函数，这会导致子线程获得自己的 CPU 时间，而不是父线程的 CPU 时间，这是因为线程伪句柄是当前线程的句柄，即伪句柄指代的是正在调用函数的线程。</p><p>要使代码符合预期想法，必须将伪句柄转换为实句柄。可以利用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle"><code>DuplicateHandle</code></a> 函数来完成这件事：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ParentThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    HANDLE hThreadParent;<br><br>    <span class="hljs-built_in">DuplicateHandle</span>(<br>        <span class="hljs-built_in">GetCurrentProcess</span>(),    <span class="hljs-comment">// Handle of process that thread</span><br>                                <span class="hljs-comment">// pseudohandle is relative to</span><br><br>        <span class="hljs-built_in">GetCurrentThread</span>(),     <span class="hljs-comment">// Parent thread&#x27;s pseudohandle</span><br>        <span class="hljs-built_in">GetCurrentProcess</span>(),    <span class="hljs-comment">// Handle of process that the new, real,</span><br>                                <span class="hljs-comment">// thread handle is relative to</span><br><br>        &amp;hThreadParent,         <span class="hljs-comment">// Will receive the new, real, handle</span><br>                                <span class="hljs-comment">// identifying the parent thread</span><br>        <span class="hljs-number">0</span>,                      <span class="hljs-comment">// Ignored due to DUPLICATE_SAME_ACCESS</span><br>        FALSE,                  <span class="hljs-comment">// New thread handle is not inheritable</span><br>        DUPLICATE_SAME_ACCESS); <span class="hljs-comment">// New thread handle has same</span><br>                                <span class="hljs-comment">// access as pseudohandle</span><br><br>    <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, ChildThread, (PVOID) hThreadParent, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// Function continues...</span><br>&#125;<br><br><span class="hljs-function">DWORD WINAPI <span class="hljs-title">ChildThread</span><span class="hljs-params">(PVOID pvParam)</span> </span>&#123;<br>    HANDLE hThreadParent = (HANDLE) pvParam;<br>    FILETIME ftCreationTime, ftExitTime, ftKernelTime, ftUserTime;<br>    <span class="hljs-built_in">GetThreadTimes</span>(hThreadParent, &amp;ftCreationTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime);<br>    <span class="hljs-built_in">CloseHandle</span>(hThreadParent);<br>    <span class="hljs-comment">// Function continues...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Jobs</title>
    <link href="/2022/02/14/windows-via-c-cpp-5th-jobs/"/>
    <url>/2022/02/14/windows-via-c-cpp-5th-jobs/</url>
    
    <content type="html"><![CDATA[<p>Microsoft Windows 提供了<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/job-objects">作业内核对象（Job Kernel Object）</a>，允许将进程组合在一起，并创建一个“沙盒（sandbox）”来限制进程可以执行的操作。最好将作业对象视为进程的容器。创建包含单个进程的作业也是很有用的，因为您可以对该进程施加各种限制。</p><p>如下 <code>StartRestrictedProcess</code> 函数将一个进程放置到一个限制进程执行某些操作的能力的作业中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartRestrictedProcess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Check if we are not already associated with a job.</span><br>    <span class="hljs-comment">// If this is the case, there is no way to switch to another job.</span><br>    BOOL bInJob = FALSE;<br>    <span class="hljs-built_in">IsProcessInJob</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), <span class="hljs-literal">NULL</span>, &amp;bInJob);<br>    <span class="hljs-keyword">if</span> (bInJob) &#123;<br>        <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Process already in a job&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;&quot;</span>), MB_ICONINFORMATION | MB_OK);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Create a job kernel object.</span><br>    HANDLE hjob = <span class="hljs-built_in">CreateJobObject</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Wintellect_RestrictedProcessJob&quot;</span>));<br><br>    <span class="hljs-comment">// Place some restrictions on processes in the job.</span><br><br>    <span class="hljs-comment">// First, set some basic restrictions.</span><br>    JOBOBJECT_BASIC_LIMIT_INFORMATION jobli = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-comment">// The process always runs in the idle priority class.</span><br>    jobli.PriorityClass = IDLE_PRIORITY_CLASS;<br><br>    <span class="hljs-comment">// The job cannot use more than 1 second of CPU time.</span><br>    jobli.PerJobUserTimeLimit.QuadPart = <span class="hljs-number">10000</span>; <span class="hljs-comment">// 1 sec in 100-ns intervals</span><br><br>    <span class="hljs-comment">// These are the only 2 restrictions I want placed on the job (process).</span><br>    jobli.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS | JOB_OBJECT_LIMIT_JOB_TIME;<br>    <span class="hljs-built_in">SetInformationJobObject</span>(hjob, JobObjectBasicLimitInformation, &amp;jobli, <span class="hljs-built_in">sizeof</span>(jobli));<br><br>    <span class="hljs-comment">// Second, set some UI restrictions.</span><br>    JOBOBJECT_BASIC_UI_RESTRICTIONS jobuir;<br>    jobuir.UIRestrictionsClass = JOB_OBJECT_UILIMIT_NONE; <span class="hljs-comment">// A fancy zero</span><br><br>    <span class="hljs-comment">// The process can&#x27;t log off the system.</span><br>    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_EXITWINDOWS;<br><br>    <span class="hljs-comment">// The process can&#x27;t access USER objects (such as other windows) in the system.</span><br>    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_HANDLES;<br>    <br>    <span class="hljs-built_in">SetInformationJobObject</span>(hjob, JobObjectBasicUIRestrictions, &amp;jobuir, <span class="hljs-built_in">sizeof</span>(jobuir));<br><br>    <span class="hljs-comment">// Spawn the process that is to be in the job.</span><br>    <span class="hljs-comment">// Note: You must first spawn the process and then place the process in the job.</span><br>    <span class="hljs-comment">//       This means that the process&#x27; thread must be initially suspended so that</span><br>    <span class="hljs-comment">//       it can&#x27;t execute any code outside of the job&#x27;s restrictions.</span><br>    STARTUPINFO si = &#123; <span class="hljs-built_in">sizeof</span>(si) &#125;;<br>    PROCESS_INFORMATION pi;<br>    TCHAR szCmdLine[<span class="hljs-number">8</span>];<br>    _tcscpy_s(szCmdLine, _countof(szCmdLine), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;CMD&quot;</span>));<br>    BOOL bResult = <span class="hljs-built_in">CreateProcess</span>(<span class="hljs-literal">NULL</span>, szCmdLine, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, CREATE_SUSPENDED | CREATE_NEW_CONSOLE, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi);<br><br>    <span class="hljs-comment">// Place the process in the job.</span><br>    <span class="hljs-comment">// Note: If this process spawns any children, the children are</span><br>    <span class="hljs-comment">//       automatically part of the same job.</span><br>    <span class="hljs-built_in">AssignProcessToJobObject</span>(hjob, pi.hProcess);<br><br>    <span class="hljs-comment">// Now we can allow the child process&#x27; thread to execute code.</span><br>    <span class="hljs-built_in">ResumeThread</span>(pi.hThread);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br><br>    <span class="hljs-comment">// Wait for the process to terminate or</span><br>    <span class="hljs-comment">// for all the job&#x27;s allotted CPU time to be used.</span><br>    HANDLE h[<span class="hljs-number">2</span>];<br>    h[<span class="hljs-number">0</span>] = pi.hProcess;<br>    h[<span class="hljs-number">1</span>] = hjob;<br>    DWORD dw = <span class="hljs-built_in">WaitForMultipleObjects</span>(<span class="hljs-number">2</span>, h, FALSE, INFINITE);<br>    <span class="hljs-keyword">switch</span> (dw - WAIT_OBJECT_0) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">// The process has terminated...</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-comment">// All of the job&#x27;s allotted CPU time was used...</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    FILETIME CreationTime;<br>    FILETIME ExitTime;<br>    FILETIME KernelTime;<br>    FILETIME UserTime;<br>    TCHAR szInfo[MAX_PATH];<br>    <span class="hljs-built_in">GetProcessTimes</span>(pi.hProcess, &amp;CreationTime, &amp;ExitTime, &amp;KernelTime, &amp;UserTime);<br>    <span class="hljs-built_in">StringCchPrintf</span>(szInfo, _countof(szInfo), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Kernel = %u | User = %u\n&quot;</span>),<br>    KernelTime.dwLowDateTime / <span class="hljs-number">10000</span>, UserTime.dwLowDateTime / <span class="hljs-number">10000</span>);<br>    <span class="hljs-built_in">MessageBox</span>(<span class="hljs-built_in">GetActiveWindow</span>(), szInfo, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Restricted Process times&quot;</span>), MB_ICONINFORMATION | MB_OK);<br><br>    <span class="hljs-comment">// Clean up properly.</span><br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(hjob);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：默认情况下，当您通过 Windows 资源管理器（Windows Explorer）启动应用程序时，该进程会自动关联到一个专用作业，其名称以“PCA”字符串为前缀。当作业中的进程退出时，资源管理器可能会收到通知。因此，当由 Windows 资源管理器启动的传统应用程序出现故障时，将触发程序兼容性助手（Program Compatibility Assistant）。从 Shell 中启动应用程序则不会发生这种作业关联。</p></blockquote><h2 id="对作业的进程设置限制"><a href="#对作业的进程设置限制" class="headerlink" title="对作业的进程设置限制"></a>对作业的进程设置限制</h2><p>创建作业后，通常需要设置沙盒（设置限制）以控制作业中的进程可以执行的操作。通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-setinformationjobobject"><code>SetInformationJobObject</code></a> 可以对作业设置几种不同类型的限制：</p><ul><li>基本限制和扩展基本限制，可防止作业中的进程独占系统资源。</li><li>基本 UI 限制，可防止作业中的进程更改用户界面。</li><li>安全限制，可防止作业中的进程访问安全资源（文件、注册表子项等）。</li></ul><p>一旦对作业设置了限制，您可能希望查询这些限制。可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-queryinformationjobobject"><code>QueryInformationJobObject</code></a> 函数轻松地完成此操作。</p><h2 id="在作业中放置进程"><a href="#在作业中放置进程" class="headerlink" title="在作业中放置进程"></a>在作业中放置进程</h2><p>使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-assignprocesstojobobject"><code>AssignProcessToJobObject</code></a> 函数可以将进程放置到作业中，一旦进程被放置到作业中，它就不能被转移到其它作业中。可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi/nf-jobapi-isprocessinjob"><code>IsProcessInJob</code></a> 函数检查进程是否已经在指定的作业中。</p><p>在创建进程后，将进程放置到作业之前，进程并不是作业的一部分，因此它并不会受到作业的限制，进程可以在这段时间内执行开发者预期要限制的事情。可以在创建计划要放置到作业中的进程时，在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 时使用 <code>CREATE_SUSPENDED</code> 标志。这将会创建新进程，但不允许该进程执行任何代码。在将进程放置到作业后，可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><code>ResumeThread</code></a> 函数使进程中的线程恢复执行。</p><h2 id="终止作业中的所有进程"><a href="#终止作业中的所有进程" class="headerlink" title="终止作业中的所有进程"></a>终止作业中的所有进程</h2><p>要想终止作业中的所有进程，只需调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-terminatejobobject"><code>TerminateJobObject</code></a>。这类似于为作业中的每个进程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a>，并将其退出代码设置为 <code>uExitCode</code>。</p><h2 id="作业通知"><a href="#作业通知" class="headerlink" title="作业通知"></a>作业通知</h2><p>通知允许您获知与作业相关的事件。例如，作业中的所有进程何时终止了，或者所有分配的 CPU 时间是否已到期了？作业中何时产生了新进程，或者作业中的进程何时终止了？</p><p>如果您关心的是所有分配的 CPU 时间是否已到期，则可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 或类似函数来捕获此事件。这是因为一旦用完所有分配的 CPU 时间，Windows 就会终止作业中的所有进程并将作业对象置于已示意（signaled）。随后，您可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-setinformationjobobject"><code>SetInformationJobObject</code></a> 并给予作业更多的 CPU 时间来将作业对象重置回未示意（nonsignaled）状态。</p><p>如果需要获得更高级的通知信息（如进程的创建&#x2F;终止），那么必须创建 I&#x2F;O 完成端口内核对象（I&#x2F;O Completion Port Kernel Object），并将作业对象或对象与其关联。然后，必须有一个或多个线程在完成端口上等待作业通知到达，以便可以对其进行处理。</p><p>创建 I&#x2F;O 完成端口后，通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-setinformationjobobject"><code>SetInformationJobObject</code></a> 将作业与其关联，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">JOBOBJECT_ASSOCIATE_COMPLETION_PORT joacp;<br>joacp.CompletionKey = <span class="hljs-number">1</span>; <span class="hljs-comment">// Any value to uniquely identify this job</span><br>joacp.CompletionPort = hIOCP; <span class="hljs-comment">// Handle of completion port that receives notifications</span><br><span class="hljs-built_in">SetInformationJobObject</span>(hJob, JobObjectAssociateCompletionPortInformation, &amp;joacp, <span class="hljs-built_in">sizeof</span>(jaocp));<br></code></pre></td></tr></table></figure><p>上述代码执行后，系统将监视作业，并在事件发生时将其发布到 I&#x2F;O 完成端口。线程通常通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><code>GetQueuedCompletionStatus</code></a> 来监视 I&#x2F;O 完成端口。</p><p>最后需要注意的一点是：默认情况下，作业对象被配置为当作业分配的 CPU 时间到期时，作业的所有进程都将自动终止，并且不会发布 <code>JOB_OBJECT_MSG_END_OF_JOB_TIME</code> 通知。如果要防止作业对象终止进程，而只是通知您已超过时间，则必须执行如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Create a JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure and initialize its only member.</span><br>JOBOBJECT_END_OF_JOB_TIME_INFORMATION joeojti;<br>joeojti.EndOfJobTimeAction = JOB_OBJECT_POST_AT_END_OF_JOB;<br><br><span class="hljs-comment">// Tell the job object what we want it to do when the job time is exceeded.</span><br><span class="hljs-built_in">SetInformationJobObject</span>(hJob, JobObjectEndOfJobTimeInformation, &amp;joeojti, <span class="hljs-built_in">sizeof</span>(joeojti));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Processes</title>
    <link href="/2022/02/09/windows-via-c-cpp-5th-processes/"/>
    <url>/2022/02/09/windows-via-c-cpp-5th-processes/</url>
    
    <content type="html"><![CDATA[<p>进程（Process）通常被定义为正在运行的程序实例，由两部分组成：</p><ul><li>一个被操作系统用来管理进程的内核对象。这个内核对象也是系统用来存放关于进程的统计信息的地方。</li><li>一个包含所有可执行文件（executable）或 DLL（动态链接库，Dynamic-Link Library）模块的代码和数据的地址空间。它还包含了动态内存分配，如线程栈和堆的分配。</li></ul><p>进程是惰性的。对于要完成任何事情的进程，它必须具有在其上下文（context）中运行的线程（thread），线程负责执行进程地址空间中的代码。单个进程可能包含多个线程，这些线程在进程的地址空间中“同时地（simultaneously）”执行代码。为此，每个线程都有自己的一组 CPU 寄存器（register）和栈（stack）。每个进程至少有一个线程。创建进程时，系统会自动创建其第一个线程，称为<em>主线程（primary thread）</em>。此线程可以创建其他线程，而这些线程又可以创建更多线程。如果在进程的地址空间中没有执行代码的线程，则该进程没有理由继续存在，并且系统将自动销毁进程及其地址空间。</p><p>操作系统会为每个线程安排一些 CPU 时间，通过轮询（round-robin）方式为线程提供时间片（称为<em>quantum</em>），让人产生所有线程同时运行的错觉。若机器具有多个 CPU，则操作系统用于在 CPU 上对线程进行负载平衡的算法会很复杂。Microsoft Windows 可以同时在每个 CPU 上安排不同的线程，以便多个线程真正地同时运行。Windows 内核负责处理此类系统上线程的所有管理和调度。</p><h1 id="windows-应用程序的起点"><a href="#windows-应用程序的起点" class="headerlink" title="Windows 应用程序的起点"></a>Windows 应用程序的起点</h1><p>Windows 支持两种应用类型：GUI（Graphical User Interface）应用和 CUI（Console User Interface）应用。使用 Microsoft Visual Studio 创建应用工程时，集成环境会设置各种链接器开关，以便链接器在生成的可执行文件中嵌入正确类型的子系统。GUI 应用的链接器开关是 <code>/SUBSYSTEM:WINDOWS</code>；CUI 应用的链接器开关是 <code>/SUBSYSTEM:CONSOLE</code>。当用户运行应用程序时，操作系统的加载器会查看可执行映像的标头（header）并获取子系统值。</p><p>Windows 应用程序必须具有一个在应用程序开始运行时被调用的入口点函数，具体取决于应用的类型和是否使用 Unicode：</p><blockquote><p>注：操作系统实际上并不调用您编写的入口点函数。相反，它调用由 C&#x2F;C++ 运行时实现的 C&#x2F;C++ 运行时启动函数，并在链接时设置 <code>-entry:</code> 命令行选项。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> WINAPI _tWinMain(<br>    HINSTANCE hInstanceExe,<br>    HINSTANCE,<br>    PTSTR pszCmdLine,<br>    <span class="hljs-type">int</span> nCmdShow);<br><br><span class="hljs-type">int</span> _tmain(<br>    <span class="hljs-type">int</span> argc,<br>    TCHAR *argv[],<br>    TCHAR *envp[]);<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">Application Type</th><th align="left">Entry Point</th><th align="left">Startup Function Embedded in Your Executable</th></tr></thead><tbody><tr><td align="left">GUI application that wants ANSI characters and strings</td><td align="left">_tWinMain (WinMain)</td><td align="left">WinMainCRTStartup</td></tr><tr><td align="left">GUI application that wants Unicode characters and strings</td><td align="left">_tWinMain (wWinMain)</td><td align="left">wWinMainCRTStartup</td></tr><tr><td align="left">CUI application that wants ANSI characters and strings</td><td align="left">_tmain (Main)</td><td align="left">mainCRTStartup</td></tr><tr><td align="left">CUI application that wants Unicode characters and strings</td><td align="left">_tmain (Wmain)</td><td align="left">wmainCRTStartup</td></tr></tbody></table><p>链接器负责在链接可执行文件时选择正确的 C&#x2F;C++ 运行时启动函数。如果指定了 <code>/SUBSYSTEM:WINDOWS</code> 链接器开关，则链接器希望找到 <code>WinMain</code> 或 <code>wWinMain</code> 函数。如果这两个函数都不存在，那么链接器将返回“未解析的外部符号（unresolved external symbol）”错误；否则，它会调用 <code>WinMainCRTStartup</code> 或 <code>wWinMainCRTStartup</code> 函数。同样，如果指定了 <code>/SUBSYSTEM:CONSOLE</code> 链接器开关，则链接器希望找到 <code>main</code> 或 <code>wmain</code> 函数，并调用 <code>mainCRTStartup</code> 或 <code>wmainCRTStartup</code> 函数。</p><blockquote><p>注：如果未指定 <code>/SUBSYSTEM</code> 链接器开关，那么链接器会检查代码中是否存在四个函数（<code>WinMain</code>、<code>wWinMain</code>、<code>main</code>、<code>wmain</code>）之一，并以此来推断应该将哪个子系统及 C&#x2F;C++ 启动函数嵌入到可执行文件中。</p></blockquote><p>所有 C&#x2F;C++ 运行时启动函数基本上都执行相同的操作，不同之处在于它们是处理 ANSI 还是 Unicode 字符串，以及在初始化 C 运行时库后调用哪个入口点函数：</p><ul><li>检索指向新进程的完整命令行的指针。</li><li>检索指向新进程环境变量的指针。</li><li>初始化 C&#x2F;C++ 运行时的全局变量。</li><li>初始化 C 运行时内存分配函数（<code>malloc</code> 和 <code>calloc</code>）和其他低级输入&#x2F;输出例程使用的堆。</li><li>调用所有全局的和静态的 C++ 类对象的构造函数。</li></ul><p>在初始化这些之后，C&#x2F;C++ 启动函数会调用应用的入口点函数。如果你编写了一个 <code>_tWinMain</code> 函数并且启用了 <code>_UNICODE</code>，则调用如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GetStartupInfo</span>(&amp;StartupInfo);<br><span class="hljs-type">int</span> nMainRetVal = <span class="hljs-built_in">wWinMain</span>((HINSTANCE)&amp;_ImageBase, <span class="hljs-literal">NULL</span>, pszCommandLineUnicode,<br>    (StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW)<br>        ? StartupInfo.wShowWindow : SW_SHOWDEFAULT);<br></code></pre></td></tr></table></figure><blockquote><p>注：<code>_ImageBase</code> 是链接器定义的伪变量，它展示可执行文件映射到应用程序内存的位置。</p></blockquote><p>如果你编写了一个 <code>_tmain</code> 函数并且启用了 <code>_UNICODE</code>，则调用如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> nMainRetVal = <span class="hljs-built_in">wmain</span>(argc, argv, envp);<br></code></pre></td></tr></table></figure><p>当入口点函数返回时，启动函数会使用返回值 <code>nMainRetVal</code> 调用 C 运行时 <code>exit</code> 函数，<code>exit</code> 函数会执行如下操作：</p><ul><li>调用任何通过调用 <code>_onexit</code> 函数注册的函数。</li><li>调用所有全局的和静态的 C++ 类对象的析构函数。</li><li>在 <code>DEBUG</code> 构建中，如果已设置 <code>_CRTDBG_LEAK_CHECK_DF</code> 标志，则 C&#x2F;C++ 运行时内存管理中的泄漏将通过调用 <code>_CrtDumpMemoryLeaks</code> 函数列出。</li><li>调用操作系统的 <code>ExitProcess</code> 函数，并将 <code>nMainRetVal</code> 传递给它。这会导致操作系统终止进程并设置其退出码。</li></ul><h2 id="进程实例句柄"><a href="#进程实例句柄" class="headerlink" title="进程实例句柄"></a>进程实例句柄</h2><p>加载到进程地址空间中的每个可执行文件或 DLL 文件都分配有一个唯一的实例句柄。可执行文件的实例将作为 <code>(w)WinMain</code> 的第一个参数 <code>hInstanceExe</code>。加载资源的调用通常需要句柄的值，如要从可执行文件的映像中加载图标资源，则需要调用以下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HICON <span class="hljs-title">LoadIcon</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszIcon)</span></span>;<br></code></pre></td></tr></table></figure><p>某些函数需要 <code>HMODULE</code> 类型的参数，如 <code>GetModuleFileName</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">GetModuleFileName</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HMODULE hInstModule,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTSTR pszPath,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD cchPath)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>注：事实上，<code>HMODULE</code> 和 <code>HINSTANCE</code> 是一样的东西。如果函数的文档指示需要 <code>HMODULE</code>，那么可以传递一个 <code>HINSTANCE</code>，反之亦然。定义出两个数据类型是因为在 16 位 Windows 中，它们所标识的东西是不同的。</p></blockquote><p><code>(w)WinMain</code> 的 <code>hInstanceExe</code> 参数的实际值是系统将可执行文件的映像加载到进程地址空间中的内存基址。加载可执行文件映像的基址由链接器确定，可以使用 Microsoft 链接器的 <a href="https://docs.microsoft.com/en-us/cpp/build/reference/base-base-address"><code>/BASE:address</code></a> 链接器开关更改应用程序加载到的基址。</p><p>可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew"><code>GetModuleHandle</code></a> 函数来检索进程已加载的指定模块。</p><h2 id="进程的前一个实例句柄"><a href="#进程的前一个实例句柄" class="headerlink" title="进程的前一个实例句柄"></a>进程的前一个实例句柄</h2><p>C&#x2F;C++ 运行时启动代码始终将 <code>NULL</code> 传递给 <code>(w)WinMain</code> 的 <code>hPrevInstance</code> 参数。此参数在 16 位 Windows 中使用，保留此参数仅仅是为了简化 16 位 Windows 应用程序的移植。请切勿在代码中引用此参数。</p><h2 id="进程的命令行"><a href="#进程的命令行" class="headerlink" title="进程的命令行"></a>进程的命令行</h2><p>创建新进程时，将传递该进程的命令行。命令行至少包含用于创建新进程的可执行文件的名称（第一个标记）。当 C 运行时的启动代码开始执行 GUI 应用程序时，它会通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinew"><code>GetCommandLine</code></a> Windows 函数来检索进程的完整命令行，它会跳过可执行文件的名称，并将指向命令行其余部分的指针传递给 <code>WinMain</code> 的 <code>pszCmdLine</code> 参数。</p><p><code>ShellAPI.h</code> 中声明了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw"><code>CommandLineToArgvW</code></a> 函数，可用于辅助命令行标记的提取。</p><h2 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h2><p>每个进程都有一个与之关联的环境块。环境块是在进程的地址空间内分配的内存块，其中包含一组具有以下外观的字符串：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">=<span class="hljs-symbol">:</span><span class="hljs-symbol">:</span>=<span class="hljs-symbol">:</span><span class="hljs-symbol">:</span>\ ...<br>VarName1=VarValue1\0<br>VarName2=VarValue2\0<br>VarName3=VarValue3\0 ...<br>VarNameX=VarValueX\0<br>\0<br></code></pre></td></tr></table></figure><p>每个字符串的第一部分是环境变量的名称，后跟一个等号，等号后是要分配给变量的值。</p><blockquote><p>注：除了第一个 <code>=::=::\ ...</code> 字符串之外，块中的其他一些字符串可能以 <code>=</code> 字符开头。在这种情况下，这些字符串不会用作环境变量。</p></blockquote><p>有两种访问环境块的方法。第一种方法是通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings"><code>GetEnvironmentStrings</code></a> 函数来检索完整的环境块。第二种方法是通过 <a href="https://docs.microsoft.com/en-us/cpp/c-language/main-function-and-program-execution"><code>main</code></a> 入口点收到的 <code>TCHAR* env[]</code> 参数（仅适用于 CUI 应用程序）。</p><p>当用户登录到 Windows 时，系统将创建 shell 进程，并将一组环境字符串与其关联。系统通过检查注册表（registry）中的两个键（key）来获取环境字符串的初始集。第一个键包含适用于系统的所有环境变量的列表：<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</code>；第二个键包含适用于当前登录用户的所有环境变量的列表：<code>HKEY_CURRENT_USER\Environment</code>。用户可以在 <strong>控制面板（Control Panel） &gt; 系统（System） &gt; 高级系统设置（Advanced System Settings） &gt; 环境变量（Environment Variables）</strong> 中维护这些环境变量。</p><blockquote><p>注：只有具有管理员权限的用户才能更改 <strong>系统变量（System Variables）</strong> 列表中包含的变量。</p></blockquote><p>应用程序可以使用各种注册表函数来修改这些注册表项。但是，要使更改对所有应用程序生效，用户必须注销，然后重新登录。某些应用程序（如资源管理器、任务管理器和控制面板）可以在其主窗口收到 <code>WM_SETTINGCHANGE</code> 消息时使用新的注册表项更新其环境块。如果应用程序更新了注册表项，并希望让感兴趣的应用程序更新其环境块，则可以进行以下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SendMessage</span>(HWND_BROADCAST, WM_SETTINGCHANGE, <span class="hljs-number">0</span>, (LPARAM) <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Environment&quot;</span>));<br></code></pre></td></tr></table></figure><p>通常，子进程会继承父进程的环境变量。父进程可以在创建子进程时决定子进程的环境变量。由于子进程继承的环境变量是拷贝所得而不是引用所得的，所以后续父、子进程对环境变量的修改不会相互影响。</p><p>如果要使用环境变量，则应用程序可以利用一些函数：</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable"><code>GetEnvironmentVariable</code></a> 函数用于确定环境变量的存在和值。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-expandenvironmentstringsw"><code>ExpandEnvironmentStrings</code></a> 函数用于解析包含可替换字符串的内容，由一对百分号包裹的部分指示为可替换字符串，如 <code>%USERPROFILE%\Documents</code>，<code>%USERPROFILE%</code> 将替换为环境变量 <code>USERPROFILE</code> 的值。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-setenvironmentvariablew"><code>SetEnvironmentVariable</code></a> 函数用于添加、删除或修改环境变量的值。</li></ul><h2 id="进程的亲和性"><a href="#进程的亲和性" class="headerlink" title="进程的亲和性"></a>进程的亲和性</h2><p>通常，进程中的线程可以在主机中的任何 CPU 上执行。但是，也可以强制进程的线程在可用 CPU 的子集上运行，这称为处理器亲和性（processor affinity）。子进程会继承其父进程的亲和性。</p><h2 id="进程的错误模式"><a href="#进程的错误模式" class="headerlink" title="进程的错误模式"></a>进程的错误模式</h2><p>每个进程有一组相关联的标志，这些标志告诉系统进程应如何响应严重错误，包括磁盘介质故障、未处理的异常、文件查找故障和数据未对齐等。进程可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode"><code>SetErrorMode</code></a> 函数来告诉系统如何处理这些每个错误。</p><p>默认情况下，子进程继承其父进程的错误模式标志。即如果进程打开了 <code>SEM_NOGPFAULTERRORBOX</code> 标志，然后产生了一个子进程，那么子进程也将打开此标志。但是，子进程不会收到有关此问题的通知，并且子进程可能尚未编写如何处理 GP 故障。如果子进程的某个线程发生了 GP 故障，则子进程可能会在不通知用户的情况下终止。父进程可以通过在调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 时指定 <code>CREATE_DEFAULT_ERROR_MODE</code> 标志来防止子进程继承其错误模式。</p><h2 id="进程的当前驱动器和目录"><a href="#进程的当前驱动器和目录" class="headerlink" title="进程的当前驱动器和目录"></a>进程的当前驱动器和目录</h2><p>系统在内部跟踪进程的当前驱动器（Drive）和目录（Directory）。这些信息是基于每个进程进行维护的，因此在进程中更改当前驱动器或目录会更改进程中所有线程的此信息。当进程调用需要路径的函数时，若没有提供完整的路径，则会基于当前驱动器和目录进行查找。</p><p>可以通过调用以下两个函数来获取和设置进程的当前驱动器和目录：</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory"><code>GetCurrentDirectory</code></a></li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory"><code>SetCurrentDirectory</code></a></li></ul><h3 id="进程的当前目录"><a href="#进程的当前目录" class="headerlink" title="进程的当前目录"></a>进程的当前目录</h3><p>系统会跟踪进程的当前驱动器和目录，但不会跟踪每个驱动器的当前目录。但是，有一些操作系统支持处理多个驱动器的当前目录。此支持通过进程的环境字符串提供。例如，一个进程可以有两个环境变量，如下所示：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">=<span class="hljs-symbol">C:</span>=<span class="hljs-symbol">C:</span>\Utility\Bin<br>=<span class="hljs-symbol">D:</span>=<span class="hljs-symbol">D:</span>\Program Files<br></code></pre></td></tr></table></figure><p>这些变量指示进程的驱动器 C 的当前目录是 <code>\Utility\Bin</code>，而其驱动器 D 的当前目录是 <code>\Program Files</code>。</p><p>如果调用一个函数，并传递一个驱动器限定名称（如：<code>D:readme.txt</code>）以指示驱动器不是当前驱动器，那么系统将在进程的环境块中查找与指定驱动器号关联的变量。如果变量存在，则系统将使用变量的值作为当前目录；如果变量不存在，则系统会假定当前目录为驱动器的根目录。</p><blockquote><p>注：可以使用 C 运行时函数 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/chdir-wchdir"><code>_chdir</code></a> 替代 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory"><code>SetCurrentDirectory</code></a> 来改变当前目录。与 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory"><code>SetCurrentDirectory</code></a> 不同，<a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/chdir-wchdir"><code>_chdir</code></a> 还会添加或修改环境变量，因此会保留不同驱动器的当前目录。</p></blockquote><p>可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew"><code>GetFullPathName</code></a> 来获取其当前目录，如获取驱动器 C 的当前目录：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TCHAR szCurDir[MAX_PATH];<br>DWORD cchLength = <span class="hljs-built_in">GetFullPathName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;C:&quot;</span>), MAX_PATH, szCurDir, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h2 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h2><p>有时候应用程序需要确定用户正在运行哪个版本的 Windows，可以使用如下函数获取相关信息：</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion"><code>GetVersion</code></a>，最开始是为 16 位 Windows 设计的。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversionexw"><code>GetVersionEx</code></a>，<a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion"><code>GetVersion</code></a> 的增强版。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-verifyversioninfow"><code>VerifyVersionInfo</code></a>，从 Windows Vista 开始提供的。</li></ul><blockquote><p>注：最新的方法应该查看 <a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/windows-system-information">Microsoft Documentation - Windows&#x2F;Apps&#x2F;Win32&#x2F;Desktop Technologies&#x2F;System Services&#x2F;Windows System Information</a>。</p></blockquote><h1 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h1><p>使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 函数可以创建进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTSTR pszCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psaProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psaThread,</span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD fdwCreate,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszCurDir,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSTARTUPINFO psiStartInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">    PPROCESS_INFORMATION ppiProcInfo)</span></span>;<br></code></pre></td></tr></table></figure><p>调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 函数时，系统会创建一个进程内核对象（Process Kernel Object），并将其使用计数初始化为 1。进程内核对象不是进程本身，而是操作系统用于管理进程的小型数据结构。系统会为新进程创建一个虚拟地址空间，并将可执行文件的代码和数据以及任何所需的 DLL 加载到进程的地址空间中。</p><p>然后，系统会为新进程的主线程创建一个线程内核对象（Thread Kernel Object），并将其使用计数初始化为 1。与进程内核对象一样，线程内核对象是操作系统用于管理线程的小型数据结构。主线程会从执行 C&#x2F;C++ 运行时启动代码开始。如果系统成功地创建新进程和主线程，则 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 将返回 <code>TRUE</code>。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 会在进程完全初始化之前返回 <code>TRUE</code>。这意味着操作系统加载器尚未尝试查找所有必需的 DLL。如果找不到 DLL 或无法正确初始化，则进程将终止。由于 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw"><code>CreateProcess</code></a> 返回 <code>TRUE</code>，因此父进程不会知道任何初始化的问题。</p></blockquote><h1 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h1><p>进程可以通过四种方式终止：</p><ul><li>从主线程的入口点函数返回。（强烈建议这样做）</li><li>进程中的一个线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 函数。（避免使用此方法）</li><li>另一个进程中的线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a> 函数。（避免使用此方法）</li><li>进程中的所有线程自行终止。（很少会发生）</li></ul><p>当一个进程终止时，以下动作会被执行：</p><ol><li>进程中任何剩余的线程会被终止。</li><li>释放进程分配的所有 User 和 GDI 对象，并关闭所有内核对象。</li><li>进程的退出码从 <code>STILL_ACTIVE</code> 更改为传递给 <code>ExitProcess</code> 或 <code>TerminateProcess</code> 的退出码。</li><li>进程内核对象的状态变为已示意（signaled）。</li><li>进程内核对象的使用计数递减 1。</li></ol><blockquote><p>注：进程终止后，其相关的进程内核对象不一定会被销毁，因为可能有其它进程正在使用它。如 A 进程持有已打开的 B 进程相关的进程内核对象句柄，A 进程可以使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess"><code>GetExitCodeProcess</code></a> 函数来获取 B 进程的终止状态，若 B 未终止，则通过输出参数 <code>pdwExitCode</code> 返回 <code>STILL_ACTIVE</code>；否则返回 B 的退出码。</p></blockquote><h2 id="从主线程的入口点函数返回"><a href="#从主线程的入口点函数返回" class="headerlink" title="从主线程的入口点函数返回"></a>从主线程的入口点函数返回</h2><p>应将应用程序设计为仅在从主线程的入口点函数返回时终止，这是保证正确清理所有主线程资源的唯一方法。</p><p>从主线程的入口点函数返回可确保以下内容：</p><ul><li>此线程创建的任何 C++ 对象都将使用其析构函数正确销毁。</li><li>系统将正确释放线程栈使用的内存。</li><li>系统会将进程的退出码（保存在进程内核对象中）设置为入口点函数的返回值。</li><li>系统将递减进程内核对象的使用计数。</li></ul><h2 id="进程中的一个线程调用-exitprocess-函数"><a href="#进程中的一个线程调用-exitprocess-函数" class="headerlink" title="进程中的一个线程调用 ExitProcess 函数"></a>进程中的一个线程调用 ExitProcess 函数</h2><p>当进程中的一个线程调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 时，进程将终止，操作系统保证该进程的所有进程或线程的系统资源会得到很好的清理。</p><p>然而显式地调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 可能会导致 C&#x2F;C++ 运行时无法正确地清理，如下代码所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSomeObj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CSomeObj</span>()  &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Constructor\r\n&quot;</span>); &#125;<br>    ~<span class="hljs-built_in">CSomeObj</span>() &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Destructor\r\n&quot;</span>); &#125;<br>&#125;;<br><br>CSomeObj g_GlobalObj;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    CSomeObj LocalObj;<br>    <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// This shouldn&#x27;t be here</span><br><br>    <span class="hljs-comment">// At the end of this function, the compiler automatically added</span><br>    <span class="hljs-comment">// the code necessary to call LocalObj&#x27;s destructor.</span><br>    <span class="hljs-comment">// ExitProcess prevents it from executing.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码只会看到：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Constructor</span></span><br></code></pre></td></tr></table></figure><p>C++ 对象未被正确销毁！这是因为 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 会强制进程马上终止，导致 C&#x2F;C++ 运行时没有机会进行清理。</p><h2 id="另一个进程中的线程调用-terminateprocess-函数"><a href="#另一个进程中的线程调用-terminateprocess-函数" class="headerlink" title="另一个进程中的线程调用 TerminateProcess 函数"></a>另一个进程中的线程调用 TerminateProcess 函数</h2><p>与 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess"><code>ExitProcess</code></a> 相同，调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a> 也会终止进程。不同的是，任何线程都可以调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a> 来终止另一个进程或自身的进程。</p><p>仅当无法使用其他方法强制进程退出时，才应使用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a>。被终止的进程不会收到关于它正在终止的通知（这意味着应用程序可能无法正确地进行清理），也无法防止自身被终止（正常安全机制除外）。例如，进程可能无法将其内存中包含的数据刷写到磁盘，但其使用的系统资源（如打开的文件对象）会被完全地清理。</p><blockquote><p>注：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess"><code>TerminateProcess</code></a> 函数是异步的。因此，如果需要确定进程已终止，那么可能需要调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject"><code>WaitForSingleObject</code></a> 或类似的函数。</p></blockquote><h2 id="进程中的所有线程自行终止"><a href="#进程中的所有线程自行终止" class="headerlink" title="进程中的所有线程自行终止"></a>进程中的所有线程自行终止</h2><p>如果进程中的所有线程自行终止（可能因为它们都调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread"><code>ExitThread</code></a> 或它们都被 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread"><code>TerminateThread</code></a> 终止），那么进程的退出码将被设置为与终止运行的最后一个线程相同的退出码。</p><h1 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h1><p>在设计应用程序时，可能会遇到希望请求执行另一个任务，但同时希望原本任务继续执行的情况。其中一种解决方法是创建一个新的进程，让新进程执行另一个任务。</p><p>如果要创建新进程，让它执行一些任务并等待结果，则可以使用类似于如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PROCESS_INFORMATION pi;<br>DWORD dwExitCode;<br><br><span class="hljs-comment">// Spawn the child process.</span><br>BOOL fSuccess = <span class="hljs-built_in">CreateProcess</span>(..., &amp;pi);<br><span class="hljs-keyword">if</span> (fSuccess) &#123;<br>    <span class="hljs-comment">// Close the thread handle as soon as it is no longer needed!</span><br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br><br>    <span class="hljs-comment">// Suspend our execution until the child has terminated.</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);<br><br>    <span class="hljs-comment">// The child process terminated; get its exit code.</span><br>    <span class="hljs-built_in">GetExitCodeProcess</span>(pi.hProcess, &amp;dwExitCode);<br><br>    <span class="hljs-comment">// Close the process handle as soon as it is no longer needed.</span><br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，应用程序会将另一个进程作为分离的进程（Detached Process）启动。这意味着在创建并执行进程后，父进程不再需要与新进程进行交互。若要放弃与子进程的所有关联，则父进程必须通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 来关闭其拥有的新进程及其主线程的句柄。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PROCESS_INFORMATION pi;<br><br><span class="hljs-comment">// Spawn the child process.</span><br>BOOL fSuccess = <span class="hljs-built_in">CreateProcess</span>(..., &amp;pi);<br><span class="hljs-keyword">if</span> (fSuccess) &#123;<br>    <span class="hljs-comment">// Allow the system to destroy the process &amp; thread kernel</span><br>    <span class="hljs-comment">// objects as soon as the child process terminates.</span><br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Kernel Objects</title>
    <link href="/2022/02/07/windows-via-c-cpp-5th-kernel-objects/"/>
    <url>/2022/02/07/windows-via-c-cpp-5th-kernel-objects/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是内核对象？"><a href="#什么是内核对象？" class="headerlink" title="什么是内核对象？"></a>什么是内核对象？</h1><p>Windows 内核对象（Kernel Object）是一个包含资源维护信息的结构化内存块。系统创建并维护若干类型的<a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">内核对象</a>，如访问令牌对象（access token object）。因为内核对象的数据结构只能被内核访问，所以用户程序只能通过调用 Windows 函数来创建和维护这些对象。当调用了会创建内核对象的函数时，函数会返回一个句柄（handle）以标识所创建的对象。</p><p>句柄是进程相关的，因此直接将句柄值传递给其它进程是没有意义的。但是可以通过“<a href="#%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%BE%B9%E7%95%8C%E5%85%B1%E4%BA%AB%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1">跨进程边界共享内核对象（Sharing Kernel Objects Across Process Boundaries）</a>”来实现进程间的内核对象共享。</p><h2 id="使用计数"><a href="#使用计数" class="headerlink" title="使用计数"></a>使用计数</h2><p>内核对象是属于内核的而不是进程的，这意味着内核对象的生命周期不一定与进程的生命周期一致。内核通过每个对象中包含的一个使用计数（usage count）来获知有多少进程正在使用它。</p><p>使用计数是内核对象最通用的数据成员之一。当对象首次被创建时，其使用计数会被设置为 1；然后，当另一个进程访问它时，使用计数就递增 1。当一个进程终止时，内核会自动递减该进程仍然打开的所有内核对象的使用计数。如果内核对象的使用计数为 0，那么内核就会销毁该对象。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>可以使用安全描述符（security descriptor）来保护内核对象。安全描述符描述了对象的属主和对象的访问权限。安全描述符通常用于编写服务器应用。</p><p>大多数用于创建内核对象的函数有一个指向 <code>SECURITY_ATTRIBUTES</code> 结构的指针参数，如 <code>CreateFileMapping</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFileMapping</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hFile,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psa,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD flProtect,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwMaximumSizeHigh,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwMaximumSizeLow,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszName)</span></span>;<br></code></pre></td></tr></table></figure><p>大多数应用会简单地向该参数传递 <code>NULL</code> 以使用默认的安全。</p><h1 id="进程的内核对象句柄表"><a href="#进程的内核对象句柄表" class="headerlink" title="进程的内核对象句柄表"></a>进程的内核对象句柄表</h1><p>当一个进程被初始化时，系统会为其分配一个句柄表。这个表只用于内核对象，而不会用于用户对象或 GDI 对象。没有文档介绍如何处理和管理这个表，但其大体上如下：</p><table><thead><tr><th align="left">Index</th><th align="left">Pointer to Kernel Object Memory Block</th><th align="left">Access Mask (DWORD of Flag Bits)</th><th align="left">Flags</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0x????????</td><td align="left">0x????????</td><td align="left">0x????????</td></tr><tr><td align="left">2</td><td align="left">0x????????</td><td align="left">0x????????</td><td align="left">0x????????</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><h2 id="创建内核对象"><a href="#创建内核对象" class="headerlink" title="创建内核对象"></a>创建内核对象</h2><p>当进程首次被初始化时，它的句柄表是空的。然后，当进程中的线程调用创建内核对象的函数（如 <code>CreateFileMapping</code>）时，内核就会为该对象分配一个内存块并初始化它。接着，内核会对进程的句柄表进行扫描以找出一个空项，然后记录下对象的相关信息。</p><p>用于创建内核对象的函数都会返回与进程相关的句柄，这些句柄可以被同一进程中运行的任一或所有线程使用。</p><p>当调用一个接受内核对象句柄作为参数的函数时，应当传递一个由 <strong>Create*</strong> 函数返回的值。如果传递了一个无效的句柄，那么该函数会返回失败，并且 <code>GetLastError</code> 返回 6（<code>ERROR_INVALID_HANDLE</code>）。如果调用函数以创建内核对象但调用失败了，那么返回的句柄值通常是 0（<code>NULL</code>），这是由于系统内存不足或者遇到了安全问题；少数函数在失败时返回的句柄值是 -1（<code>INVALID_HANDLE_VALUE</code>）。因此，当查看会创建内核对象的函数返回值时，必须格外小心。</p><h2 id="关闭内核对象"><a href="#关闭内核对象" class="headerlink" title="关闭内核对象"></a>关闭内核对象</h2><p>可以通过调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a> 来关闭一个已打开的内核对象句柄。</p><p>该函数首先会检查调用进程的句柄表，以确保句柄值的合法性。如果该句柄是有效的，那么系统会递减该内核对象的使用计数（若使用计数为 0，则从内存中销毁该内核对象）；如果句柄是无效的，那么 <code>CloseHandle</code> 会返回 <code>FALSE</code> 并且 <code>GetLastError</code> 会返回 <code>ERROR_INVALID_HANDLE</code>（若进程处于调试状态下，则系统会抛出异常 0xC0000008 “An invalid handle was specified”）。</p><p><code>CloseHandle</code> 返回前会清除进程句柄表中相应的项，因此传递给 <code>CloseHandle</code> 的句柄将在进程中失效，后续上下文中不应该再使用它。</p><h1 id="跨进程边界共享内核对象"><a href="#跨进程边界共享内核对象" class="headerlink" title="跨进程边界共享内核对象"></a>跨进程边界共享内核对象</h1><p>有三种允许进程共享内核对象的机制：</p><ul><li>对象句柄继承（Object Handle Inheritance）</li><li>命名对象（Naming Object）</li><li>复制对象句柄（Duplicating Object Handle）</li></ul><h2 id="对象句柄继承"><a href="#对象句柄继承" class="headerlink" title="对象句柄继承"></a>对象句柄继承</h2><p>仅当进程间存在父子关系时才能使用对象句柄继承。在这种场景下，父进程有一个或多个可用的内核对象，父进程决定产生一个子进程并赋予子进程访问父进程的内核对象。为此，父进程必须执行如下步骤。</p><p>首先，当父进程创建内核对象时，父进程必须向系统指示它希望该对象的句柄是可继承的。为了创建可继承的句柄，父进程必须分配并初始化 <code>SECURITY_ATTRIBUTES</code> 结构，并将该结构的地址传递给特定的 <strong>Create</strong> 函数。下面的代码创建一个互斥对象（mutex object），并得到一个可继承的句柄：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SECURITY_ATTRIBUTES sa;<br>sa.nLength = <span class="hljs-built_in">sizeof</span>(sa);<br>sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>sa.bInheritHandle = TRUE; <span class="hljs-comment">// Make the returned handle inheritable.</span><br><br>HANDLE hMutex = <span class="hljs-built_in">CreateMutex</span>(&amp;sa, FALSE, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>下一步，父进程调用 <code>CreateProcess</code> 函数来产生子进程，其中传递 <code>TRUE</code> 给 <code>bInheritHandles</code> 参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">    PTSTR pszCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psaProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psaThread,</span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID pvEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPSTARTUPINFO pStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">    PPROCESS_INFORMATION pProcessInformation)</span></span>;<br></code></pre></td></tr></table></figure><p>由于 <code>bInheritHandles</code> 参数为 <code>TRUE</code>，所以系统在创建子进程时会为其初始化一个空的进程句柄表，并且遍历父进程的进程句柄表以找出那些可继承的句柄项，然后将这些句柄项复制到子进程的进程句柄表的相同位置（这意味着这些句柄值在父子进程中是相同的）。此外，系统还会递增这些内核对象的使用计数。之后，父子进程对这些句柄的维护是独立的，即父进程关闭句柄不会影响到子进程。</p><blockquote><p>注：对象句柄继承仅在生成子进程时应用。若父进程要使用可继承的句柄创建任何新的内核对象，则已在运行的子进程将不会继承这些新句柄。</p></blockquote><p>对象句柄继承有一个奇怪的特征：子进程不知道它继承了什么句柄。这通常需要一些方法（如命令行参数、进程间通信、环境变量等）来告知子进程它所继承的句柄的值。</p><h3 id="更改句柄的标志"><a href="#更改句柄的标志" class="headerlink" title="更改句柄的标志"></a>更改句柄的标志</h3><p>有时，父进程可能需要产生多个子进程，但只希望其中几个子进程继承对象句柄。这种情况下可以使用 <code>SetHandleInformation</code> 函数来改变内核对象句柄的继承标志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">SetHandleInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hObject,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwMask,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwFlags)</span></span>;<br></code></pre></td></tr></table></figure><p><code>hObject</code> 标识一个有效的句柄，<code>dwMask</code> 告知函数哪些标志需要更改，<code>dwFlags</code> 指示需要将标志设置为什么。</p><p>当前，每个句柄都有两个关联的标志，可以通过或运算来同时操作两个标志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HANDLE_FLAG_INHERIT             0x00000001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002</span><br></code></pre></td></tr></table></figure><p>若要打开继承标志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SetHandleInformation</span>(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);<br></code></pre></td></tr></table></figure><p>若要关闭继承标志：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SetHandleInformation</span>(hObj, HANDLE_FLAG_INHERIT, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code> 标志告知系统此句柄不应允许被关闭。关闭打开了该标志的句柄会失败或发生异常（调试状态下）。</p><h2 id="命名对象"><a href="#命名对象" class="headerlink" title="命名对象"></a>命名对象</h2><p>大多数内核对象可以被命名。如下函数可以创建命名的互斥量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateMutex</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PSECURITY_ATTRIBUTES psa,</span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL bInitialOwner,</span></span><br><span class="hljs-params"><span class="hljs-function">    PCTSTR pszName)</span></span>;<br></code></pre></td></tr></table></figure><p>大多数的内核对象创建函数具有一个通用的最后参数 <code>pszName</code>。如果此参数为 <code>NULL</code>，那么系统将创建匿名的内核对象，否则创建指定名字的对象。命名的内核对象可以通过名字来共享。<code>pszName</code> 接受一个零结尾（zero-terminated）的字符串，其最大长度为 <code>MAX_PATH</code>。</p><blockquote><p>注：Microsoft 没有提供内核对象的命名指南，所有内核对象共享单个命名空间，因此需要注意赋予给内核对象的名字是否已存在。</p></blockquote><p>通过命名来共享对象的方式如下，假设进程 A 启动并调用如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hMutexProcessA = <span class="hljs-built_in">CreateMutex</span>(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;JeffMutex&quot;</span>));<br></code></pre></td></tr></table></figure><p>随后，假设进程 B 启动并调用如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE hMutexProcessB = <span class="hljs-built_in">CreateMutex</span>(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;JeffMutex&quot;</span>));<br></code></pre></td></tr></table></figure><p>当进程 B 调用 <code>CreateMutex</code> 时，系统会先检查名字为“JeffMutex”的内核对象是否已存在，然后会检查对象的类型。由于 B 尝试创建互斥量，并且已存在的名字为“JeffMutex”的对象也是互斥量，因此系统会进行安全检查以查看调用方是否具有对该对象的完全访问权限。若有，则系统将在 B 的句柄表中找出一个空条目，并将该条目初始化为指向现有的内核对象。若对象类型不匹配，或者调用方被拒绝访问，则 <code>CreateMutex</code> 将失败。</p><p>当 B 调用的 <code>CreateMutex</code> 成功返回时，实际上并没有创建一个互斥量，而是简单地引用了系统中已存在的同名互斥量。因此“JeffMutex”的使用计数将递增。此外，与对象句柄继承不一样，B 中的句柄值不必与 A 中的相同。</p><p>可以使用 <strong>Open*</strong> 函数来替代 <strong>Create*</strong> 函数以引用已存在的内核对象，如 <code>OpenMutex</code>。与对应的 <strong>Create*</strong> 函数一样，<strong>Open*</strong> 函数也有一个通用的最后参数 <code>pszName</code>。不同的是，如果指定名字的内核对象不存在时，<strong>Create*</strong> 函数会创建它，而 <strong>Open*</strong> 函数只会简单地返回失败。</p><blockquote><p>贴士：可以通过创建一个 GUID 并将其字符串表示作为对象名字来确保对象的唯一性。</p></blockquote><blockquote><p>贴士：可以利用对象名字的唯一性来防止应用程序运行多个实例，如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> WINAPI _tWinMain(HINSTANCE hInstExe, HINSTANCE, PTSTR pszCmdLine, <span class="hljs-type">int</span> nCmdShow) &#123;<br>    HANDLE h = <span class="hljs-built_in">CreateMutex</span>(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;&#123;FA531CC1-0497-11d3-A180-00105A276C3E&#125;&quot;</span>));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() == ERROR_ALREADY_EXISTS) &#123;<br>        <span class="hljs-comment">// There is already an instance of this application running.</span><br>        <span class="hljs-comment">// Close the object and immediately return.</span><br>        <span class="hljs-built_in">CloseHandle</span>(h);<br>        <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// This is the first instance of this application running.</span><br>    ...<br>    <span class="hljs-comment">// Before exiting, close the object.</span><br>    <span class="hljs-built_in">CloseHandle</span>(h);<br>    <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="终端服务命名空间"><a href="#终端服务命名空间" class="headerlink" title="终端服务命名空间"></a>终端服务命名空间</h3><p>终端服务（Terminal Services）会使上述假设的情景发生一些变化。运行终端服务的机器具有多个为内核对象准备的命名空间：一个全局命名空间（通常被服务所使用），用于所有客户端会话都可以访问的内核对象；每个客户端会话都拥有自己的命名空间。</p><p>如果希望获知进程正在运行在哪个终端服务会话上，那么可以使用 <code>ProcessIdToSessionId</code> 函数。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD processID = <span class="hljs-built_in">GetCurrentProcessId</span>();<br>DWORD sessionID;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ProcessIdToSessionId</span>(processID, &amp;sessionID)) &#123;<br>    <span class="hljs-built_in">tprintf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Process &#x27;%u&#x27; runs in Terminal Services session &#x27;%u&#x27;&quot;</span>), processID, sessionID);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ProcessIdToSessionId might fail if you don&#x27;t have enough rights</span><br>    <span class="hljs-comment">// to access the process for which you pass the ID as parameter.</span><br>    <span class="hljs-comment">// Notice that it is not the case here because we&#x27;re using our own process ID.</span><br>    <span class="hljs-built_in">tprintf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Unable to get Terminal Services session ID for process &#x27;%u&#x27;&quot;</span>), processID);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务的命名内核对象始终位于全局命名空间中。默认情况下，在终端服务中，应用程序的命名内核对象位于会话的命名空间中。但是，可以通过在名字前面加上“Global\”前缀来强制命名对象进入全局命名空间，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE h = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Global\\MyName&quot;</span>));<br></code></pre></td></tr></table></figure><p>也可以通过在名字前面加上“Local\”前缀来显式声明希望内核对象位于当前会话的命名空间中，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HANDLE h = <span class="hljs-built_in">CreateEvent</span>(<span class="hljs-literal">NULL</span>, FALSE, FALSE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Local\\MyName&quot;</span>));<br></code></pre></td></tr></table></figure><p>Microsoft 将 <em>Global</em> 和 <em>Local</em> 视为保留关键字，除非强制使用特定的命名空间，否则不应在对象名称中使用这些关键字。Microsoft 还认为 <em>Session</em> 是一个保留关键字。</p><blockquote><p>注：所有这些保留关键字都区分大小写。</p></blockquote><h2 id="复制对象句柄"><a href="#复制对象句柄" class="headerlink" title="复制对象句柄"></a>复制对象句柄</h2><p>使用 <code>DuplicateHandle</code> 函数可以复制对象句柄：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">DuplicateHandle</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hSourceProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hSourceHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hTargetProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    PHANDLE phTargetHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL bInheritHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwOptions)</span></span>;<br></code></pre></td></tr></table></figure><p>此函数获取一个进程的句柄表中的条目，并将该条目复制到另一个进程的句柄表中。</p><p><code>hSourceProcessHandle</code> 和 <code>hTargetProcessHandle</code> 必须是进程内核对象句柄，并且必须与调用 <code>DuplicateHandle</code> 函数的进程相关联。</p><p><code>hSourceHandle</code> 可以是任何类型的内核对象句柄，并且其必须与 <code>hSourceProcessHandle</code> 所标识的进程相关联。</p><p><code>phTargetHandle</code> 是一个 <code>HANDLE</code> 变量的地址，该变量用于接收复制后与 <code>hTargetProcessHandle</code> 所标识的进程相关联的句柄值。</p><p>最后的三个参数用于指示目标进程的内核对象句柄项使用的访问掩码和继承标志。<code>dwOptions</code> 可以是 0 或 <code>DUPLICATE_SAME_ACCESS</code> 与 <code>DUPLICATE_CLOSE_SOURCE</code> 的任意组合。指定 <code>DUPLICATE_SAME_ACCESS</code> 会使目标句柄的访问掩码与源句柄的一致，并且使 <code>DuplicateHandle</code> 忽略 <code>dwDesiredAccess</code> 参数。指定 <code>DUPLICATE_CLOSE_SOURCE</code> 会起到在源进程中关闭句柄的效果，源进程可以轻松地将内核对象移交给目标进程，内核对象的使用计数不受影响。</p><p>复制对象句柄也存在与对象句柄继承一样的奇怪特征：目标进程不会收到任何关于有新内核对象可用的通知。由于复制对象句柄发生在目标进程运行之后，因此这通常需要使用进程间通信来告知目标进程新可用内核对象的句柄值。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Working with Characters and Strings</title>
    <link href="/2022/01/28/windows-via-c-cpp-5th-working-with-characters-and-strings/"/>
    <url>/2022/01/28/windows-via-c-cpp-5th-working-with-characters-and-strings/</url>
    
    <content type="html"><![CDATA[<p>在 Windows Vista 中，每个 Unicode 字符都使用 UTF-16（Unicode Transformation Format）进行编码。UTF-16 将每个字符编码为 16 位，当 16 位不足以表示所有字符时，其将使用代理（surrogate），代理是一种使用 32 位来表示单个字符的方法。</p><p>从 Windows NT 起，所有 Windows 版本都是使用 Unicode 从头开始构建的。也就是说，用于创建窗口、显示文本、执行字符串操作等的所有核心函数都需要 Unicode 字符串。如果你通过传递 ANSI 字符串来调用任何 Windows 函数，那么函数会首先将该字符串转换为 Unicode，然后将 Unicode 字符串传递给操作系统。如果希望从函数返回 ANSI 字符串，则系统会在返回到应用程序之前将 Unicode 字符串转换为 ANSI 字符串。所有这些转换都是在您看不见的情况下发生的。当然，系统执行所有这些字符串转换需要时间和内存开销。</p><p>当 Windows 公开那些需要字符串作为参数的函数时，它通常会提供两个版本：以大写 W 结尾的接受 Unicode 字符串；以大写 A 结尾的接受 ANSI 字符串，如 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexw"><code>CreateWindowExW</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexa"><code>CreateWindowExA</code></a>。然而我们通常调用的是无后缀的函数（如 <code>CreateWindowEx</code>），这使我们可以通过宏定义 <code>UNICODE</code> 来控制编译时使用那个版本的函数。</p><blockquote><p>注：使用 Visual Studio 创建新项目时，默认定义了 <code>UNICODE</code>。这意味着默认使用 W 版本函数。</p></blockquote><blockquote><p>注：在 Windows Vista 下，A 版本函数只是一个简单的翻译层，它会分配内存以将 ANSI 字符串转换为 Unicode 字符串，然后调用 W 版本函数，当 W 版本函数返回后，A 版本函数会释放掉它分配的内存，最后将结果返回给你。因此应用程序需要更多内存并且运行速度相对较慢。从一开始就使用 Unicode 开发应用程序，可以使应用程序更有效地执行。此外，Windows 的这些翻译函数中存在一些众所周知的 bug，因此避免使用它们也可以消除一些潜在的 bug。如果你要创建动态链接库（DLL）给其它开发者使用，那么建议你将函数导出为两个版本：W 版本和 A 版本，其中 A 版本仅作为一个简单的翻译层。这样可以与 Windows 函数的风格保持一致。</p></blockquote><p>Windows API 中的某些函数，如 <code>WinExec</code> 和 <code>OpenFile</code> 是为了保持对 16-bit Windows 程序的兼容，新的应用开发应该避免使用它们。</p><p>与 Windows 函数一样，C 运行时库提供了一组函数来操作 ANSI 字符和字符串（如 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strlen-wcslen-mbslen-mbslen-l-mbstrlen-mbstrlen-l?view=msvc-170"><code>strlen</code></a>），另一组函数来操作 Unicode 字符和字符串（如 <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strlen-wcslen-mbslen-mbslen-l-mbstrlen-mbstrlen-l?view=msvc-170"><code>wcslen</code></a>）。但是，与 Windows 函数不同，这些函数的 ANSI 版本不会将字符串转换为 Unicode，然后在内部调用函数的 Unicode 版本。</p><p>任何修改字符串的函数都会显露出潜在的危险：如果目标字符串缓冲区不够大，无法包含生成的字符串，则会发生内存损坏。下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The following puts 4 characters in a</span><br><span class="hljs-comment">// 3-character buffer, resulting in memory corruption</span><br>WCHAR szBuffer[<span class="hljs-number">3</span>] = <span class="hljs-string">L&quot;&quot;</span>;<br><span class="hljs-built_in">wcscpy</span>(szBuffer, <span class="hljs-string">L&quot;abc&quot;</span>); <span class="hljs-comment">// The terminating 0 is a character too!</span><br></code></pre></td></tr></table></figure><p><code>strcpy</code> 和 <code>wcscpy</code> 函数（以及大多数其他字符串操作函数）的问题在于，它们不接受指定缓冲区最大大小的参数，因此，该函数不知道它正在损坏内存。Microsoft 现在提供了一组新函数，这些函数取代了 C 运行时库提供的不安全的字符串操作函数（如 <code>wcscat</code>）。若要编写安全的代码，不应再使用任何熟悉的修改字符串的 C 运行时函数。相反，您应该利用 Microsoft 的 <code>StrSafe.h</code> 文件定义的安全的字符串函数。</p><p>对于许多打开文本文件并对其进行处理的应用程序（如编译器），如果在打开文件后，应用程序可以确定文本文件是否包含 ANSI 字符或 Unicode 字符，这将非常方便。由AdvApi32导出并在中声明的IsTextUnicode函数.dll可以帮助进行以下区分：</p><p>由 <code>AdvApi32.dll</code> 导出并由 <code>WinBase.h</code> 声明的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-istextunicode"><code>IsTextUnicode</code></a> 函数用于确定缓冲区是否可能包含某种形式的 Unicode 文本。该函数使用一系列统计和确定性方法来猜测缓冲区的内容。由于这不是一门精确的科学，因此该函数可能会返回不正确的结果。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows via C/C++, 5th Edition - Error Handling</title>
    <link href="/2022/01/28/windows-via-c-cpp-5th-error-handling/"/>
    <url>/2022/01/28/windows-via-c-cpp-5th-error-handling/</url>
    
    <content type="html"><![CDATA[<p>调用 Windows 函数时，它会检查传参的合法性然后执行任务。如果传参非法或执行失败，那么系统将返回一个值以指明原因。下表列出大多数 Windows 函数的返回值的数据类型：</p><table><thead><tr><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>VOID</code></td><td align="left">表明函数不可能发生错误。</td></tr><tr><td align="left"><code>BOOL</code></td><td align="left">失败时返回 0；否则返回非零值。避免测试这种函数的返回值是否为 <code>TRUE</code>，最好测试其是否为 <code>FALSE</code>。</td></tr><tr><td align="left"><code>HANDLE</code></td><td align="left">失败时通常会返回 <code>NULL</code>，某些函数可会返回 <code>INVALID_HANDLE_VALUE</code>（定义为 -1）；否则返回 <code>HANDLE</code>，其标识一个可操作对象。函数的 Platform SDK 文档会指明返回值的含义。</td></tr><tr><td align="left"><code>PVOID</code></td><td align="left">失败时返回 <code>NULL</code>；否则返回 <code>PVOID</code>，其标识一个数据块的内存地址。</td></tr><tr><td align="left"><code>LONG</code>&#x2F;<code>DWORD</code></td><td align="left">返回计数的函数通常返回一个 <code>LONG</code> 或 <code>DWORD</code>。如果函数由于某些原因而无法进行计数，则它通常会返回 0 或 -1。调用返回这种数据类型的函数时应该阅读 Platform SDK 文档以确保返回值的含义。</td></tr></tbody></table><p>Microsoft 编译了一个所有可能的错误码的列表，并且为每个错误码分配了一个 32-bit 的编号，编号的规则如下：</p><table><thead><tr><th align="left">Bits:</th><th align="left">31-30</th><th align="left">29</th><th align="left">28</th><th align="left">27-16</th><th align="left">15-0</th></tr></thead><tbody><tr><td align="left">Contents</td><td align="left">Severity</td><td align="left">Microsoft&#x2F;customer</td><td align="left">Reserved</td><td align="left">Facility code</td><td align="left">Exception code</td></tr><tr><td align="left">Meaning</td><td align="left">0 &#x3D; Success<br>1 &#x3D; Informational<br>2 &#x3D; Warning<br>3 &#x3D; Error</td><td align="left">0 &#x3D; Microsoft-defined code<br>1 &#x3D; customer-defined code</td><td align="left">Must be 0</td><td align="left">The first 256 values are reserved by Microsoft</td><td align="left">Microsoft&#x2F;customer-defined code</td></tr></tbody></table><p>如果要创建自定义的错误码，那么根据规定应该将错误码的第 29 位置为 1 以避免与 Microsoft 定义的错误码发生冲突。</p><p>当一个 Windows 函数检测到错误时，它会使用一个称为线程本地存储（Thread-local storage）的机制，将相应的错误码与调用的线程关联起来。这种机制使线程间的错误码不会相互影响。当函数返回时，其返回值就会指明是否发生错误，若要确认是什么错误，则可以调用 <code>GetLastError</code> 函数以获取与线程关联的错误码。</p><blockquote><p>注：由于 <code>GetLastError</code> 返回的是线程产生的最后一个错误，并且一些 Windows 函数即使没有发生错误也可能会改写线程关联的错误码。所以 <code>GetLastError</code> 应该在调用 Windows 函数并判断其发生错误后调用才有意义。</p></blockquote><blockquote><p>技巧：在 Microsoft Visual Studio 中调试程序时，可以在 Watch 窗口中使用 <code>@err, hr</code> 表达式对线程错误码进行观察。Microsoft Visual Studio 还附带一个称为 Error Lookup 的实用工具（Tools &gt; Error Lookup）可以将错误码转换成对应的文本描述。</p></blockquote><p>Windows 提供 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessage"><code>FormatMessage</code></a> 函数，可以将错误码转换成对应的文本描述。</p>]]></content>
    
    
    <categories>
      
      <category>My Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Windows via C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Qt5 显示乱码问题</title>
    <link href="/2021/05/09/solve-qt5-mojibake/"/>
    <url>/2021/05/09/solve-qt5-mojibake/</url>
    
    <content type="html"><![CDATA[<p>对于在 Windows 上进行 Qt 开发的小伙伴来说，乱码可能是一个较为头疼的问题。</p><p><a href="https://doc.qt.io/qt-5/windows.html">Qt for Windows</a> 支持两种编译器：MSVC 和 MinGW-GCC。本文将介绍使用这两种编译器而出现乱码问题的解决办法。如果在 Linux 上也出现了乱码，则可以参考 MinGW-GCC 的做法。</p><h1 id="mingw-gcc"><a href="#mingw-gcc" class="headerlink" title="MinGW-GCC"></a>MinGW-GCC</h1><p>如果使用的编译器是 MinGW-GCC，一般来说不会遇到乱码问题。出现乱码问题很大可能是因为源文件的编码格式不是 UTF-8（通常是由于代码在 Windows 与 Linux 间共享而造成的）。这时候请检查你自己编写的源文件是否为其他编码格式，若是，则统一改为 UTF-8 编码后再次构建工程。</p><p>在 Qt Creator 中可以通过 Tools &gt; Options… &gt; Text Editor &gt; Behavior 中的 File Encodings 下的 Default encoding 更改默认的文本编码格式，建议设置为 UTF-8。</p><h1 id="msvc"><a href="#msvc" class="headerlink" title="MSVC"></a>MSVC</h1><p>使用 MSVC 编译器遇到乱码问题的可能性会相对高一点。这是因为 MSVC 在文本文件不带 BOM 时会将文件的编码格式假定为当前系统区域设置所对应的编码格式，比如 Windows 中文版的默认编码格式为 GBK。换句话说，如果源文件的编码格式为 UTF-8，那么在 Windows 中文版下 MSVC 会将这些源文件当作 GBK 编码格式处理，这就很容易导致乱码。</p><blockquote><p>建议将源文件统一编码为 UTF-8，方便不同平台的共享。</p></blockquote><p>为了解决这个问题，MSVC 提供了编译选项 <code>/utf-8</code>，该选项将源文件字符集和执行字符集都指定为 UTF-8。</p><p>如果使用 qmake 作为项目构建工具，则可以在 <code>.pro</code> 文件中添加：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">wi<span class="hljs-symbol">n32</span>:ms<span class="hljs-attr">vc:QMAKE_CXXFLAGS += /utf-8</span><br></code></pre></td></tr></table></figure><p>如果使用 CMake 作为项目构建工具，则可以在 <code>CMakeLists.txt</code> 文件中添加：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span> (MSVC)<br>    <span class="hljs-keyword">add_compile_options</span>(/utf-<span class="hljs-number">8</span>)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>修改后重新构建项目即可解决乱码问题。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt5</tag>
      
      <tag>MSVC</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 下移除不需要的内核</title>
    <link href="/2021/04/25/remove-unneeded-kernels-in-ubuntu/"/>
    <url>/2021/04/25/remove-unneeded-kernels-in-ubuntu/</url>
    
    <content type="html"><![CDATA[<p>在 Ubuntu Linux 下如果经常更新内核，那么磁盘中可能会存留大量的旧内核。由于这些旧内核几乎不会再被使用，所以我们可以手动清理它们以腾出更多的磁盘空间</p><blockquote><p>注：移除内核具有一定的风险，执行这些操作的前提是你明白自己在干什么！！！</p></blockquote><h1 id="查看当前内核信息"><a href="#查看当前内核信息" class="headerlink" title="查看当前内核信息"></a>查看当前内核信息</h1><p>在移除旧内核前，我们应该查看当前正在使用的内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p>该命令将输出如下相似的内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">72</span>-generic<br></code></pre></td></tr></table></figure><h1 id="查看已安装的内核"><a href="#查看已安装的内核" class="headerlink" title="查看已安装的内核"></a>查看已安装的内核</h1><p>使用如下命令可以获得系统中已安装的内核列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg --list | grep linux-image<br></code></pre></td></tr></table></figure><p>该命令将输出如下相似的内容（不包含前五行，这是为了方便读者理解每列的含义而添加的）：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">Desired=Unknown/Install/Remove/Purge/Hold<br>| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend<br>|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)<br>||/ Name                                       Version                                          Architecture Description<br>+++-==========================================-================================================-============-============================<br>rc  linux-image-<span class="hljs-number">5.4.0-42</span>-generic               <span class="hljs-number">5.4.0-42</span>.<span class="hljs-number">46~18.04.1</span>                              amd64        Signed kernel image generic<br>rc  linux-image-<span class="hljs-number">5.4.0-67</span>-generic               <span class="hljs-number">5.4.0-67</span>.<span class="hljs-number">75~18.04.1</span>                              amd64        Signed kernel image generic<br>rc  linux-image-<span class="hljs-number">5.4.0-70</span>-generic               <span class="hljs-number">5.4.0-70</span>.<span class="hljs-number">78~18.04.1</span>                              amd64        Signed kernel image generic<br>ii  linux-image-<span class="hljs-number">5.4.0-71</span>-generic               <span class="hljs-number">5.4.0-71</span>.<span class="hljs-number">79~18.04.1</span>                              amd64        Signed kernel image generic<br>ii  linux-image-<span class="hljs-number">5.4.0-72</span>-generic               <span class="hljs-number">5.4.0-72</span>.<span class="hljs-number">80~18.04.1</span>                              amd64        Signed kernel image generic<br>ii  linux-image-generic-hwe-<span class="hljs-number">18</span>.<span class="hljs-number">04</span>              <span class="hljs-number">5.4.0.72</span>.<span class="hljs-number">80~18.04.65</span>                             amd64        Generic Linux kernel image<br></code></pre></td></tr></table></figure><h1 id="移除旧内核"><a href="#移除旧内核" class="headerlink" title="移除旧内核"></a>移除旧内核</h1><p>在上一节的输出中，我们可以确定自己需要移除的内核版本（如上节输出中，可以选择移除 <code>linux-image-5.4.0-71-generic</code>）。</p><p>使用包管理工具移除内核（以 <code>linux-image-5.4.0-71-generic</code> 为示例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt purge linux-image-5.4.0-71-generic<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cannot find -lGL</title>
    <link href="/2021/03/25/cannot-find-lgl/"/>
    <url>/2021/03/25/cannot-find-lgl/</url>
    
    <content type="html"><![CDATA[<p>在 Ubuntu 18.04 LTS 上编译 Qt 库时发生了错误，提示如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/ld: cannot find -lGL<br>collect2: error: ld returned <span class="hljs-number">1</span> <span class="hljs-keyword">exit</span> status<br></code></pre></td></tr></table></figure><p>这是由于缺少了 <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> 库。<a href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics)">Mesa 3D</a> 是一个开源的 OpenGL 实现，可以通过安装它来解决问题。</p><p>在 Ubuntu 上可以执行以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install libgl1-mesa-dev<br></code></pre></td></tr></table></figure><p>通过 <code>locate</code> 命令，可以看到 GL 库已安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">locate libGL.so<br>/usr/lib/i386-linux-gnu/libGL.so<br>/usr/lib/i386-linux-gnu/libGL.so.1<br>/usr/lib/i386-linux-gnu/libGL.so.1.0.0<br>/usr/lib/x86_64-linux-gnu/libGL.so.1<br>/usr/lib/x86_64-linux-gnu/libGL.so.1.0.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt5</tag>
      
      <tag>ld</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 代理</title>
    <link href="/2021/03/17/git-proxy/"/>
    <url>/2021/03/17/git-proxy/</url>
    
    <content type="html"><![CDATA[<p>由于国内特殊的原因，我们访问 <a href="https://github.com/">GitHub</a> 的速度十分缓慢。尽管如此，我们仍然需要经常地访问它，毕竟它是全球最活跃的开源代码托管站。</p><p>Git 支持使用 ssh 和 http(s) 协议进行传输。因此我们可以对其使用代理（梯子）来提高克隆 GitHub 仓库的速度。在默认情况下，国内克隆 GitHub 上的仓库的速度可能只有 15 ~ 30 KB&#x2F;s，而使用代理则可以达到 1 ~ 10 MB&#x2F;s（具体取决于代理的速度）。</p><p>现在你需要拥有一个代理（至于如何获得代理，请自行百度&#x2F;谷歌），本文假定两个代理：</p><ul><li>http 代理：<code>127.0.0.1:1080</code></li><li>socks5 代理：<code>127.0.0.1:1081</code></li></ul><h2 id="代理-http-s-传输"><a href="#代理-http-s-传输" class="headerlink" title="代理 http(s) 传输"></a>代理 http(s) 传输</h2><p>Git 支持 http(s) 代理功能，仅仅需要简单的配置即可开启该功能：</p><p>使用 http 代理来代理 Git 的 http(s) 传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;http://127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;http://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure><p>或使用 socks5 代理来代理 Git 的 http(s) 传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1081&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;socks5://127.0.0.1:1081&#x27;</span><br></code></pre></td></tr></table></figure><p>如果需要取消 Git 的 http(s) 传输代理，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><h2 id="代理-ssh-传输"><a href="#代理-ssh-传输" class="headerlink" title="代理 ssh 传输"></a>代理 ssh 传输</h2><p>利用 <a href="https://www.openssh.com/">OpenSSH</a> 的 <a href="https://man.openbsd.org/ssh_config#ProxyCommand">ProxyCommand</a> 特性，可以实现 ssh 传输的代理。</p><p>默认情况下，ssh 会自己建立与目标机器的连接。如果启用了 ProxyCommand 特性，则 ProxyCommand 所指定的命令负责建立连接，ssh 会直接使用命令所建立的连接。</p><p>通过 <a href="https://en.wikipedia.org/wiki/Netcat">netcat</a> 或 <a href="https://github.com/gotoh/ssh-connect">ssh-connect</a> 可以建立连接以供 ssh 使用。</p><blockquote><p>注：<br>大部分 Unix&#x2F;Linux 都默认安装了 netcat，一般为 <code>nc</code> 命令，而 Windows 则需要另行安装。<br>如果不想在 Windows 上安装 netcat，那么可以使用 Git-Bash 自带的 <code>connect.exe</code>（即 ssh-connect）来替代 netcat。</p></blockquote><p>修改 OpenSSH 的 <code>config</code> 文件（Unix&#x2F;Linux&#x2F;Git-Bash：<code>~/.ssh/config</code>；Windows：<code>%USERPROFILE%/.ssh/config</code>），添加如下内容之一：</p><ul><li>netcat<ul><li>使用 http 代理：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Host github.com<br>    HostName github.com<br>    User git<br>    ProxyCommand nc -v -X connect -x 127.0.0.1:1080 %h %p<br></code></pre></td></tr></table></figure></li><li>使用 socks5 代理：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Host github.com<br>    HostName github.com<br>    User git<br>    ProxyCommand nc -v -x 127.0.0.1:1081 %h %p<br></code></pre></td></tr></table></figure></li></ul></li><li>ssh-connect<ul><li>使用 http 代理：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Host github.com<br>    HostName github.com<br>    User git<br>    ProxyCommand connect -H 127.0.0.1:1080 %h %p<br></code></pre></td></tr></table></figure></li><li>使用 socks5 代理：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Host github.com<br>    HostName github.com<br>    User git<br>    ProxyCommand connect -S 127.0.0.1:1081 %h %p<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>修改后保存即可。后续的 <code>git</code> 命令若使用 ssh 协议进行传输，则会利用此代理。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 Qt5 添加 MQTT 模块</title>
    <link href="/2021/01/13/add-mqtt-module-for-qt5/"/>
    <url>/2021/01/13/add-mqtt-module-for-qt5/</url>
    
    <content type="html"><![CDATA[<p><a href="http://mqtt.org/">MQTT</a> 是一种利用发布&#x2F;订阅范式的机对机（M2M）协议，目前在物联网应用中十分流行。</p><p>在 Qt5 中，Qt 官方的 MQTT 模块属于 <a href="https://doc.qt.io/QtForAutomation/index.html">Qt for Automation</a> 的一部分。因此商用版的 Qt5 可以很方便地使用 MQTT 模块，使用方法请参考官方文档 <a href="https://doc.qt.io/QtMQTT/index.html">Qt MQTT</a> 。</p><p>然而大部分个人开发者（比如我）都用不起商用版，所以本文介绍如何为开源版 Qt5 添加 MQTT 模块，使得开源版也可以像商业版一样方便地使用 MQTT 模块。</p><blockquote><p>提醒：QtMQTT 采用 <a href="https://www.qt.io/company">Qt Company</a> 和 <a href="https://www.gnu.org/licenses/gpl-3.0.html">GPLv3</a> 两种许可进行分发。开源版的分发许可为 GPLv3，因此商业应用需要考虑许可问题。</p></blockquote><p>本文假定读者有基本的 Qt 开发基础和 Git 使用基础，并已安装 Qt5 的开发工具链（建议使用官方的安装包进行安装）和 Git 工具。Windows 环境下请确保已安装 <a href="https://www.perl.org/">perl</a>，因为 Qt 的命令工具 <code>syncqt.pl</code> 需要 perl。</p><h1 id="下载-qtmqtt-源码"><a href="#下载-qtmqtt-源码" class="headerlink" title="下载 QtMQTT 源码"></a>下载 QtMQTT 源码</h1><p>目前有两个地方可以获取 QtMQTT 的源码：</p><ul><li><a href="https://codereview.qt-project.org/admin/repos/qt%2Fqtmqtt">Qt Code Review</a></li><li><a href="https://github.com/qt/qtmqtt">GitHub</a></li></ul><p>这里使用 GitHub 地址为例，拉取源码库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/qt/qtmqtt.git<br></code></pre></td></tr></table></figure><p>切换工作目录到源码库目录，并变更分支到对应的 Qt 版本（这里以 5.15.0 为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> qtmqtt<br>git checkout 5.15.0<br></code></pre></td></tr></table></figure><h1 id="在-linux-下编译并安装-qtmqtt"><a href="#在-linux-下编译并安装-qtmqtt" class="headerlink" title="在 Linux 下编译并安装 QtMQTT"></a>在 Linux 下编译并安装 QtMQTT</h1><p>在 <code>qtmqtt</code> 目录下使用 <code>qmake</code> 命令生成用于构建模块的 Makefile 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qmake<br></code></pre></td></tr></table></figure><p>构建模块，并将模块安装到 Qt 的安装目录中（详情见 Makefile 文件）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">make all<br><span class="hljs-comment"># 此处省略构建输出的信息</span><br><span class="hljs-comment"># ...</span><br><br>make install<br><span class="hljs-comment"># 此处省略安装输出的信息</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h2 id="安装-qtmqtt-文档"><a href="#安装-qtmqtt-文档" class="headerlink" title="安装 QtMQTT 文档"></a>安装 QtMQTT 文档</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make docs<br>make install_docs<br></code></pre></td></tr></table></figure><blockquote><p>注意：在 Linux 下构建的文档可能无法正常显示（由于 <code>qtmqtt.qch</code> 文件有错）。可以在 Windows 下构建文档然后将其 <code>qtmqtt\doc</code> 中的 <code>qtmqtt.qch</code> 文件复制到 Linux 下的 Qt 安装目录的文档目录下（如：<code>Qt/Docs/Qt-5.15.0</code>）。</p></blockquote><h2 id="安装-qtmqtt-示例"><a href="#安装-qtmqtt-示例" class="headerlink" title="安装 QtMQTT 示例"></a>安装 QtMQTT 示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make sub-examples-install_subtargets<br></code></pre></td></tr></table></figure><h1 id="在-windows-下编译并安装-qtmqtt"><a href="#在-windows-下编译并安装-qtmqtt" class="headerlink" title="在 Windows 下编译并安装 QtMQTT"></a>在 Windows 下编译并安装 QtMQTT</h1><p>在 Windows 下进行编译需要用到 MSVC。以 VS2019 为例，默认安装下 VS2019 并不会将 MSVC 的运行环境配置到系统的 <code>PATH</code> 中，官方给出的建议是使用 VS2019 提供的批处理文件来自动配置 MSVC 的运行环境。这些批处理文件位于 <code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build</code> 中，其中 <code>vcvars32.bat</code> 用于配置 32-bit 的运行环境；<code>vcvars64.bat</code> 用于配置 64-bit 的运行环境。</p><blockquote><p>注意：<code>MinGW</code> 用户请参考 Linux。</p></blockquote><p>以 64-bit 为例，打开 <code>cmd</code>，切换其工作目录到 <code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build</code> 然后执行批处理文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">vcvars64.bat<br></code></pre></td></tr></table></figure><p>在 Windows 下，Qt 的命令工具同样也需要配置运行环境。Qt 官方提供了批处理文件 <code>qtenv2.bat</code> 用于配置 Qt 命令工具的运行环境。这个批处理文件位于 Qt 安装目录下对应编译器目录的 <code>bin</code> 目录下。</p><p>切换工作目录到 Qt 的 <code>bin</code> 目录下（如 <code>C:\Qt\5.15.0\msvc2019_64\bin</code>），然后执行 <code>qtenv2.bat</code> 以配置 Qt 命令工具的运行环境：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">qtenv2.bat<br></code></pre></td></tr></table></figure><p>将工作目录切换到 QtMQTT 的源码库目录，执行 <code>qmake</code> 命令生成用于构建模块的 Makefile 文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">qmake<br></code></pre></td></tr></table></figure><p>构建模块，并将模块安装到 Qt 的安装目录中（详情见 Makefile 文件）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">nmake all<br><span class="hljs-comment"># 此处省略构建输出的信息</span><br><span class="hljs-comment"># ...</span><br><br>nmake install<br><span class="hljs-comment"># 此处省略安装输出的信息</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h2 id="安装-qtmqtt-文档-1"><a href="#安装-qtmqtt-文档-1" class="headerlink" title="安装 QtMQTT 文档"></a>安装 QtMQTT 文档</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">nmake docs<br>nmake install_docs<br></code></pre></td></tr></table></figure><h2 id="安装-qtmqtt-示例-1"><a href="#安装-qtmqtt-示例-1" class="headerlink" title="安装 QtMQTT 示例"></a>安装 QtMQTT 示例</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">nmake sub<span class="hljs-literal">-examples-install_subtargets</span><br></code></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>现在你可以像商业版一样方便地使用 MQTT 模块了。</p><p>简单用法可以参考官方文档 <a href="https://doc.qt.io/QtMQTT/index.html">Qt MQTT</a> 。</p><p>更详细的用法可以参考 QtMQTT 文档和示例。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQTT</tag>
      
      <tag>Qt5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 快速入坑</title>
    <link href="/2020/12/30/cmake-quick-start/"/>
    <url>/2020/12/30/cmake-quick-start/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的工具系列，可用于构建、测试和打包软件。它通过一个名为 <code>CMakeLists.txt</code> 的配置文件来管理软件的编译流程，并根据用户所选择的目标平台生成构建软件所需的本地化 makefile 或 workspace。通俗来讲，使用 CMake 可以生成 UNIX-like 上构建软件所需的 Makefile 和 Windows 上构建软件所需的 vcxproj，而无需为它们单独写一份 Makefile&#x2F;vcxproj 。</p><p><a href="https://cmake.org/documentation/">CMake 官方文档</a>中有详细的使用手册，可以帮助用户更深入地了解 CMake。另外，还有一个详细的使用教程：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial</a>。</p><p>本文以 Ubuntu 20.04 为例，介绍一些 CMake 的日常用法。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu 20.04 下安装 CMake 是十分方便的。通过以下命令安装 GNU C++ compiler、GNU Make 和 CMake：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install g++ make cmake<br></code></pre></td></tr></table></figure><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="Hello World"></a>Hello World</h1><p>创建一个最小组织结构 <code>hello</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> hello &amp;&amp; <span class="hljs-built_in">cd</span> hello &amp;&amp; <span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">touch</span> CMakeLists.txt hello.cpp<br></code></pre></td></tr></table></figure><p>该组织结构的树图为：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">hello/<br>├── <span class="hljs-keyword">build</span><br>├── CMakeLists.txt<br>└── hello.cpp<br></code></pre></td></tr></table></figure><blockquote><p>利用 <code>build</code> 目录来存放 <code>cmake</code> 的输出可以避免项目组织结构被污染。</p></blockquote><p>将 <code>hello.cpp</code> 的内容改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CMakeLists.txt</code> 的内容改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低的 CMake 版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 设置项目名</span><br><span class="hljs-keyword">project</span>(hello)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(hello hello.cpp)<br></code></pre></td></tr></table></figure><blockquote><p>CMake 使用 <code>#</code> 来注释一行。</p></blockquote><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br></code></pre></td></tr></table></figure><p>生成完成后，通过 <code>ls</code> 命令可以看到构建软件所需的 <code>Makefile</code> 文件。此时可以使用以下命令来构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --build .<br></code></pre></td></tr></table></figure><p>执行构建所得的可执行文件 <code>hello</code>，将得到预期的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./hello <br>Hello, World!<br></code></pre></td></tr></table></figure><h1 id="各种项目组织形式"><a href="#各种项目组织形式" class="headerlink" title="各种项目组织形式"></a>各种项目组织形式</h1><h2 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h2><p>单个源文件的场景请参考 <a href="#hello-world">Hello World</a>，如果源文件与 <code>CMakeLists.txt</code> 不在同一个目录下，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello2/<br>├── build<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>└── <span class="hljs-attribute">src</span><br>    └── hello.cpp<br></code></pre></td></tr></table></figure><p>只需要将：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(hello hello.cpp)<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(hello src/hello.cpp)<br></code></pre></td></tr></table></figure><h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><p>多个源文件的场景分两种：单个目录和多个目录。</p><h3 id="单个目录"><a href="#单个目录" class="headerlink" title="单个目录"></a>单个目录</h3><p>创建一个具有多个源文件-单个目录的组织结构 <code>adder</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> adder &amp;&amp; <span class="hljs-built_in">cd</span> adder &amp;&amp; <span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">touch</span> CMakeLists.txt main.cpp adder.cpp adder.h<br></code></pre></td></tr></table></figure><p>该组织结构的树图为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">adder/</span><br><span class="hljs-keyword"></span>├── <span class="hljs-keyword">adder.cpp</span><br><span class="hljs-keyword"></span>├── <span class="hljs-keyword">adder.h</span><br><span class="hljs-keyword"></span>├── <span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>├── CMakeLists.txt<br>└── main.cpp<br></code></pre></td></tr></table></figure><p>将 <code>adder.h</code> 的内容改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ADDER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADDER_H</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>adder.cpp</code> 的内容改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp</code> 的内容改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;adder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 = &quot;</span><br>              &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>              &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CMakeLists.txt</code> 的内容改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低的 CMake 版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 设置项目名</span><br><span class="hljs-keyword">project</span>(adder)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(adder main.cpp adder.cpp)<br></code></pre></td></tr></table></figure><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile，并构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br>cmake --build .<br></code></pre></td></tr></table></figure><p>执行构建所得的可执行文件 <code>adder</code>，将得到预期的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./adder <br>1 + 2 = 3<br></code></pre></td></tr></table></figure><p>这里稍微说明一下 CMake 的 <code>add_executable</code> 命令，它的完整语法为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-built_in">add_executable</span>(&lt;name&gt; <span class="hljs-selector-attr">[WIN32]</span> <span class="hljs-selector-attr">[MACOSX_BUNDLE]</span><br>               <span class="hljs-selector-attr">[EXCLUDE_FROM_ALL]</span><br>               <span class="hljs-selector-attr">[source1]</span> <span class="hljs-selector-attr">[source2 ...]</span>)<br></code></pre></td></tr></table></figure><p>它的作用为从命令所指定的源文件&#x2F;列表（<code>[source1] [source2 ...]</code>）中构建一个可执行文件目标（<code>&lt;name&gt;</code>）。</p><p>将源文件手工地一个个添加到 <code>add_executable</code> 中虽然可行，但不是一种好的办法。CMake 提供了一个 <code>aux_source_directory</code> 命令，它可以帮助用户解决这种手工烦恼，其语法为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">aux<span class="hljs-constructor">_source_directory(&lt;<span class="hljs-params">dir</span>&gt; &lt;<span class="hljs-params">variable</span>&gt;)</span><br></code></pre></td></tr></table></figure><p>该命令会将指定目录（<code>&lt;dir&gt;</code>）下的所有源文件名收集成一个列表，并存放在变量（<code>&lt;variable&gt;</code>）中。所以，我们可以将 <code>CMakeLists.txt</code> 的内容改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低的 CMake 版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 设置项目名</span><br><span class="hljs-keyword">project</span>(adder)<br><br><span class="hljs-comment"># 获取目录下的所有源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC_LIST)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(adder <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>CMake 中，引用变量的语法为 <code>$&#123;variable_name&#125;</code>。</p></blockquote><h3 id="多个目录"><a href="#多个目录" class="headerlink" title="多个目录"></a>多个目录</h3><p>创建一个具有多个源文件-多个目录的组织结构 <code>adder2</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> adder2 &amp;&amp; <span class="hljs-built_in">cd</span> adder2 &amp;&amp; <span class="hljs-built_in">mkdir</span> build math &amp;&amp; <span class="hljs-built_in">touch</span> CMakeLists.txt main.cpp &amp;&amp; <span class="hljs-built_in">touch</span> math/adder.cpp math/adder.h<br></code></pre></td></tr></table></figure><p>该组织结构的树图为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adder2/<br>├── build<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>└── math<br>    ├── adder<span class="hljs-selector-class">.cpp</span><br>    └── adder.h<br></code></pre></td></tr></table></figure><p><code>main.cpp</code>、<code>adder.h</code> 和 <code>adder.cpp</code> 的内容与<a href="#%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6">单个源文件</a>中的相同。</p><p>尝试参考<a href="#%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6">单个源文件</a>中的做法，将 <code>CMakeLists.txt</code> 的内容改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低的 CMake 版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 设置项目名</span><br><span class="hljs-keyword">project</span>(adder)<br><br><span class="hljs-comment"># 获取目录下的所有源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC_LIST)<br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-keyword">math</span> MATH_SRC_LIST)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(adder <span class="hljs-variable">$&#123;SRC_LIST&#125;</span> <span class="hljs-variable">$&#123;MATH_SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile，并构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br>cmake --build .<br></code></pre></td></tr></table></figure><p>然而，这次构建发生了错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cmake --build .<br>Scanning dependencies of target adder<br>[ 33%] Building CXX object CMakeFiles/adder.dir/main.cpp.o<br>/home/dsyx/cmake.demo/adder2/main.cpp:1:10: fatal error: adder.h: No such file or directory<br>    1 | <span class="hljs-comment">#include &quot;adder.h&quot;</span><br>      |          ^~~~~~~~~<br>compilation terminated.<br>make[2]: *** [CMakeFiles/adder.dir/build.make:63: CMakeFiles/adder.dir/main.cpp.o] Error 1<br>make[1]: *** [CMakeFiles/Makefile2:76: CMakeFiles/adder.dir/all] Error 2<br>make: *** [Makefile:84: all] Error 2<br></code></pre></td></tr></table></figure><p>根据输出的错误信息，可以知道找不到头文件 <code>adder.h</code>。在 <code>CMakeLists.txt</code> 中添加以下命令可以修正这个错误：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将 math 目录添加到编译器的 include 搜索列表中</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">math</span>)<br></code></pre></td></tr></table></figure><p>然而，在 CMake 中更推荐的组织方法是将子目录作为库来看待。创建一个具有多个源文件-多个目录的组织结构 <code>adder3</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> adder3 &amp;&amp; <span class="hljs-built_in">cd</span> adder3 &amp;&amp; <span class="hljs-built_in">mkdir</span> build math &amp;&amp; <span class="hljs-built_in">touch</span> CMakeLists.txt main.cpp &amp;&amp; <span class="hljs-built_in">touch</span> math/adder.cpp math/adder.h math/CMakeLists.txt<br></code></pre></td></tr></table></figure><p>该组织结构的树图为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adder3<br>├── build<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>└── math<br>    ├── adder<span class="hljs-selector-class">.cpp</span><br>    ├── adder<span class="hljs-selector-class">.h</span><br>    └── CMakeLists.txt<br></code></pre></td></tr></table></figure><p><code>main.cpp</code>、<code>adder.h</code> 和 <code>adder.cpp</code> 的内容与<a href="#%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6">单个源文件</a>中的相同。</p><p>将 <code>math/CMakeLists.txt</code> 的内容修改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 获取目录下的所有源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(. MATH_SRC_LIST)<br><span class="hljs-comment"># 添加一个库</span><br><span class="hljs-keyword">add_library</span>(<span class="hljs-keyword">math</span> <span class="hljs-variable">$&#123;MATH_SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p><code>CMakeLists.txt</code> 的内容修改为：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 最低的 CMake 版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 设置项目名</span><br><span class="hljs-keyword">project</span>(adder)<br><br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">math</span>)<br><br><span class="hljs-comment"># 获取目录下的所有源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC_LIST)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(adder <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><br><span class="hljs-comment"># 指定目标要链接的库</span><br><span class="hljs-keyword">target_link_libraries</span>(adder <span class="hljs-keyword">math</span>)<br><br><span class="hljs-comment"># 指定在编译给定目标时要使用到的 include 目录</span><br><span class="hljs-keyword">target_include_directories</span>(adder PUBLIC<br>                          <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span><br>                          )<br></code></pre></td></tr></table></figure><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile，并构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br>cmake --build .<br></code></pre></td></tr></table></figure><p>执行构建所得的可执行文件 <code>adder</code>，将得到预期的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./adder <br>1 + 2 = 3<br></code></pre></td></tr></table></figure><h1 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h1><p>本节以<a href="#%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95">多个目录</a>中的 <code>adder3</code> 作为基础。</p><p>在 <code>math/CMakeLists.txt</code> 中添加以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将 math 库安装到 $&#123;CMAKE_INSTALL_PREFIX&#125;/lib 中</span><br><span class="hljs-keyword">install</span>(TARGETS <span class="hljs-keyword">math</span> DESTINATION lib)<br><span class="hljs-comment"># 将 adder.h 文件安装到 adder.h $&#123;CMAKE_INSTALL_PREFIX&#125;/include 中</span><br><span class="hljs-keyword">install</span>(FILES adder.h DESTINATION <span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 中添加以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将可执行文件 adder 安装到 $&#123;CMAKE_INSTALL_PREFIX&#125;/bin 中</span><br><span class="hljs-keyword">install</span>(TARGETS adder DESTINATION bin)<br></code></pre></td></tr></table></figure><p><code>install</code> 命令用来指定要在安装时运行的规则，它的语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(TARGETS &lt;target&gt;... [...])</span></span><br><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span></span><br><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(DIRECTORY &lt;dir&gt;... [...])</span></span><br><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(SCRIPT &lt;file&gt; [...])</span></span><br><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(CODE &lt;code&gt; [...])</span></span><br><span class="hljs-function"><span class="hljs-title">install</span><span class="hljs-params">(EXPORT &lt;export-name&gt; [...])</span></span><br></code></pre></td></tr></table></figure><p>该命令可用的规则十分之多，这里仅说明目前用到的：</p><ul><li><code>TARGETS</code> 指定从项目中安装目标的规则，一般用于指定可执行文件和库。</li><li><code>DESTINATION</code> 指定磁盘上要安装文件的目录。参数可以是相对或绝对路径。如果是相对路径则会使用 <code>CMAKE_INSTALL_PREFIX</code> 变量作为该目录的前缀。</li><li><code>FILES</code> 指定安装项目文件的规则。如果使用的是相对路径则该路径将相对于当前源目录进行解释。</li></ul><blockquote><p><code>CMAKE_INSTALL_PREFIX</code> 有一个默认值，在 UNIX-like 上为 <code>/usr/local</code>；在 Windows 上为 <code>c:/Program Files/$&#123;PROJECT_NAME&#125;</code>。</p></blockquote><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile，并构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br>cmake --build .<br></code></pre></td></tr></table></figure><p>使用 <code>cmake --install .</code> 进行安装，这里使用 <code>--prefix</code> 来替代 <code>CMAKE_INSTALL_PREFIX</code> 的值，放置污染系统目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --install . --prefix ~/cmake.installdir<br></code></pre></td></tr></table></figure><p>安装后可以看到用户目录下存在 <code>cmake.installdir</code>，其组织树图为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cmake.<span class="hljs-keyword">installdir</span><br><span class="hljs-keyword"></span>├── <span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>│   └── <span class="hljs-keyword">adder</span><br><span class="hljs-keyword"></span>├── include<br>│   └── <span class="hljs-keyword">adder.h</span><br><span class="hljs-keyword"></span>└── lib<br>    └── libmath.a<br></code></pre></td></tr></table></figure><p>这里冒出了一个问题，如何删除 CMake 安装的软件呢？CMake 并没有提供 <code>uninstall</code> 命令，但是在 <code>cmake --install</code> 后，会生成一个 <code>install_manifest.txt</code> 文件，这个文件描述了安装的详情。</p><p>为了演示测试功能，我们修改 <code>main.cpp</code> 的内容，使其接受命令行参数（为了方便不做任何异常处理）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;adder.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a = std::<span class="hljs-built_in">stod</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">double</span> b = std::<span class="hljs-built_in">stod</span>(argv[<span class="hljs-number">2</span>]);<br><br>    std::cout &lt;&lt; a<br>              &lt;&lt; <span class="hljs-string">&quot; + &quot;</span><br>              &lt;&lt; b<br>              &lt;&lt; <span class="hljs-string">&quot; = &quot;</span><br>              &lt;&lt; <span class="hljs-built_in">add</span>(a, b)<br>              &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>CMakeLists.txt</code> 的末尾添加以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 启用对此目录及其子目录的测试</span><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-comment"># 添加一个名为 Run 的测试，以测试程序能否正常运行</span><br><span class="hljs-keyword">add_test</span>(NAME Run <span class="hljs-keyword">COMMAND</span> adder <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 添加一个名为 Test_0_0 的测试，以测试 0 + 0 的结果是否符合预期</span><br><span class="hljs-keyword">add_test</span>(NAME Test_0_0 <span class="hljs-keyword">COMMAND</span> adder <span class="hljs-number">0</span> <span class="hljs-number">0</span>)<br><span class="hljs-keyword">set_tests_properties</span>(Test_0_0 PROPERTIES PASS_REGULAR_EXPRESSION <span class="hljs-string">&quot;0 \\+ 0 = 0&quot;</span>)<br><br><span class="hljs-comment"># 添加一个名为 Test_n1_1 的测试，以测试 -1 + 1 的结果是否符合预期</span><br><span class="hljs-keyword">add_test</span>(NAME Test_n1_1 <span class="hljs-keyword">COMMAND</span> adder -<span class="hljs-number">1</span> <span class="hljs-number">1</span>)<br><span class="hljs-keyword">set_tests_properties</span>(Test_n1_1 PROPERTIES PASS_REGULAR_EXPRESSION <span class="hljs-string">&quot;-1 \\+ 1 = 0&quot;</span>)<br><br><span class="hljs-comment"># 添加一个名为 Test_1_100 的测试，以测试 1 + 100 的结果是否符合预期</span><br><span class="hljs-keyword">add_test</span>(NAME Test_1_100 <span class="hljs-keyword">COMMAND</span> adder <span class="hljs-number">1</span> <span class="hljs-number">100</span>)<br><span class="hljs-keyword">set_tests_properties</span>(Test_1_100 PROPERTIES PASS_REGULAR_EXPRESSION <span class="hljs-string">&quot;1 \\+ 100 = 101&quot;</span>)<br><br><span class="hljs-comment"># 添加一个名为 Test_n1_n100 的测试，以测试 -1 + -100 的结果是否符合预期</span><br><span class="hljs-keyword">add_test</span>(NAME Test_n1_n100 <span class="hljs-keyword">COMMAND</span> adder -<span class="hljs-number">1</span> -<span class="hljs-number">100</span>)<br><span class="hljs-keyword">set_tests_properties</span>(Test_n1_n100 PROPERTIES PASS_REGULAR_EXPRESSION <span class="hljs-string">&quot;-1 \\+ -100 = -101&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>add_test</code> 命令将测试添加到要由 <code>ctest</code> 运行的项目中，它的语法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">add_test(NAME <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span> COMMAND <span class="hljs-tag">&lt;<span class="hljs-name">command</span>&gt;</span> [<span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>...]<br>         [CONFIGURATIONS <span class="hljs-tag">&lt;<span class="hljs-name">config</span>&gt;</span>...]<br>         [WORKING_DIRECTORY <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>]<br>         [COMMAND_EXPAND_LISTS])<br></code></pre></td></tr></table></figure><p><code>set_tests_properties</code> 命令用于设置测试的属性，它的语法是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">_tests_properties(<span class="hljs-params">test1</span> [<span class="hljs-params">test2</span><span class="hljs-operator">...</span>] PROPERTIES <span class="hljs-params">prop1</span> <span class="hljs-params">value1</span> <span class="hljs-params">prop2</span> <span class="hljs-params">value2</span>)</span><br></code></pre></td></tr></table></figure><p>其中 <code>PROPERTIES</code> 可以为：</p><ul><li><code>WILL_FAIL</code>：如果设置了该属性，则将反转测试的通过&#x2F;失败标志。</li><li><code>PASS_REGULAR_EXPRESSION</code>：如果设置了该属性，则会根据给出的正则表达式检查测试输出，如果匹配则通过。</li><li><code>FAIL_REGULAR_EXPRESSION</code>：如果设置了该属性，则会根据给出的正则表达式检查测试输出，如果匹配则失败。</li><li><code>TIMEOUT</code>：设置该属性会将测试运行时间限制为指定的秒数。</li></ul><p>将工作目录切换到 <code>build</code> 目录，然后运行 <code>cmake</code> 命令生成本地化的 makefile，并构建软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build/<br>cmake ../<br>cmake --build .<br></code></pre></td></tr></table></figure><p>使用 <code>ctest</code> 命令执行测试：</p><blockquote><p><code>ctest</code> 可执行文件是 CMake 测试驱动程序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ctest<br>Test project /home/dsyx/cmake.demo/adder3/build<br>    Start 1: Run<br>1/5 Test <span class="hljs-comment">#1: Run ..............................   Passed    0.00 sec</span><br>    Start 2: Test_0_0<br>2/5 Test <span class="hljs-comment">#2: Test_0_0 .........................   Passed    0.00 sec</span><br>    Start 3: Test_n1_1<br>3/5 Test <span class="hljs-comment">#3: Test_n1_1 ........................   Passed    0.00 sec</span><br>    Start 4: Test_1_100<br>4/5 Test <span class="hljs-comment">#4: Test_1_100 .......................   Passed    0.00 sec</span><br>    Start 5: Test_n1_n100<br>5/5 Test <span class="hljs-comment">#5: Test_n1_n100 .....................   Passed    0.00 sec</span><br><br>100% tests passed, 0 tests failed out of 5<br><br>Total Test time (real) =   0.01 sec<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
